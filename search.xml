<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AndroidStudio中使用Aliyun Maven</title>
    <url>/2017/07/06/AndroidStudio%E4%B8%AD%E4%BD%BF%E7%94%A8Aliyun%20Maven/</url>
    <content><![CDATA[<Contents>
<blockquote>
<p>转载请注明出处<br />
<a href="http://blog.csdn.net/guodongAndroid/article/details/74598095">http://blog.csdn.net/guodongAndroid/article/details/74598095</a><br />
本文来自<a href="http://sunxiaodou.com">【孫小逗的博客】</a></p>
</blockquote>
<h2 id="androidstudio中使用aliyun-maven"><a class="markdownIt-Anchor" href="#androidstudio中使用aliyun-maven"></a> AndroidStudio中使用Aliyun Maven</h2>
<p>Aliyun Maven地址：<a href="http://maven.aliyun.com">http://maven.aliyun.com</a></p>
<p>在项目级别的build.gradle中添加如下Maven地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven&#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span>&#125;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&#x27;com.android.tools.build:gradle:2.3.3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven&#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span>&#125;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=135768&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>androidstudio</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中关于scrollBy的一点点心得</title>
    <url>/2016/06/01/Android%E4%B8%AD%E5%85%B3%E4%BA%8EscrollBy%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<Contents>
<blockquote>
<p>转载请注明出处<br />
<a href="http://blog.csdn.net/guodongandroid/article/details/51558131">http://blog.csdn.net/guodongandroid/article/details/51558131</a><br />
本文来自<a href="http://www.sunxiaodou.com">【孫小逗的博客】</a></p>
</blockquote>
<h3 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述"></a> 一、概述</h3>
<p>最近对自定义View和动画进行了研究学习，同时之前不太明白的地方也豁然开朗。学习不是一下子就学会的，不懂的地方，在后续的学习过程中会慢慢的理解，有种拨云见日的感觉。<br />
scrollBy(int dx, int dy)主要用于滑屏操作，第一个参数dx代表滑屏后与滑屏前的x坐标之差，第二个参数dy同理。那下面我们来试试吧。</p>
<h3 id="二-自定义view使用scrollby"><a class="markdownIt-Anchor" href="#二-自定义view使用scrollby"></a> 二、自定义View，使用scrollBy</h3>
<p>首先我们新建了类DragView继承自Button</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DragView</span> <span class="keyword">extends</span> <span class="title class_">Button</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mDownX;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mDownY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DragView</span><span class="params">(Context context)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DragView</span><span class="params">(Context context, AttributeSet attrs)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DragView</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        setBackgroundColor(<span class="number">0x88FF0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mDownX = (<span class="type">int</span>) event.getX();</span><br><span class="line">                mDownY = (<span class="type">int</span>) event.getY();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="type">int</span> <span class="variable">mX</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">                <span class="type">int</span> <span class="variable">mY</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">dX</span> <span class="operator">=</span> mX - mDownX;</span><br><span class="line">                <span class="type">int</span> <span class="variable">dY</span> <span class="operator">=</span> mY - mDownY;</span><br><span class="line"></span><br><span class="line">                scrollBy(dX, dY);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们设置了浅红色的背景，声明了两个全局变量，并重写了onTouchEvent方法，里面判断了单击和滑动事件，单击时记录x和y的坐标，赋值给mDownX和mDownY，滑动的时候也获取x和y的坐标，和单击时的坐标相减取得偏移量，调用scrollBy方法。</p>
<p>然后，我们在布局中使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.sun.androidqyz.DragView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;100dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>很简单吧，效果图如下：</p>
<p><img data-src="http://img.blog.csdn.net/20160601180554090" alt="这里写图片描述" /></p>
<p>咦，咋滑不动呢？（我是真的滑了，不是在滑动鼠标）先不管为啥拖不动。我们在布局中添加几个属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.sun.androidqyz.DragView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/app_name&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，为自定义的View增加了android:text属性，重新运行程序，看看效果如何：</p>
<p><img data-src="http://img.blog.csdn.net/20160601181009530" alt="这里写图片描述" /></p>
<p>哈，现在是不是可以看到滑动的效果了呢？不对啊，我们明明自定义的View，现在为啥拖动的不是View而是View里面的字呢，啥子情况哦？</p>
<p>其实呢，在自定义View中直接调用scrollBy滑动的是View的Content内容，对于Button，它的Content就是文本，ImageView就是drawable了。</p>
<p>还有一个问题，不知你们发现没有？开始滑动时，可以看到鼠标是向上滑动的，按照人们的正常思维，那“AndroidQYZ”这几个字母也应该向上滑动才对，而现在是向下滑动。</p>
<p>这个就不太好理解了。做iOS开发的同学肯定用过UIScrolView，没错，看到这我才明白Android和iOS这么相似。其实是这样的：首先我们就要知道布局是没有边界的，就像很大一块画布，而手机屏幕就像是一个放大镜，放大了画布上的一小部分内容，当我们滑动屏幕时，画布是没有滑动的，滑动的是放大镜，就是我们的屏幕，可以这也说，当放大镜向上滑动时，我们就可以看到画布在向下滑动，这就是为啥鼠标明明向上滑动，而“AndroidQYZ”这几个字母却向下滑动的原因了，既然我们知道了为啥，那怎么修改呢？</p>
<p>我们先修改第二个问题，代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">scroll<span class="constructor">By(-<span class="params">dX</span>, -<span class="params">dY</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>so easy，没错，我们取了负值就可以了，不信？我们可以看看效果：</p>
<p><img data-src="http://img.blog.csdn.net/20160601182849991" alt="这里写图片描述" /></p>
<p>可以看到，“AndroidQYZ”这几个字母已经跟随鼠标的移动而移动了，可还是没有让自定义View滑动呀，你这不是骗人嘛？不着急，之前说直接调用scrollBy滑动的是Content，这就简单了，我们直接调用自定义View的父View的scrollBy不就好了嘛，看下面：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">((View) get<span class="constructor">Parent()</span>).scroll<span class="constructor">By(-<span class="params">dX</span>, -<span class="params">dY</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>getParent()方法获取此View的ViewParent并强转为View，再调用scrollBy方法，要不要看看效果呢？就怕你们不信。</p>
<p><img data-src="http://img.blog.csdn.net/20160601183447763" alt="这里写图片描述" /></p>
<p>哈哈，怎么样，可以滑动了吧。当然还有scrollTo方法，大家可以自己去试试。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=135768&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>scrollBy</tag>
      </tags>
  </entry>
  <entry>
    <title>Android事件分发、拦截与处理的理解</title>
    <url>/2016/06/21/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E3%80%81%E6%8B%A6%E6%88%AA%E4%B8%8E%E5%A4%84%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<Contents>
<blockquote>
<p>转载请注明出处<br />
<a href="http://blog.csdn.net/guodongAndroid/article/details/51727272">http://blog.csdn.net/guodongAndroid/article/details/51727272</a><br />
本文来自<a href="www.sunxiaodou.com">【孫小逗的博客】</a></p>
</blockquote>
<h2 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述"></a> 一、概述</h2>
<p>昨天，某位黑同学问了个很奇葩的问题：禁止ViewPager的左右滑动。好吧，被问到的一瞬间就想是不是他傻X。ViewPager不滑动，干嘛还要用ViewPager，唉，无语。无语归无语，事情还是要干的。随手给他写了个自定义的ViewPager。。。。(吹牛一点都不好)</p>
<h2 id="二-事件分发-拦截与处理"><a class="markdownIt-Anchor" href="#二-事件分发-拦截与处理"></a> 二、事件分发、拦截与处理</h2>
<p>首先需要知道事件分发、拦截与处理分别对应着</p>
<ol>
<li>dispatchTouchEvent(MotionEvent ev)</li>
<li>onInterceptTouchEvent(MotionEvent ev)</li>
<li>onTouchEvent(MotionEvent event)</li>
</ol>
<p>ViewGroup比View多了<code>onInterceptTouchEvent(MotionEvent ev)</code>方法，即事件拦截方法。因为ViewGroup可以包含子View，所以与子View的事件有冲突时可以进行拦截。</p>
<p>这三个方法默认返回值都为false。</p>
<p>下面看个例子会更容易理解：<br />
自定义了两个LinearLayout和一个View，代码如下：</p>
<p>FirstViewGroup.java</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstViewGroup</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = <span class="string">&quot;FirstViewGroup&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstViewGroup</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstViewGroup</span><span class="params">(Context context, AttributeSet attrs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        setBackgroundColor(<span class="number">0x88FF0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;dispatchTouchEvent:&quot;</span> + ev.getAction());</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">dispatchTouchEvent</span><span class="params">(ev)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onInterceptTouchEvent:&quot;</span> + ev.getAction());</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onInterceptTouchEvent</span><span class="params">(ev)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onTouchEvent:&quot;</span> + event.getAction());</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onTouchEvent</span><span class="params">(event)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SecondViewGroup.java</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondViewGroup</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = <span class="string">&quot;SecondViewGroup&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecondViewGroup</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecondViewGroup</span><span class="params">(Context context, AttributeSet attrs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecondViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        setBackgroundColor(<span class="number">0x88FFFF00</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;dispatchTouchEvent:&quot;</span> + ev.getAction());</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">dispatchTouchEvent</span><span class="params">(ev)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onInterceptTouchEvent:&quot;</span> + ev.getAction());</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onInterceptTouchEvent</span><span class="params">(ev)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onTouchEvent:&quot;</span> + event.getAction());</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onTouchEvent</span><span class="params">(event)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyView.java</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = <span class="string">&quot;MyView&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        setBackgroundColor(<span class="number">0x6600FF00</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;dispatchTouchEvent: &quot;</span> + event.getAction());</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">dispatchTouchEvent</span><span class="params">(event)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onTouchEvent: &quot;</span> + event.getAction());</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onTouchEvent</span><span class="params">(event)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到两个ViewGroup实现了事件分发、拦截与处理三个方法，并打印了Log，MyView实现了事件分发与处理两个方法，也打印了Log。</p>
<p>下面看看布局文件：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">              android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">              android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">              android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com<span class="selector-class">.sun</span><span class="selector-class">.androidqyz</span><span class="selector-class">.FirstViewGroup</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:<span class="attribute">padding</span>=<span class="string">&quot;40dp&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;com<span class="selector-class">.sun</span><span class="selector-class">.androidqyz</span><span class="selector-class">.SecondViewGroup</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:<span class="attribute">padding</span>=<span class="string">&quot;60dp&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">            &lt;com<span class="selector-class">.sun</span><span class="selector-class">.androidqyz</span><span class="selector-class">.MyView</span></span><br><span class="line">                android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">                android:layout_height=<span class="string">&quot;match_parent&quot;</span>/&gt;</span><br><span class="line">        &lt;/com<span class="selector-class">.sun</span><span class="selector-class">.androidqyz</span>.SecondViewGroup&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/com<span class="selector-class">.sun</span><span class="selector-class">.androidqyz</span>.FirstViewGroup&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>
<p>效果如图所示：<br />
<img data-src="http://img.blog.csdn.net/20160621140248957" alt="这里写图片描述" /></p>
<p>可以看到最外层的ViewGroup的背景色是浅红色，第二层的ViewGroup的背景色是橙色，最里面的View背景色是绿色。</p>
<p>现在我们点击最外层的ViewGroup，看下打印的Log如下：<br />
<img data-src="http://img.blog.csdn.net/20160621140718608" alt="这里写图片描述" /></p>
<p>可以发现事件处理的顺序是先调用事件分发(dispatchTouchEvent)——&gt;事件拦截(onInterceptTouchEvent)——&gt;事件处理(onTouchEvent)</p>
<p>接下来我们点击第二层ViewGroup，看下打印的Log如下：<br />
<img data-src="http://img.blog.csdn.net/20160621141112922" alt="这里写图片描述" /></p>
<p>可以发现现在事件处理的顺序是先调用FirstViewGroup事件分发(dispatchTouchEvent)——&gt;FirstViewGroup事件拦截(onInterceptTouchEvent)——&gt;SecondViewGroup事件分发(dispatchTouchEvent)——&gt;SecondViewGroup事件拦截(onInterceptTouchEvent)——&gt;SecondViewGroup事件处理(onTouchEvent)——&gt;FirstViewGroup事件处理(onTouchEvent)</p>
<p>相信看到这，当我们点击MyView的时候，打印的Log您已经知道是什么了，让我们看看吧：<br />
<img data-src="http://img.blog.csdn.net/20160621141627195" alt="这里写图片描述" /></p>
<p>是不是和你想的一样呢？事件的分发、拦截与处理就像现实生活中领导A分发个任务给领导B，领导再把任务分发给你(MyView)，你处理(onTouchEvent)完时需要向上汇报给领导B，领导B处理(onTouchEvent)完，再汇报给领导A。</p>
<p>在自定义控件时，很少去复写dispatchTouchEvent方法，所以这里我们只看事件拦截(onInterceptTouchEvent)。</p>
<p>如果领导A觉得这个任务自己就可以完成，就不去派给领导B，我们就把FirstViewGroup的onInterceptTouchEvent方法返回true，当我们点击SecondViewGroup或MyView时，我们看下Log：<br />
<img data-src="http://img.blog.csdn.net/20160621142644803" alt="这里写图片描述" /></p>
<p>说明此时领导A已经把任务拦截下，自己处理了，如果领导B拦截了任务会是怎样的呢？点击MyView时的Log如下：<br />
<img data-src="http://img.blog.csdn.net/20160621142953355" alt="这里写图片描述" /></p>
<p>如果你(MyView)受不了领导的压迫，要反抗，处理完任务后返回了true，点击MyView的Log如下：<br />
<img data-src="http://img.blog.csdn.net/20160621143752257" alt="这里写图片描述" /></p>
<p>看来是真要反抗了，处理完任务都不向领导汇报了。</p>
<h2 id="三-总结"><a class="markdownIt-Anchor" href="#三-总结"></a> 三、总结</h2>
<p>Android事件分发、拦截与处理是个复杂的过程，在开发的过程中运用的场景也很多，是Android开发必须掌握的技能。现在回过头来，不从源码的角度看看Android的事件分发、拦截与处理和现实生活中的领导分派任务又有什么区别呢？</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=135768&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title>View滑动冲突的两种解决方式</title>
    <url>/2016/09/13/View%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<Contents>
<blockquote>
<p>转载请注明出处<br />
<a href="http://blog.csdn.net/guodongAndroid/article/details/52530227">http://blog.csdn.net/guodongAndroid/article/details/52530227</a><br />
本文来自<a href="http://www.sunxiaodou.com">【孫小逗的博客】</a></p>
</blockquote>
<h2 id="view滑动冲突的两种解决方式"><a class="markdownIt-Anchor" href="#view滑动冲突的两种解决方式"></a> View滑动冲突的两种解决方式</h2>
<h3 id="1-外部拦截法"><a class="markdownIt-Anchor" href="#1-外部拦截法"></a> 1、外部拦截法</h3>
<p>所谓外部拦截法是指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突问题，这种方法比较符合点击事件的分发机制。外部拦截法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可，这种方法的伪代码如下所示：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">bool</span>ean onInterceptTouchEvent(MotionEvent ev)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">bool</span>ean <span class="built_in">int</span>ercepted = <span class="literal">false</span>;</span><br><span class="line">       <span class="built_in">int</span> x = (<span class="built_in">int</span>) ev.getX();</span><br><span class="line">       <span class="built_in">int</span> y = (<span class="built_in">int</span>) ev.getY();</span><br><span class="line">       <span class="built_in">int</span> action = ev.getAction();</span><br><span class="line">       <span class="keyword">switch</span> (action)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">int</span>ercepted = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (父容器需要当前点击事件)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">int</span>ercepted = <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">int</span>ercepted = <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">int</span>ercepted = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLastXIntercept = x;</span><br><span class="line">       mLastYIntercept = y;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">int</span>ercepted;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是外部拦截法的典型逻辑，针对不同的滑动冲突，只需要修改父容器需要当前点击事件的条件即可，其他均不需要修改而且也不能修改。在onInterceptTouchEvent方法中，首先是ACTION_DOWN这个事件，父容器必须返回false，即不拦截DOWN事件，这是因为一旦父容器拦截了DOWN事件，那么后续的MOVE和UP事件都会直接交由父容器处理，这个时候事件没法再传递给子元素了；其次是ACTION_MOVE事件，这个事件可以根据需求来决定是否拦截，如果父容器需要拦截就返回true，否则返回false；最后是ACTION_UP事件，这里必须返回false。</p>
<h3 id="2-内部拦截法"><a class="markdownIt-Anchor" href="#2-内部拦截法"></a> 2、内部拦截法</h3>
<p>内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法不符合事件分发机制，需要配合requstDisallowInterceptTouchEvent方法才能正常工作，使用起来较外部拦截法稍显复杂，需要重写子元素的dispatchTouchEvent方法，这种方法的伪代码如下所示：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">       <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">       <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">switch</span> (action)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">           &#123;</span><br><span class="line">               parentView.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>); <span class="comment">// parentView为父容器</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span> deltaX = x - mLastDiapatchX;</span><br><span class="line">               <span class="keyword">int</span> deltaY = y - mLastDiapatchY;</span><br><span class="line">               <span class="keyword">if</span> (父容器需要此点击事件)</span><br><span class="line">               &#123;</span><br><span class="line">                   parentView.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>); <span class="comment">// parentView为父容器</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLastDiapatchX = x;</span><br><span class="line">       mLastDiapatchY = y;</span><br><span class="line">       <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">dispatchTouchEvent</span><span class="params">(ev)</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是内部拦截法的典型代码，当面对不同的滑动冲突时只需要修改里面的条件即可，其他不需要改动而且也不能改动。除了子元素需要做处理以外，父容器也需要默认拦截除了ACTION_DOWN以外的其他事件，这样当子元素调用<code>parentView.requestDisallowInterceptTouchEvent(false)</code>方法时，父容器才能继续拦截所需事件。父容器为什么不拦截DOWN事件已在外部拦截法中叙述，父容器的改动如下所示：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">       <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=135768&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title>Java通过ESL连接FreeSWITCH</title>
    <url>/2017/08/02/java-esl-freeswitch/</url>
    <content><![CDATA[<Contents>
<blockquote>
<p>转载请注明出处</p>
<p><a href="http://sunxiaodou.com/2017/08/02/Java%E9%80%9A%E8%BF%87ESL%E8%BF%9E%E6%8E%A5FreeSWITCH/">http://sunxiaodou.com/2017/08/02/Java通过ESL连接FreeSWITCH/</a></p>
<p>本文来自<a href="http://sunxiaodou.com">【孫小逗的博客】</a></p>
</blockquote>
<h2 id="java通过esl连接freeswitch"><a class="markdownIt-Anchor" href="#java通过esl连接freeswitch"></a> Java通过ESL连接FreeSWITCH</h2>
<h3 id="创建gradle项目"><a class="markdownIt-Anchor" href="#创建gradle项目"></a> 创建Gradle项目</h3>
<p>首先我们创建一个基于Gradle的Java工程，并添加FreeSWITCH ESL的Java依赖。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">&#x27;org.freeswitch.esl.client:org.freeswitch.esl.client:0.9.2&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/freeswitch/QQ20170802-152052@2x.png" alt="Project" /></p>
<p>创建ESLTest.java文件，并添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ESLTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;192.168.1.22&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8021</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;ClueCon&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">job_UUID</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        InBound();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">InBound</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.connect(HOST, PORT, PASSWORD, <span class="number">20</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Connect Failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        client.addEventListener(<span class="keyword">new</span> <span class="title class_">IEslEventListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eventReceived</span><span class="params">(EslEvent event)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.getEventName().equals(<span class="string">&quot;CHANNEL_ANSWER&quot;</span>)) &#123; <span class="comment">//</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;通道应答&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getEventName().equals(<span class="string">&quot;HEARTBEAT&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到心跳 --&gt; &quot;</span> + event.getEventBodyLines());</span><br><span class="line">                    job_UUID = client.sendAsyncApiCommand(<span class="string">&quot;status&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Job_UUID --&gt; &quot;</span> + job_UUID);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getEventName().equals(<span class="string">&quot;CHANNEL_DESTROY&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;通道销毁&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getEventName().equals(<span class="string">&quot;CHANNEL_HANGUP_COMPLETE&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">//挂断</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;通道挂断完成&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getEventName().equals(<span class="string">&quot;CHANNEL_CREATE&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;通道创建&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backgroundJobResultReceived</span><span class="params">(EslEvent event)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> event.getEventHeaders().get(<span class="string">&quot;Job-UUID&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (job_UUID.equals(uuid)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String s : event.getEventBodyLines()) &#123;</span><br><span class="line">                        System.out.println(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        client.setEventSubscriptions(<span class="string">&quot;plain&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们使用InBound模式与FreeSWITCH进行连接，我这边的FreeSWITCH运行在192.168.1.22机器上，InBound模式默认是8021端口，密码默认为ClueCon，20为连接超时时长，单位秒。</p>
<p>FreeSWITCH每隔20秒会发送心跳事件，代码中收到心跳事件，会发送一个异步API去查看FreeSWITCH的状态，并返回一个Job_UUID，异步完成后通过<code>backgroundJobResultReceived</code>回调执行结果。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=5272940&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>FreeSwitch</category>
      </categories>
      <tags>
        <tag>FreeSWITCH</tag>
        <tag>ESL</tag>
        <tag>InBound</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Kotlin开发Android(一) Kotlin开发环境搭建</title>
    <url>/2017/07/11/%E4%BD%BF%E7%94%A8Kotlin%E5%BC%80%E5%8F%91Android(%E4%B8%80)Kotlin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<Contents>
<blockquote>
<p>转载请注明出处</p>
<p><a href="http://sunxiaodou.com/2017/07/11/%E4%BD%BF%E7%94%A8Kotlin%E5%BC%80%E5%8F%91Android(%E4%B8%80)Kotlin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">http://sunxiaodou.com/2017/07/11/使用Kotlin开发Android(一)Kotlin开发环境搭建/</a></p>
<p>本文来自<a href="http://sunxiaodou.com">【孫小逗的博客】</a></p>
</blockquote>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>Kotlin：<a href="http://kotlinlang.org">官网</a><br />
Kotlin语法：<a href="https://huanglizhuo.gitbooks.io/kotlin-in-chinese/content/GettingStarted/Basic-Syntax.html">基本语法-中文</a></p>
<p>Kotlin教程：<a href="https://www.youtube.com/watch?v=H_oGi8uuDpA">视频教程</a></p>
<h2 id="kotlin-for-android"><a class="markdownIt-Anchor" href="#kotlin-for-android"></a> Kotlin for Android</h2>
<h3 id="androidstudio集成kotlin插件"><a class="markdownIt-Anchor" href="#androidstudio集成kotlin插件"></a> AndroidStudio集成Kotlin插件</h3>
<ol>
<li>
<p>打开AndroidStudio的Preferences界面，选择Plugins，点击箭头所指按钮</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/plugins1.png" alt="Install JetBrains plugins" /></p>
</li>
<li>
<p>输入Kotlin搜索插件</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/plugins2.png" alt="搜索Kotlin" /></p>
</li>
<li>
<p>因为我已经安装过了，所以没有了Install按钮。</p>
</li>
<li>
<p>如果你按照如上步骤安装插件，你可能会发现下载的很慢。是不是很坑爹，既然下载的那么慢，你还啰嗦辣么久，😆，有些事总得自己捣鼓捣鼓。</p>
</li>
<li>
<p>使用离线安装Kotlin插件。<a href="https://plugins.jetbrains.com/plugin/6954-kotlin">Kotlin插件下载地址</a>。下载带有“Studio&quot;字样的文件，”IJ“是给IntelliJ IDEA使用的。</p>
<p>(⊙o⊙)哦，记得使用迅雷等软件下载哦😂</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/QQ20170711-200501@2x.png" alt="kotlin离线下载" /></p>
</li>
<li>
<p>根据下图离线安装，安装完成重启AndroidStudio即可。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/pugin%1Cs3.png" alt="Install plugins from disk" /></p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/plugins4.png" alt="选择kotlin插件" /></p>
</li>
</ol>
<h3 id="hello-kotlin"><a class="markdownIt-Anchor" href="#hello-kotlin"></a> Hello Kotlin</h3>
<p>像平常一样创建一个项目，如</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/QQ20170711-202047@2x.png" alt="MyKoltin" /></p>
<p>然后点击Code，选择Convert Java File to Kotlin File，即可把Java文件无缝转换为Kotlin文件</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/QQ20170711-202821@2x.png" alt="convert java to kotlin" /></p>
<p>转换后的kotlin文件</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/koltlin.png" alt="kotlin文件" /></p>
<p>现在我们点击同步按钮，并配置Kotlin，如下图</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/config.png" alt="configure" /></p>
<p>在下拉列表中选择最新最新的Kotlin版本，点击OK，最后点击右上角的Sync Now按钮。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/xuanzhe.png" alt="version" /></p>
<p>稍等片刻，就会自动打开项目级别和Module级别的build.gradle文件。如下图，kotlin配置完成</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/mykotlin.png" alt="MyKotlin build.gradle" /></p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/app.png" alt="app build.gradle" /></p>
<p>不出意外的话，我们就可以运行看到Hello World了😆</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/MyKotlin-Run.png" alt="hello world" /></p>
<p>说好的Hello Kotlin呢？？？在app的build.gradle加入以下内容并同步项目。此拓展可以省去findViewById()，直接使用控件的id。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;kotlin-android-extensions&#x27;</span></span><br></pre></td></tr></table></figure>
<p>现在我们就可以给TextView添加一个id —&gt; kotlin。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/id.png" alt="id" /></p>
<p>在MainActivity.kt文件中添加如下代码，我们的Hello Kotlin就完成了。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/hello%20kotlin.png" alt="hello kotlin" /></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=135768&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AndroidStudio</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Nexus搭建本地Maven仓库</title>
    <url>/2017/10/17/%E4%BD%BF%E7%94%A8Nexus%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0Maven%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<Contents>
<blockquote>
<p>转载请注明出处</p>
<p><a href="http://sunxiaodou.com/2017/08/02/Java%E9%80%9A%E8%BF%87ESL%E8%BF%9E%E6%8E%A5FreeSWITCH/">http://sunxiaodou.com/2017/10/17/使用Nexus搭建本地Maven仓库/</a></p>
<p>本文出自<a href="http://sunxiaodou.com">【孫小逗的博客】</a></p>
</blockquote>
<h2 id="使用nexus搭建本地maven仓库"><a class="markdownIt-Anchor" href="#使用nexus搭建本地maven仓库"></a> 使用Nexus搭建本地Maven仓库</h2>
<h3 id="安装nexus"><a class="markdownIt-Anchor" href="#安装nexus"></a> 安装Nexus</h3>
<p><a href="https://www.sonatype.com/download-oss-sonatype">下载Nexus</a></p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/nexus_install/nexus_download.png" alt="nexus_download" /></p>
<p>下载Mac版本的，最新版本为3.6.0-02。解压后放在本地。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/nexus_install/nexus_bin.png" alt="nexus_bin" /></p>
<p>在终端里CD进入nexus的bin目录，运行<code>./nexus start</code></p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/nexus_install/start_nexus.png" alt="start_nexus" /></p>
<p>没有错误的话，此时nexus已经启动，可以在浏览器中输入<code>http://localhost:8081/</code>进行访问，nexus默认监听8081端口。出现以下界面表示nexus安装完成。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/nexus_install/nexus_manager.png" alt="nexus_manager" /></p>
<h3 id="创建本地仓库"><a class="markdownIt-Anchor" href="#创建本地仓库"></a> 创建本地仓库</h3>
<p>在浏览器中点击Sign in按钮以登录nexus，默认用户名admin，默认密码admin123。根据以下步骤创建仓库。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/nexus_install/create_repository_a.png" alt="create_repository_a" /></p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/nexus_install/select_recipe.png" alt="select_recipe" /></p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/nexus_install/create_repository_b.png" alt="create_repository_b" /></p>
<p>点击Create repository按钮即可创建本地仓库。</p>
<h3 id="androidstudio上传库到本地仓库并引用"><a class="markdownIt-Anchor" href="#androidstudio上传库到本地仓库并引用"></a> AndroidStudio上传库到本地仓库并引用</h3>
<h4 id="上传"><a class="markdownIt-Anchor" href="#上传"></a> 上传</h4>
<p>在我们的项目库下新建nexus_maven.gradle文件，并添加以下内容。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/nexus_install/create_nexus_gradle.png" alt="create_nexus_gradle" /></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line"></span><br><span class="line">task androidJavadocs(<span class="attr">type:</span> Javadoc) &#123;</span><br><span class="line">    source = android.sourceSets.main.java.srcDirs</span><br><span class="line">    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task androidJavadocsJar(<span class="attr">type:</span> Jar, <span class="attr">dependsOn:</span> androidJavadocs) &#123;</span><br><span class="line">    classifier = <span class="string">&#x27;javadoc&#x27;</span></span><br><span class="line">    from androidJavadocs.destinationDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task androidSourcesJar(<span class="attr">type:</span> Jar) &#123;</span><br><span class="line">    classifier = <span class="string">&#x27;sources&#x27;</span></span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives androidSourcesJar</span><br><span class="line">    archives androidJavadocsJar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(<span class="attr">url:</span> <span class="string">&quot;http://localhost:8081/repository/test/&quot;</span>) &#123; <span class="comment">// 此处的test为本地仓库名称</span></span><br><span class="line">                authentication(<span class="attr">userName:</span> <span class="string">&quot;admin&quot;</span>, <span class="attr">password:</span> <span class="string">&quot;admin123&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            pom.project &#123;</span><br><span class="line">                name <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">                version <span class="string">&#x27;0.0.1&#x27;</span></span><br><span class="line">                artifactId <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">                groupId <span class="string">&#x27;com.guodongandroid.test&#x27;</span></span><br><span class="line">                packaging <span class="string">&#x27;aar&#x27;</span></span><br><span class="line">                description <span class="string">&#x27;xxx xxx xxx&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们库的build.gradle文件最后引用这个nexus_maven.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">from:</span> <span class="string">&#x27;nexus_maven.gradle&#x27;</span></span><br></pre></td></tr></table></figure>
<p>最后执行上传操作。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/nexus_install/uploadArchives.png" alt="uploadArchives" /></p>
<p>此时可以在本地仓库test中看到刚刚上传的文件。</p>
<h4 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h4>
<p>在Project级别的build.gradle文件的allprojects中添加如下代码:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">maven &#123;</span><br><span class="line">   url <span class="string">&#x27;http://localhost:8081/repository/test/&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Module级别的build.gradle文件中添加如下依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">&#x27;com.guodongandroid.test:xxx:0.0.1@aar&#x27;</span></span><br></pre></td></tr></table></figure>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=135768&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>Nexus</category>
      </categories>
      <tags>
        <tag>Nexus</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>使用秒级编译方案-Freeline</title>
    <url>/2017/01/07/%E4%BD%BF%E7%94%A8%E7%A7%92%E7%BA%A7%E7%BC%96%E8%AF%91%E6%96%B9%E6%A1%88-Freeline/</url>
    <content><![CDATA[<Contents>
<blockquote>
<p>转载请注明出处<br />
<a href="http://blog.csdn.net/guodongandroid/article/details/54174776">http://blog.csdn.net/guodongandroid/article/details/54174776</a><br />
本文来自<a href="http://www.sunxiaodou.com">【孫小逗的博客】</a></p>
</blockquote>
<h1 id="使用秒级编译方案-freeline"><a class="markdownIt-Anchor" href="#使用秒级编译方案-freeline"></a> 使用秒级编译方案-Freeline</h1>
<h2 id="一-关于freeline"><a class="markdownIt-Anchor" href="#一-关于freeline"></a> 一、关于Freeline</h2>
<p>Freeline是蚂蚁金服旗下开发的一个基于动态替换的编译方案，运用到项目后可以极大的提高项目编译速度。相比较现在的instant-run，buck，layoutcast等方案快数倍。<br />
<a href="https://github.com/alibaba/freeline" title="开源地址">GitHub地址</a><br />
<a href="https://www.freelinebuild.com/">官网</a></p>
<h2 id="二-集成freeline"><a class="markdownIt-Anchor" href="#二-集成freeline"></a> 二、集成Freeline</h2>
<p>这里只说Windows下的集成，Linux/Mac 请自行百度/Google。（屌丝没有MacBook）</p>
<h3 id="1-集成前的准备"><a class="markdownIt-Anchor" href="#1-集成前的准备"></a> 1、集成前的准备</h3>
<p>你需要提前安装 Python 2.7+（Freeline 暂时还不支持 Python 3+），安装完之后需要重启一下 Android Studio。<br />
<a href="https://www.python.org/downloads/release/python-2713/">Python 2.7.13下载地址</a></p>
<h3 id="2-如何集成"><a class="markdownIt-Anchor" href="#2-如何集成"></a> 2、如何集成</h3>
<p>提供了两种方式集成Freeline，最简单的方法是通过 Android Studio 的插件来集成（实际上是对命令行的方式做了封装，提供自动化的解决方案），另一种则是手工通过修改配置与执行命令的方式来集成。<br />
<font color="#F00F0">建议使用方法二，自己先捣鼓一遍，最后使用插件。</font><br />
<strong>方法一：Android Studio 插件</strong><br />
在最新版本的 Freeline 插件中，提供了自动化一键接入的方式，不需要像以前一样手动修改	<font color="#FF00FF">build.gradle</font>	配置文件了.</p>
<p>在Android Studio中，通过以下路径	<font color="#FF00FF">Preferences → Plugins → Browse repositories</font>	，搜索“freeline”，并安装，安装完成重启AS。</p>
<p><img data-src="http://img.blog.csdn.net/20170107144204312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvZG9uZ0FuZHJvaWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Freeline" /></p>
<p>直接点击	<font color="#FF00FF">Run Freeline</font> 的按钮，就可以享受Freeline带来的开发效率的提升啦（会先需要一个较为耗时的全量编译过程）。</p>
<p>第一次使用的时候，插件会自动检测是否安装了 Freeline，如果没有安装的话会弹出提示，按照提示点击“确定”，插件就会自动为你修改配置文件，并自动安装 Freeline 的依赖文件。</p>
<p><strong>方法二：命令行方式</strong><br />
配置 project-level 的 build.gradle，加入 freeline-gradle 的依赖：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">classpath &#x27;com.antfortune.freeline:gradle:<span class="keyword">x</span>.<span class="keyword">x</span>.<span class="keyword">x</span>&#x27;</span><br></pre></td></tr></table></figure>
<p><img data-src="http://img.blog.csdn.net/20170107144549590?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvZG9uZ0FuZHJvaWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" /></p>
<p>然后，在你的主 module 的 build.gradle 中，应用 freeline 插件的依赖：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apply</span> plugin: <span class="string">&#x27;com.antfortune.freeline&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="http://img.blog.csdn.net/20170107144659841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvZG9uZ0FuZHJvaWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" /></p>
<p>最后，在命令行执行以下命令来下载 freeline 的 python 和二进制依赖。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Windows<span class="selector-attr">[CMD]</span>: gradlew initFreeline</span><br></pre></td></tr></table></figure>
<p><font color="#F00F0" size = 4>注意！注意！注意！</font></p>
<ul>
<li>在CMD下执行命令需要CD到项目根目录，在AS下的Terminal可以直接执行。</li>
<li>对于国内的同学，如果你在下载的时候速度很慢，你也可以加上参数，执行 <font color="#FF00FF">gradlew initFreeline -Pmirror</font>，这样就会从国内镜像地址来下载。<font color="#F00F0" size = 4>（推荐使用）</font></li>
<li>在执行的过程中，freeline可能会下载一些东西，有时候因为网络的样子会下载很慢，比如这样子的：</li>
</ul>
<p><img data-src="http://img.blog.csdn.net/20170107145754803?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvZG9uZ0FuZHJvaWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" /></p>
<p>这时候可以提前下载对应版本的<a href="https://services.gradle.org/distributions/">gradle</a>，然后将下载好的zip文件放入这个目录下，freeline会自动解压：</p>
<p><img data-src="http://img.blog.csdn.net/20170107154826832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvZG9uZ0FuZHJvaWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" /></p>
<p>再次执行 <font color="#FF00FF">gradlew initFreeline -Pmirror</font>，Freeline会再下载相应的依赖包，一般不会出错了，直到出现这步时，耐心等待一会儿。这个时候已经开始了对Freeline的初始化。</p>
<p><img data-src="http://img.blog.csdn.net/20170107150447710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvZG9uZ0FuZHJvaWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" /></p>
<p>初始化成功：</p>
<p><img data-src="http://img.blog.csdn.net/20170107150721089?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvZG9uZ0FuZHJvaWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" /></p>
<p>接下来就是第一次的全量编译，耐心等待编译完成（只有第一次全量编译时间较长，以后的增量编译都是10s之内的）：</p>
<p>执行一条	<font color="#FF00FF">python freeline.py</font> 命令即可。</p>
<p><img data-src="http://img.blog.csdn.net/20170107151313958?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvZG9uZ0FuZHJvaWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" /></p>
<p>这是第一次编译的时间是40秒。然后我修改了一个数值进行第二次编译。</p>
<p><img data-src="http://img.blog.csdn.net/20170107151501007?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvZG9uZ0FuZHJvaWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" /></p>
<p>0.7秒即编译完成，不到一眨眼的功夫，484想说“卧槽”。</p>
<p><font color="#F00F0" size = 4>注意又来了！</font></p>
<ul>
<li>
<p>freeline的limitation，目前还不支持连接多台设备。目前方案参考 <a href="https://github.com/alibaba/freeline/issues/233">Issues233</a>。</p>
</li>
<li>
<p>在自己的Application类中加入以下代码：</p>
<p><code>FreelineCore.init(this);</code></p>
</li>
<li>
<p>有时增量编译完成后并不会自动launch activity，但这时已经把更新部署到设备上了。</p>
</li>
<li>
<p>有其他问题多去看看<a href="https://github.com/alibaba/freeline/issues">Issues</a>。</p>
</li>
</ul>
<p><img data-src="http://img.blog.csdn.net/20170107151925468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvZG9uZ0FuZHJvaWQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" /></p>
<p>至此，Freeline已经成功的集成到了我们的项目中，如果觉得每次执行命令行比较繁琐，可以根据方法一在AS中安装Freeline的插件。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=135768&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>Freeline</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Freeline</tag>
      </tags>
  </entry>
  <entry>
    <title>使用迅雷下载百度网盘文件</title>
    <url>/2017/07/16/%E4%BD%BF%E7%94%A8%E8%BF%85%E9%9B%B7%E4%B8%8B%E8%BD%BD%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<Contents>
<h2 id="使用迅雷下载百度网盘文件"><a class="markdownIt-Anchor" href="#使用迅雷下载百度网盘文件"></a> 使用迅雷下载百度网盘文件</h2>
<blockquote>
<p>转载请注明出处：</p>
<p><a href="http://sunxiaodou.com/2017/07/16/%E4%BD%BF%E7%94%A8%E8%BF%85%E9%9B%B7%E4%B8%8B%E8%BD%BD%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E6%96%87%E4%BB%B6/">http://sunxiaodou.com/2017/07/16/使用迅雷下载百度网盘文件/</a></p>
<p>本文来自<a href="http://sunxiaodou.com">【孫小逗的博客】</a></p>
</blockquote>
<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3>
<ol>
<li>我是在Mac版的Chrome进行的安装，到最后一切安装就绪，点击下载时还是弹出百度网盘的下载对话框。</li>
<li>然后尝试在Windows版的Chrome安装，是可以正常使用的。</li>
<li>最后的下载截图是Windows版的QQ浏览器，正常使用。</li>
<li>其他浏览器请自行测试。</li>
</ol>
<h3 id="下载chrome插件-tampermonkey脚本管理器"><a class="markdownIt-Anchor" href="#下载chrome插件-tampermonkey脚本管理器"></a> 下载Chrome插件 — Tampermonkey脚本管理器</h3>
<ol>
<li>可以翻墙的同学，在Chrome的网上应用商店直接搜索Tampermonkey，添加到Chrome扩展即可。</li>
<li>不能翻墙的同学，可以使用我已经下载好的插件文件本地安装。链接: <a href="https://pan.baidu.com/s/1nvmfq8D">https://pan.baidu.com/s/1nvmfq8D</a> 密码: i2r4</li>
</ol>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/baiduyun/Chrome.png" alt="Chrome" /></p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/baiduyun/Chrome%20Install.png" alt="Chrome Install" /></p>
<h3 id="安装脚本-打开greasy-fork"><a class="markdownIt-Anchor" href="#安装脚本-打开greasy-fork"></a> 安装脚本 — 打开Greasy Fork</h3>
<p>现在我们打开<a href="https://greasyfork.org/zh-CN/">Greasy Fork</a>，一个提供用户脚本的网站。并在搜索框内输入“解决百度云”关键字搜索。<br />
<img data-src="http://om278gsrf.bkt.clouddn.com/baiduyun/search%20baiduyun.png" alt="Greasy Fork" /></p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/baiduyun/search%20rustlt.png" alt="search result" /></p>
<p>我们点击下面那个“路人添加版”，更新时间比较新。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/baiduyun/install%20script.png" alt="install" /></p>
<p>点击安装此脚本，进入源码界面，点击安装即可。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/baiduyun/install%20script%20again.png" alt="install again" /></p>
<p>至此，所有的安装已完成。</p>
<h3 id="使用迅雷下载大文件"><a class="markdownIt-Anchor" href="#使用迅雷下载大文件"></a> 使用迅雷下载大文件</h3>
<p>现在我们可以打开百度网盘网页版，可以看到脚本管理器提示，脚本已在运行。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/baiduyun/start%20script.png" alt="start" /></p>
<p>我们选择一个比较大的电影《5kz.mp4 — 悟空传》，点击下载按钮，弹出QQ浏览器的下载对话框，我们可以点击迅雷下载。</p>
<p><img data-src="http://om278gsrf.bkt.clouddn.com/baiduyun/download%205kz.png" alt="download" /></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=135768&auto=1&height=66"></iframe>]]></content>
      <tags>
        <tag>迅雷</tag>
        <tag>百度网盘</tag>
      </tags>
  </entry>
  <entry>
    <title>记Android Studio自定义属性访问不了的问题</title>
    <url>/2016/05/30/%E8%AE%B0Android%20Studio%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<Contents>
<blockquote>
<p>转载请注明出处:<br />
<a href="http://blog.csdn.net/guodongAndroid/article/details/51536091">http://blog.csdn.net/guodongAndroid/article/details/51536091</a><br />
本文来自:<a href="http://sunxiaodou.com">【孫小逗的博客】</a></p>
</blockquote>
<h2 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述"></a> 一、概述</h2>
<p>在Eclipse中对于自定义属性的引用是在根布局文件中声明一个命名空间，比如：xmlns：xxx=“<a href="http://schemas.android.com/apk/res/%E9%A1%B9%E7%9B%AE%E5%8C%85%E5%90%8D%E2%80%9D%E3%80%82%E5%85%B6%E4%B8%ADxxx%E6%98%AF%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E7%9A%84%EF%BC%8C%E9%A1%B9%E7%9B%AE%E5%8C%85%E5%90%8D%E5%B0%B1%E6%98%AFManifest%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84package%E3%80%82%E8%80%8C%E5%9C%A8Android">http://schemas.android.com/apk/res/项目包名”。其中xxx是自己定义的，项目包名就是Manifest文件中的package。而在Android</a> Studio中声明命名控件和在Eclipse中类似，例如：xmlns:wzq=“<a href="http://schemas.android.com/apk/res-auto">http://schemas.android.com/apk/res-auto</a>”，<br />
只是res后面不同。但是这样带来了一个麻烦！</p>
<h2 id="二-解决"><a class="markdownIt-Anchor" href="#二-解决"></a> 二、解决</h2>
<p>AS这样做会带来什么麻烦呢？即，所有的自定义属性堆积在一起，导入的时候，就会很混乱。Google为了解决这个问题，就将要使用自定义View或ViewGroup类名与属性文件内的声明命名设置关联，如图：<br />
<img data-src="http://img.blog.csdn.net/20160530101952575" alt="这里写图片描述" /></p>
<p>意思是类名要和自定义属性文件的命名一致。</p>
<p>如果不一致会出现情况呢？我们尝试一下，更改自定义属性文件的命名，如图：<img data-src="http://img.blog.csdn.net/20160530102219469" alt="这里写图片描述" /></p>
<p>出现的情况，如下图：<br />
<img data-src="http://img.blog.csdn.net/20160530102257942" alt="这里写图片描述" /></p>
<p>咦，自定义属性怎么没有了？这就是自定义View或ViewGroup类名与属性文件内的声明命名不一致，AS找不到关联。</p>
<p>知道了问题所在，我们在改回来试试，如图：<br />
<img data-src="http://img.blog.csdn.net/20160530102544553" alt="这里写图片描述" /></p>
<p>哈，太棒了，自定义属性又回来了。</p>
<p>还有一点哦，在自定义View或ViewGroup涉及onSaveInstanceState()或onRestoreInstanceState()时，如果自定义的View或ViewGroup没有设置一个id的话，状态是无法恢复的。</p>
<p>这是一个简单的五子棋小游戏，根据鸿洋大神教程所写。</p>
<p>谢谢！<br />
<a href="https://github.com/guodongAndroid/GameWuZiQi.git">源码地址</a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=135768&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>AndroidStudio</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>androidstudio</tag>
        <tag>自定义属性</tag>
      </tags>
  </entry>
  <entry>
    <title>记当TextView.setSingleLine(true)时，滑动TextView的区域，导致的ViewPager不能滑动的问题</title>
    <url>/2017/09/14/%E8%AE%B0%E5%BD%93TextView.setSingleLine(true)%E6%97%B6%EF%BC%8C%E6%BB%91%E5%8A%A8TextView%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%8C%E5%AF%BC%E8%87%B4%E7%9A%84ViewPager%E4%B8%8D%E8%83%BD%E6%BB%91%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<Contents>
<blockquote>
<p>转载请注明出处：</p>
<p><a href="http://sunxiaodou.com/2017/09/14/%E8%AE%B0%E5%BD%93TextView.setSingleLine(true)%E6%97%B6%EF%BC%8C%E6%BB%91%E5%8A%A8TextView%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%8C%E5%AF%BC%E8%87%B4%E7%9A%84ViewPager%E4%B8%8D%E8%83%BD%E6%BB%91%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/">http://sunxiaodou.com/2017/09/14/记当TextView.setSingleLine(true)时，滑动TextView的区域，导致的ViewPager不能滑动的问题/</a></p>
<p>本文来自<a href="http://sunxiaodou.com">【孫小逗的博客】</a></p>
</blockquote>
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>问题背景：在ViewPager中包含两个Fragment，其中一个Fragment中有多个TextView，TextView需要开启跑马灯，在XML文件中设置了:<code>android:singleLine=&quot;true&quot;</code>导致滑动TextView的区域时，ViewPager滑动失效。</p>
<h2 id="探索"><a class="markdownIt-Anchor" href="#探索"></a> 探索</h2>
<h3 id="探索一"><a class="markdownIt-Anchor" href="#探索一"></a> 探索一</h3>
<p>首先想到的是滑动冲突，去查看了<code>TextView.setSingleLine(true)</code>时执行了什么动作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@android</span>.view.RemotableViewMethod</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSingleLine</span><span class="params">(<span class="type">boolean</span> singleLine)</span> &#123;</span><br><span class="line">    <span class="comment">// Could be used, but may break backward compatibility.</span></span><br><span class="line">    <span class="comment">// if (mSingleLine == singleLine) return;</span></span><br><span class="line">    setInputTypeSingleLine(singleLine);</span><br><span class="line">    applySingleLine(singleLine, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setInputTypeSingleLine</span><span class="params">(<span class="type">boolean</span> singleLine)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEditor != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (mEditor.mInputType &amp; EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singleLine) &#123;</span><br><span class="line">                mEditor.mInputType &amp;= ~EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mEditor.mInputType |= EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">applySingleLine</span><span class="params">(<span class="type">boolean</span> singleLine, <span class="type">boolean</span> applyTransformation,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> changeMaxLines)</span> &#123;</span><br><span class="line">        mSingleLine = singleLine;</span><br><span class="line">        <span class="keyword">if</span> (singleLine) &#123;</span><br><span class="line">            setLines(<span class="number">1</span>);</span><br><span class="line">            setHorizontallyScrolling(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (applyTransformation) &#123;</span><br><span class="line">                setTransformationMethod(SingleLineTransformationMethod.getInstance());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (changeMaxLines) &#123;</span><br><span class="line">                setMaxLines(Integer.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">            setHorizontallyScrolling(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (applyTransformation) &#123;</span><br><span class="line">                setTransformationMethod(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHorizontallyScrolling</span><span class="params">(<span class="type">boolean</span> whether)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHorizontallyScrolling != whether) &#123;</span><br><span class="line">            mHorizontallyScrolling = whether;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayout != <span class="literal">null</span>) &#123;</span><br><span class="line">                nullLayouts();</span><br><span class="line">                requestLayout();</span><br><span class="line">                invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以在<code>applySingleLine</code>方法中看到<code>setLines(1);setHorizontallyScrolling(true);</code>，<code>setHorizontallyScrolling</code>方法会设置TextView是否可以横向滚动，关键是改变了<code>mHorizontallyScrolling</code>成员变量的值。</p>
<p>然后就写了个MyViewPager:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewPager</span> <span class="keyword">extends</span> <span class="title class_">ViewPager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mDownX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mSlop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewPager</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewPager</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">         mSlop = ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> ev.getActionMasked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (actionMasked) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mDownX = (<span class="type">int</span>) ev.getX();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="type">int</span> <span class="variable">dx</span> <span class="operator">=</span> (<span class="type">int</span>) (ev.getX() - mDownX);</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(dx) &gt;= mSlop) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                mDownX = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>覆写了事件拦截方法<code>onInterceptTouchEvent(MotionEvent ev)</code>方法，在<code>MotionEvent.ACTION_MOVE</code>里根据横向滑动是否需要拦截事件。</p>
<p>然而现实是残酷的、无情的，失败。</p>
<h3 id="探索二"><a class="markdownIt-Anchor" href="#探索二"></a> 探索二</h3>
<p>众所周知，TextView要实现跑马灯需要获取到焦点，然后猜测滑动TextView区域的时ViewPager不滑动的原因是因为ViewPager没有获取到焦点所致。</p>
<p>所以在探索一的基础上加了一句代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewPager</span> <span class="keyword">extends</span> <span class="title class_">ViewPager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mDownX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mSlop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewPager</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewPager</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">         mSlop = ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> ev.getActionMasked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (actionMasked) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mDownX = (<span class="type">int</span>) ev.getX();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="type">int</span> <span class="variable">dx</span> <span class="operator">=</span> (<span class="type">int</span>) (ev.getX() - mDownX);</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(dx) &gt;= mSlop) &#123;</span><br><span class="line">                	requestFocusFromTouch();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                mDownX = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意第27行的代码<code>requestFocusFromTouch();</code>，拦截事件的同时使ViewPager获取到焦点。</p>
<p>奇迹发生，成功。</p>
<p>这个问题虽然解决了，却也引入了另一个问题：另一个Fragment中有一个横向滑动的RecyclerView，由于ViewPager的横向滑动事件拦截，导致RecyclerView的横向滑动失效。</p>
<p>只好重写一个MyRecyclerView：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRecyclerView</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mDownX;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mDownY;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mSlop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRecyclerView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRecyclerView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRecyclerView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="type">int</span> defStyle)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyle);</span><br><span class="line">        mSlop = ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> ev.getActionMasked();</span><br><span class="line">        <span class="keyword">switch</span> (actionMasked) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mDownX = (<span class="type">int</span>) ev.getX();</span><br><span class="line">                mDownY = (<span class="type">int</span>) ev.getY();</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">dx</span> <span class="operator">=</span> (<span class="type">int</span>) (ev.getX() - mDownX);</span><br><span class="line">                <span class="type">int</span> <span class="variable">dy</span> <span class="operator">=</span> (<span class="type">int</span>) (ev.getY() - mDownY);</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(dy) &gt;= mSlop &amp;&amp; Math.abs(dy) &gt; Math.abs(dx)) &#123;</span><br><span class="line">                    getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Adapter</span> <span class="variable">adapter</span> <span class="operator">=</span> getAdapter();</span><br><span class="line">                <span class="keyword">if</span> (adapter == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">LayoutManager</span> <span class="variable">manager</span> <span class="operator">=</span> getLayoutManager();</span><br><span class="line">                <span class="keyword">if</span> (manager == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">itemCount</span> <span class="operator">=</span> adapter.getItemCount();</span><br><span class="line">                <span class="keyword">if</span> (itemCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (manager <span class="keyword">instanceof</span> LinearLayoutManager) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dx &gt; <span class="number">0</span> &amp;&amp; dx &lt;= mSlop) &#123; <span class="comment">// 右滑</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">firstVisiblePosition</span> <span class="operator">=</span> ((LinearLayoutManager) manager).findFirstCompletelyVisibleItemPosition();</span><br><span class="line">                        <span class="keyword">if</span> (firstVisiblePosition == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="type">View</span> <span class="variable">firstView</span> <span class="operator">=</span> manager.findViewByPosition(firstVisiblePosition);</span><br><span class="line">                            <span class="keyword">if</span> (firstView.getLeft() == <span class="number">0</span>) &#123;</span><br><span class="line">                                getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dx &lt; <span class="number">0</span> &amp;&amp; dx &gt;= -mSlop) &#123; <span class="comment">// 左滑</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">lastVisiblePosition</span> <span class="operator">=</span> ((LinearLayoutManager) manager).findLastCompletelyVisibleItemPosition();</span><br><span class="line">                        <span class="keyword">if</span> (lastVisiblePosition == itemCount - <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="type">View</span> <span class="variable">lastView</span> <span class="operator">=</span> manager.findViewByPosition(lastVisiblePosition);</span><br><span class="line">                            <span class="keyword">if</span> (lastView.getRight() == <span class="built_in">this</span>.getWidth()) &#123;</span><br><span class="line">                                getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                mDownX = <span class="number">0</span>;</span><br><span class="line">                mDownY = <span class="number">0</span>;</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个横向滑动的RecyclerView是作为一个Item在一个竖向滑动的RecyclerView中，所以代码中加了对竖向滑动的处理。</p>
<p>有关滑动冲突的解决办法可以参考另一篇文章：<a href="http://sunxiaodou.com/2017/07/07/View%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/">View滑动冲突的两种解决方式</a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=28661549&auto=1&height=66"></iframe>]]></content>
      <tags>
        <tag>ViewPager</tag>
        <tag>TextView</tag>
        <tag>跑马灯</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaASM-基础-ASM简介</title>
    <url>/2022/07/19/ASM/JavaASM-%E5%9F%BA%E7%A1%80-ASM%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="javaasm-基础-asm简介"><a class="markdownIt-Anchor" href="#javaasm-基础-asm简介"></a> JavaASM-基础-ASM简介</h1>
<h2 id="1asm是什么"><a class="markdownIt-Anchor" href="#1asm是什么"></a> 1.ASM是什么？</h2>
<p>简单来说，<strong><a href="https://asm.ow2.io/">ASM</a> 是一个操作 Java 字节码的类库</strong>。它可以用于修改现有的 class 文件或动态生成 class 文件。</p>
<p>众所周知，一个 <code>.java</code> 源文件经过 Java 编译器(<code>javac</code>) 编译之后会生成一个 <code>.class</code> 文件。在 <code>.class</code> 文件中存储着一定规则的字节码数据(ByteCode)，ASM 操作的对象就是字节码，一般情况下，字节码都存在于 <code>.class</code> 文件中。</p>
<p>ASM 首先读取 <code>.class</code> 文件中的字节码数据，按照一定规则解析字节码数据，分解成多个部分，然后对某个或多个部分进行修改，最后再将分解和修改后的部分重新按照规则生成一个新的 <code>.class</code> 文件<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h2 id="2asm能做什么"><a class="markdownIt-Anchor" href="#2asm能做什么"></a> 2.ASM能做什么？</h2>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li>
<p><a href="https://asm.ow2.io/">ASM官网</a></p>
</li>
<li>
<p><a href="https://gitlab.ow2.org/asm/asm">ASM源码</a></p>
</li>
<li>
<p><a href="https://asm.ow2.io/javadoc/index.html">ASM API文档</a></p>
</li>
<li>
<p><a href="https://asm.ow2.io/asm4-guide.pdf">ASM使用手册</a></p>
</li>
<li></li>
</ul>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/ObjectWeb_ASM">ObjectWeb ASM - Wikipedia</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-EventBus修改纪实(一)-必达事件</title>
    <url>/2022/06/01/Android/Android-EventBus%E4%BF%AE%E6%94%B9%E7%BA%AA%E5%AE%9E(%E4%B8%80)-%E5%BF%85%E8%BE%BE%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="android-eventbus修改纪实"><a class="markdownIt-Anchor" href="#android-eventbus修改纪实"></a> Android-EventBus修改纪实</h1>
<p>持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第 3 天，<a href="https://juejin.cn/post/7099702781094674468">点击查看活动详情</a></p>
<hr />
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<p>笔者在使用 EventBus 的过程中发现有时只能收到最后一次的黏性 Event ，导致业务逻辑出现混乱，下面是笔者的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Event.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Event</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用多次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">        EventBus.getDefault().postSticky(<span class="keyword">new</span> <span class="title class_">Event</span>(code));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用多次 `test(int code)` 后再注册订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        EventBus.getDefault().register(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        <span class="comment">// 发现只能收到最后一次的黏性事件</span></span><br><span class="line">        System.out.println(event.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以去查看了 EventBus 的源码，接下来我们分析下 EventBus 发送黏性事件的流程。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<h3 id="黏性事件"><a class="markdownIt-Anchor" href="#黏性事件"></a> 黏性事件</h3>
<blockquote>
<p>以下源码基于 EventBus 3.3.1 版本</p>
</blockquote>
<p>下面是发送黏性事件的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postSticky</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">        stickyEvents.put(event.getClass(), event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">    post(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>postSticky</code> 代码比较简单，首先对 <code>stickyEvents</code> 进行加锁，接下来把 event 事件的 Class 对象作为 Key，event 事件本身作为 value 放进 Map 中，其中<code>stickyEvents</code> 是 Map 对象，实例是 <code>ConcurrentHashMap</code>, 其 Key 和 Value 的泛型形参分别是 <code>Class&lt;?&gt;</code> 和 <code>Object</code>, 它的作用就是用来存储黏性事件；然后调用 <code>post(event)</code> 把黏性事件当作普通事件发送一下。</p>
<p>首先我们看下最后为什么要调用下 <code>post(event)</code>？</p>
<p>虽然 <code>post(evnet)</code> 上面有注释，简单翻译下：“在放进 Map 后应该再发送一次，以防止订阅者想立即删除此事件”，读完注释后，可能还是不太明白，这里笔者认为：在前面存储完黏性事件后，这里调用 <code>post</code> 把黏性事件当作普通事件发送出去，或许是因为现在已经有注册的黏性事件订阅者，此时把已经注册的黏性事件订阅者当作普通事件的订阅者，这样已经注册的黏性事件订阅者可以立即收到相应的事件，只是此时事件不再是黏性的。</p>
<p>在 <code>postSticky</code> 中我们并没有看到黏性事件是在哪里发送的，想一想我们使用黏性事件的目的是什么？<strong>当注册订阅者时可以收到之前发送的事件</strong>，这样来看，黏性事件的发送是在注册订阅者时，下面是注册订阅者的源码，删除了一些无关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object subscriber)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找订阅者所有的Event接收方法</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>register</code> 代码也比较简单，首先通过订阅者的 Class 对象查找订阅者所有的Event事件接收方法，然后对 EventBus 对象加锁，遍历所有的Event事件接收方法 <code>subscriberMethods</code> 调用 <code>subscribe</code> 方法，以下是 <code>subscribe</code> 方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Key 为 Event Class 对象，Value 为存储 Event 的订阅者和接收 Event 方法对象的集合 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Key 为订阅者对象，Value 为订阅者中的 Event Class对象集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Must be called in synchronized block</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> &#123;</span><br><span class="line">    <span class="comment">// Event Class对象</span></span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅者和接收 Event 方法对象</span></span><br><span class="line">    <span class="type">Subscription</span> <span class="variable">newSubscription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subscription</span>(subscriber, subscriberMethod);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 Event Class对象，获取订阅者和接收 Event 方法对象的集合</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断订阅者和接收 Event 方法对象是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="literal">null</span>) &#123;</span><br><span class="line">        subscriptions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经包含了新的订阅者和接收 Event 方法对象，若是包含则认为是重复注册</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Subscriber &quot;</span> + subscriber.getClass() + <span class="string">&quot; already registered to event &quot;</span></span><br><span class="line">                                        + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是按优先级排序插入到集合中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是把 Event Class对象添加进对应订阅者的 Event Class对象集合中</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="literal">null</span>) &#123;</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面已经判断了是否重复注册，所以这里直接添加</span></span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来就是黏性事件的发送逻辑了</span></span><br><span class="line">    <span class="comment">// 判断 Event 接收方法是否可以处理黏性事件</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">        <span class="comment">// 这里判断是否考虑 Event 事件类的继承关系，默认为 Ture</span></span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">            <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">            <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">            <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">stickyEvent</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">stickyEvent</span> <span class="operator">=</span> stickyEvents.get(eventType);</span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的源码中，增加了不少注释有助于我们读懂源码，在源码的最后就是黏性事件的发送逻辑了，其中有两个分支，其中一个分支根据 Event 事件的继承关系发送事件，另外一个分支根据接收 Event 方法中的 Event Class 对象从 <code>stickyEvents</code> 中直接查找黏性事件，最后两个分支殊途同归，都调用了 <code>checkPostStickyEventToSubscription</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stickyEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span></span><br><span class="line">        <span class="comment">// --&gt; Strange corner case, which we don&#x27;t take care of here.</span></span><br><span class="line">        postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>checkPostStickyEventToSubscription</code> 方法很简单，对黏性事件做下判空处理，继续调用 <code>postToSubscription</code> 方法，传入订阅者与接收 Event 方法对象，黏性事件和是否是主线程布尔值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="type">boolean</span> isMainThread)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="literal">null</span>) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;A</span><br><span class="line">                <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unknown thread mode: &quot;</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>postToSubscription</code> 方法比较长，但是比较好理解，就是根据接收 Event 方法上的 <code>@Subscribe</code> 注解中传入的线程模型进行事件的分发，具体的事件分发流程，有空再分析，本文就先不分析了，现在我们只需知道最后都会调用 <code>invokeSubscriber(Subscription subscription, Object event)</code> 方法即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 反射调用 Event 接收方法传入 Event 事件</span></span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于在 <code>invokeSubscriber</code> 方法中找到调用 Event 接收方法的地方了，原来 EventBus 最后是通过反射调用 Event 接收方法并传入相应 Event 事件的。</p>
<p>分析完 Event 事件的发送流程，好像没有发现为什么有时收不到黏性事件。</p>
<p>我们回过头来再看下笔者的使用示例，为了方便查看，下面贴出使用示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用多次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">        EventBus.getDefault().postSticky(<span class="keyword">new</span> <span class="title class_">Event</span>(code));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用多次 `test(int code)` 后再注册订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        EventBus.getDefault().register(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        <span class="comment">// 发现只能收到最后一次的黏性事件</span></span><br><span class="line">        System.out.println(event.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能细心的读者已经发现 <code>test</code> 方法调用了，问题应该出在 <code>postSticky</code> 方法中，让我们再次查看 <code>postSticky</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postSticky</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">        stickyEvents.put(event.getClass(), event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">    post(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前面分析 <code>postSticky</code> 方法的结果，<code>stickyEvents</code> 用于存储黏性事件，它是个 Map 结构，而 <code>stickyEvents</code> 的 Key 正是 Event 的 Class 对象，根据 Map 结构的存储原理：如果存在相同的 Key，则覆盖 Value 的值，而 <code>stickyEvents</code> 的 Value 正是 Event 本身。</p>
<p>终于真相大白，多次调用 <code>test</code> 方法发送黏性事件，EventBus 只会存储最后一次的黏性事件。</p>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p><strong>EventBus 针对同一个黏性 Event 事件只会存储最后一次发送的黏性事件。</strong></p>
<p>EventBus 的上述实现可能是因为多次发送同一个黏性事件，则认为之前的事件是过期事件应该抛弃，因此只传递最新的黏性事件。</p>
<p>EventBus 的这种实现无法满足笔者的业务逻辑需求，笔者希望多次发送的黏性事件，订阅者都能接收到，而不是只接收最新的黏性事件，可以理解为黏性事件必达订阅者，下面让我们修改 EventBus 的源码来满足需求吧。</p>
<h2 id="修改"><a class="markdownIt-Anchor" href="#修改"></a> 修改</h2>
<p>上一节我们分析了黏性事件的发送流程，为了满足黏性事件必达的需求，基于现有黏性事件流程，我们可以仿照黏性事件的发送来提供一个发送必达消息的方法。</p>
<h3 id="subscribe"><a class="markdownIt-Anchor" href="#subscribe"></a> Subscribe</h3>
<p>首先我们定义 Event 接收方法可以接收黏性事件是在 <code>@Subscribe</code> 中 <code>sticky = true</code> , 所以我们可以修改 <code>Subscribe</code> 注解，增加黏性事件必达的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</span><br><span class="line">    ThreadMode <span class="title function_">threadMode</span><span class="params">()</span> <span class="keyword">default</span> ThreadMode.POSTING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If true, delivers the most recent sticky event (posted with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EventBus#postSticky(Object)&#125;) to this subscriber (if event available).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">sticky</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加消息必达的方法</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">rendezvous</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Subscriber priority to influence the order of event delivery.</span></span><br><span class="line"><span class="comment">     * Within the same delivery thread (&#123;<span class="doctag">@link</span> ThreadMode&#125;), higher priority subscribers will receive events before</span></span><br><span class="line"><span class="comment">     * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of</span></span><br><span class="line"><span class="comment">     * delivery among subscribers with different &#123;<span class="doctag">@link</span> ThreadMode&#125;s! */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">priority</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rendezvous</code> 以为约会、约定的意思，可以理解为不见不散，在这里它有两层作用，其一是标记方法可以接收黏性事件，其二是标记方法接收的事件是必达的。</p>
<h3 id="findsubscribermethods"><a class="markdownIt-Anchor" href="#findsubscribermethods"></a> findSubscriberMethods</h3>
<p>接下来就需要解析 <code>rendezvous</code> 了，我们先看看 <code>sticky</code> 是如何解析的，在上一节我们分析了 <code>register</code> 方法，方便查看，下面再贴出 <code>register</code> 方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object subscriber)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找订阅者所有的Event接收方法</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上一节分析中，我们没有分析查找订阅者中所有的 Event 接收方法 <code>findSubscriberMethods</code> ，接下来我们分析下在 <code>findSubscriberMethods</code> 方法是如何查找 Event 接收方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; <span class="title function_">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 先从缓存中查找</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否忽略生成索引，默认为False，所以这里走else分支</span></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 查找Event接收方法</span></span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果订阅者和订阅者父类中没有Event接收方法则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Subscriber &quot;</span> + subscriberClass</span><br><span class="line">                                    + <span class="string">&quot; and its super classes have no public methods with the @Subscribe annotation&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加进缓存中</span></span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>findSubscriberMethods</code> 方法需要传入订阅者 Class 对象，通过笔者在源码中增加的注释分析发现默认调用 <code>findUsingInfo</code> 方法查找 Event 接收方法，我们继续跟踪 <code>findUsingInfo</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title function_">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line">    <span class="comment">// FindState对订阅者Class对象和Event接收方法进行了一层封装</span></span><br><span class="line">    <span class="type">FindState</span> <span class="variable">findState</span> <span class="operator">=</span> prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass); <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找订阅者信息，包含订阅者Class对象、 订阅者父类、Event接收方法等</span></span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState); <span class="comment">// ②</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在 ① initForSubscriber中会把subscriberInfo置为null，</span></span><br><span class="line">        <span class="comment">// 在 ② getSubscriberInfo中没有Index对象，</span></span><br><span class="line">        <span class="comment">// 所以第一次时这里会走else分支</span></span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 查找Event接收方法</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找父类的Event接收方法</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过findState返回Event接收方法，并回收findState</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据笔者在源码中的注释分析，在 <code>findUsingInfo</code> 方法中使用「享元模式」对 <code>FindState</code> 进行回收利用，避免创建大量临时的 <code>FindState</code> 对象占用内存，最后再次调用 <code>findUsingReflectionInSingleClass</code> 方法查找 Event 接收方法，看方法名字应该是使用反射查找，<code>findUsingReflectionInSingleClass</code> 源码较长，删减一些不关心的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> &#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">        <span class="comment">// 通过反射获取当前类中声明的所有方法</span></span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="comment">// 删减不关心的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取方法的修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> method.getModifiers();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断方法是否是public的；是否是抽象方法，是否是静态方法，是否是桥接方法，是否是合成方法</span></span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取方法的形参Class对象数组</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取方法上的Subscribe注解</span></span><br><span class="line">                <span class="type">Subscribe</span> <span class="variable">subscribeAnnotation</span> <span class="operator">=</span> method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 检测是否已经添加了相同签名的方法，考虑子类复写父类方法的情况</span></span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 获取注解的参数</span></span><br><span class="line">                        <span class="type">ThreadMode</span> <span class="variable">threadMode</span> <span class="operator">=</span> subscribeAnnotation.threadMode();</span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> <span class="title class_">SubscriberMethod</span>(method, eventType, threadMode,</span><br><span class="line">								subscribeAnnotation.priority(), subscribeAnnotation.sticky(),</span><br><span class="line">								</span><br><span class="line">								<span class="comment">// 这里我们添加rendezvous参数 ①</span></span><br><span class="line">								subscribeAnnotation.rendezvous()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删减不关心的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删减不关心的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>findUsingReflectionInSingleClass</code> 方法中通过反射获取订阅者中声明的所有方法，然后遍历所有方法：</p>
<ol>
<li>首先判断方法的修饰符是否符合，</li>
<li>其次判断方法是否只有一个形参，</li>
<li>再次判断方法是否有 <code>Subscribe</code> 注解，</li>
<li>然后检测是否已经添加了相同签名的方法，主要是考虑子类复写父类方法这种情况，</li>
<li>最后获取 <code>Subscribe</code> 注解的参数，在这里我们解析 <code>rendezvous</code>，封装进 <code>SubscriberMethod</code> 中。</li>
</ol>
<p>在 <code>SubscriberMethod</code> 中增加 <code>rendezvous</code> 字段，删除不关心的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriberMethod</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">final</span> ThreadMode threadMode;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; eventType;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> priority;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> sticky;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 `rendezvous` 字段</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> rendezvous;</span><br><span class="line">    <span class="comment">/** Used for efficient comparison */</span></span><br><span class="line">    String methodString;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubscriberMethod</span><span class="params">(Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, </span></span><br><span class="line"><span class="params">                            <span class="type">int</span> priority, <span class="type">boolean</span> sticky,</span></span><br><span class="line"><span class="params">                            </span></span><br><span class="line"><span class="params">                            // 增加 `rendezvous` 形参</span></span><br><span class="line"><span class="params">                            <span class="type">boolean</span> rendezvous)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.method = method;</span><br><span class="line">        <span class="built_in">this</span>.threadMode = threadMode;</span><br><span class="line">        <span class="built_in">this</span>.eventType = eventType;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">        <span class="built_in">this</span>.sticky = sticky;</span><br><span class="line">        <span class="built_in">this</span>.rendezvous = rendezvous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="postrendezvous"><a class="markdownIt-Anchor" href="#postrendezvous"></a> postRendezvous</h3>
<p>好的，<code>rendezvous</code> 已经解析出来了，接下来我们对外提供发送必达事件的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择List存储必达事件，使用Pair封装必达事件的Key和Value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Pair&lt;Class&lt;?&gt;, Object&gt;&gt; rendezvousEvents;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postRendezvous</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (rendezvousEvents) &#123;</span><br><span class="line">        rendezvousEvents.add(Pair.create(event.getClass(), event));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">    post(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的源码，我们通过仿照 <code>postSticky</code> 方法实现了 <code>postRendezvous</code> 方法，在 <code>postSticky</code> 方法中使用 Map 存储黏性事件，不过我们在 <code>postRendezvous</code> 方法中使用 List 存储必达事件，保证必达事件不会因为 Key 相同而被覆盖丢失，最后也是调用 <code>post</code> 方法尝试先发送一次必达事件。</p>
<h3 id="register"><a class="markdownIt-Anchor" href="#register"></a> register</h3>
<p>在上一节中我们分析了黏性事件是在 <code>register</code> 中调用 <code>subscribe</code> 方法进行发送的，这里我们仿照黏性事件的发送逻辑，实现必达事件的发送逻辑，我们可以在 <code>subscribe</code> 方法最后增加发送必达事件的逻辑，以下源码省略了一些不关心的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Pair&lt;Class&lt;?&gt;, Object&gt;&gt; rendezvousEvents;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略不关心的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 黏性事件发送逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">stickyEvent</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">stickyEvent</span> <span class="operator">=</span> stickyEvents.get(eventType);</span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增必达事件发送逻辑</span></span><br><span class="line">    <span class="comment">// 判断方法是否可以接收必达事件</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.rendezvous) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair&lt;Class&lt;?&gt;, Object&gt; next : rendezvousEvents) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = next.first;</span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">stickyEvent</span> <span class="operator">=</span> next.second;</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">rendezvousEvent</span> <span class="operator">=</span> getRendezvousEvent(eventType);</span><br><span class="line">            <span class="keyword">if</span> (rendezvousEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, rendezvousEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>subscribe</code> 方法中，我们通过仿照黏性事件的发送逻辑增加了必达事件的发送：</p>
<ol>
<li>首先判断 Event 接收方法是否可以接收必达事件</li>
<li>其次考虑 Event 必达事件的继承关系，</li>
<li>最后两个分支都调用 <code>checkPostStickyEventToSubscription</code> 方法发送必达事件</li>
</ol>
<p>happy~</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>使用第三方库时，发现问题不要慌张，带着问题去查看源码总有一番收获，这也告诫我们在使用第三库时最好先搞明白它的实现原理，遇到问题时不至于束手无策。</p>
<p>通过分析 EventBus 的源码，我们有以下收获：</p>
<ol>
<li>明白了我们注册订阅者时 EventBus 做了哪些事情</li>
<li>知晓了我们发送黏性事件时，EventBus 是如何处理及何时发送黏性事件的</li>
<li>了解到 EventBus 是通过反射调用 Event 事件的接收方法</li>
<li>学习了 EventBus 中的一些优化点，比如对 <code>FindState</code> 使用「享元模式」避免创建大量临时对象占用内存</li>
<li>进一步了解到对并发的处理</li>
</ol>
<p>通过以上收获，我们成功修改 EventBus 源码实现了我们必达事件的需求。</p>
<p>到这里我们已经完成了必达事件的发送，不过我们还剩下获取必达事件，移除必达事件没有实现，最后 EventBus 中还有单元测试 module，我们还没有针对 <code>rendezvous</code> 编写单元测试，读者有兴趣的话，可以自己试着实现。</p>
<p>希望可以帮到你~</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>eventbus</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-EventBus修改纪实(三)-线程调度</title>
    <url>/2022/06/03/Android/Android-EventBus%E4%BF%AE%E6%94%B9%E7%BA%AA%E5%AE%9E(%E4%B8%89)-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="android-eventbus修改纪实三"><a class="markdownIt-Anchor" href="#android-eventbus修改纪实三"></a> Android-EventBus修改纪实(三)</h1>
<p>持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第 5 天，<a href="https://juejin.cn/post/7099702781094674468">点击查看活动详情</a></p>
<hr />
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>在上一篇 <a href="https://juejin.cn/post/7104536485428199437">Android-EventBus修改纪实(二)</a> 中笔者简单分析了 EventBus 提供的 5 种线程模型的作用及各模型的使用场景与注意事项，特别是在 <code>POSTING</code> 线程模型下，要谨慎的使用黏性事件和必达事件。</p>
<p>上一篇中未对线程模型的具体实现做分析，本篇文章分析下线程模型是如何做线程调度的。</p>
<p><strong>本篇文章只讨论发布普通事件的线程调度，粘性事件和必达事件的线程调度与普通事件略有不同。</strong></p>
<h2 id="线程模型"><a class="markdownIt-Anchor" href="#线程模型"></a> 线程模型</h2>
<p>先简单回顾下上篇文章中关于线程模型的分析：</p>
<ul>
<li>POSTING：对于普通事件来说，事件发布与订阅方法将在同一个线程，这是该线程调度模型的本意</li>
<li>MAIN：在主线程来分发事件，根据是否在 Android 上使用，处理逻辑不同</li>
<li>MAIN_ORDER：在主线程依次分发事件</li>
<li>BACKGROUND：在后台线程来分发事件，根据是否在 Android 上使用，处理逻辑不同。使用单线程处理，尽量不要进行耗时操作以免阻塞后台线程</li>
<li>ASYNC：在异步线程来分发事件，使用线程池处理</li>
</ul>
<h2 id="事件分发器"><a class="markdownIt-Anchor" href="#事件分发器"></a> 事件分发器</h2>
<p>EventBus 使用 <strong>事件分发器</strong> 对事件进行线程调度，除 <code>POSTING</code> 线程模型外，其他 4 种线程模型都有 <strong>事件分发器</strong> 的身影，<strong>事件分发器</strong> 主要在<code>postToSubscription</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="type">boolean</span> isMainThread)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="comment">// 处理POSTING</span></span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            <span class="comment">// 直接分发事件</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 处理MAIN</span></span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="comment">// 是否是主线程，在非 Android 平台上时，isMainThread 也是 true</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此时 mainThreadPoster != null，可以认为是在 Android 平台上</span></span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理MAIN_ORDERED</span></span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="comment">// 不管是否是主线程，总是先判断是否可以入队</span></span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="literal">null</span>) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                <span class="comment">// 否则直接分发事件</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理BACKGROUND</span></span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="comment">// 如果是主线程则入队，backgroundPoster使用单个后台线程依次分发事件，订阅方法应尽快返回以免阻塞后台线程</span></span><br><span class="line">            <span class="comment">// 在非 Android 平台上时，isMainThread 也是 true，即在非 Android 平台上时，始终在后台线程分发事件</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则直接分发事件</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理ASYNC</span></span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            <span class="comment">// 始终异步分发事件</span></span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unknown thread mode: &quot;</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>postToSubscription</code> 方法中可以看出各线程模型对应分别对应哪种 <strong>事件分发器</strong>：</p>
<ul>
<li>MAIN，MAIN_ORDERED：mainThreadPoster，<code>mainThreadPoster</code> 在Android 平台上的类型是 <code>HandlerPoster</code></li>
<li>BACKGROUND：backgroundPoster，<code>backgroundPoster</code> 的类型是 <code>BackgroundPoster</code></li>
<li>ASYNC：asyncPoster，<code>asyncPoster</code> 的类型是 <code>AsyncPoster</code></li>
</ul>
<p>以上事件发布器都实现了 <code>Poster</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Poster</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待发布事件入队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subscription 订阅者和订阅方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event        待发布事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Subscription subscription, Object event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Poster</code> 接口是对事件分发器行为的抽象。</p>
<p>从 <code>Poster</code> 接口中唯一的接口方法名称 <code>enqueue</code> 来看，可以大概猜测到事件分发器的实现思想为：<strong>事件循环机制</strong>。</p>
<p>既然是 <strong>事件循环</strong>，接口方法名称又是 <code>enqueue</code>，猜测有队列相关的实现。</p>
<h2 id="待发布事件队列"><a class="markdownIt-Anchor" href="#待发布事件队列"></a> 待发布事件队列</h2>
<p>每个事件分发器都有一个待发布事件队列，将待发布的事件存储在队列中，待发布事件队列是通过一种先进先出(FIFO)的单向链表实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PendingPostQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 链表头部元素</span></span><br><span class="line">    <span class="keyword">private</span> PendingPost head; <span class="comment">// 真链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表尾部元素</span></span><br><span class="line">    <span class="keyword">private</span> PendingPost tail; <span class="comment">// 假链表，真链表尾部元素的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入链表尾部</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(PendingPost pendingPost)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;null cannot be enqueued&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尾部元素不为空，认为链表中有数据</span></span><br><span class="line">        <span class="keyword">if</span> (tail != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 新的元素插入链表尾部</span></span><br><span class="line">            tail.next = pendingPost;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新尾部元素引用</span></span><br><span class="line">            tail = pendingPost;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = tail = pendingPost;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Head present, but no tail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知所有等待的线程，用于`poll(int)`中`wait()`</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表头部出队</span></span><br><span class="line">    <span class="keyword">synchronized</span> PendingPost <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                tail = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pendingPost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表头部出队</span></span><br><span class="line">    <span class="keyword">synchronized</span> PendingPost <span class="title function_">poll</span><span class="params">(<span class="type">int</span> maxMillisToWait)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            wait(maxMillisToWait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>待发布事件队列中有两个字段，其中 <code>head</code> 是真链表，标识链表的头部元素，<code>tail</code> 是假链表，它是真链表尾部元素的引用，标识链表的尾部元素，它的作用是方便在链表尾部插入元素，元素数据中有 <code>next</code> 字段指向下一个元素，下图展示了元素入队时真假链表的变化情况：</p>
<p><strong>箭头向右表示元素入队</strong></p>
<p><img data-src="https://guodongandroid.coding.net/p/typora/d/typora/git/raw/master/img/202206031222025.png" alt="image-20220603122155865" /></p>
<ol>
<li>初始时，<code>head</code> 和 <code>tail</code> 均为 <code>null</code>，</li>
<li>当第一个元素入队时，<code>head</code> 和 <code>tail</code> 均为 <code>event1</code>，</li>
<li>当第二个元素入队时，<code>event2</code> 插入 <code>head</code> 的尾部，<code>tail</code> 的引用更新为 <code>event2</code></li>
<li>当第三个元素入队时，<code>event3</code> 插入 <code>head</code> 的尾部，<code>tail</code> 的引用更新为 <code>event3</code></li>
</ol>
<p>当插入更多元素时依次类推，<code>head</code> 为链表的头部元素，<code>tail</code> 为链表的尾部元素。</p>
<p>元素出队的情况，正好与元素入队相反，下图展示了元素出队时真假链表的变化情况：</p>
<p><strong>箭头向左表示元素出队</strong></p>
<p><img data-src="https://guodongandroid.coding.net/p/typora/d/typora/git/raw/master/img/202206031249615.png" alt="image-20220603124949865" /></p>
<ol>
<li>当链表中有三个元素时，出队一个元素，即取出 <code>head</code> 头部元素 <code>event1</code>，然后把 <code>head</code> 的 <code>next</code> 元素 <code>event2</code> 指向为 <code>head</code>，判断 <code>head</code> 是否为 <code>null</code>，如果是，则认为链表中没有数据，将 <code>head</code> 和 <code>tail</code> 均置为 <code>null</code>, 否则 <code>tail</code> 尾部元素不变</li>
<li>当链表中有两个元素时，出队一个元素，即取出 <code>head</code> 头部元素 <code>event2</code>，然后把 <code>head</code> 的 <code>next</code> 元素 <code>event3</code> 指向为 <code>head</code>，判断 <code>head</code> 是否为 <code>null</code>，如果是，则认为链表中没有数据，将 <code>head</code> 和 <code>tail</code> 均置为 <code>null</code>, 否则 <code>tail</code> 尾部元素不变</li>
<li>当链表中有一个元素时，出队一个元素，即取出 <code>head</code> 头部元素 <code>event3</code>，然后把 <code>head</code> 的 <code>next</code> 元素 <code>null</code> 指向为 <code>head</code>，判断 <code>head</code> 是否为 <code>null</code>，如果是，则认为链表中没有数据，将 <code>head</code> 和 <code>tail</code> 均置为 <code>null</code>, 否则 <code>tail</code> 尾部元素不变</li>
</ol>
<h2 id="待发布事件队列元素"><a class="markdownIt-Anchor" href="#待发布事件队列元素"></a> 待发布事件队列元素</h2>
<p>待发布事件队列的元素是 <code>PendingPost</code>，它是单向链表结构，也是订阅者和订阅方法与事件的包装类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PendingPost</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;PendingPost&gt;();</span><br><span class="line"></span><br><span class="line">    Object event;</span><br><span class="line">    Subscription subscription;</span><br><span class="line">    PendingPost next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PendingPost</span><span class="params">(Object event, Subscription subscription)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.event = event;</span><br><span class="line">        <span class="built_in">this</span>.subscription = subscription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个元素</span></span><br><span class="line">    <span class="keyword">static</span> PendingPost <span class="title function_">obtainPendingPost</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> pendingPostPool.size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">                pendingPost.event = event;</span><br><span class="line">                pendingPost.subscription = subscription;</span><br><span class="line">                pendingPost.next = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> pendingPost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PendingPost</span>(event, subscription);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放一个元素</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">releasePendingPost</span><span class="params">(PendingPost pendingPost)</span> &#123;</span><br><span class="line">        pendingPost.event = <span class="literal">null</span>;</span><br><span class="line">        pendingPost.subscription = <span class="literal">null</span>;</span><br><span class="line">        pendingPost.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t let the pool grow indefinitely</span></span><br><span class="line">            <span class="keyword">if</span> (pendingPostPool.size() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                pendingPostPool.add(pendingPost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了 <code>PendingPost</code> 的源码，笔者想到了 Android 中 <code>Message</code> 的实现，我们在 Android 中使用 Handler 发消息时，是不是也经常使用 <code>handler.obtainMessage()</code> 或者使用 <code>Message.obtain()</code> 去获取一个 Message 的实例，Handler 使用完 Message 后会自动调用 <code>Message#recycle()</code> 方法回收利用这个 Message 实例，正好对应 <code>PendingPost#releasePendingPost()</code> 方法。<code>Message</code> 使用了「享元模式」达到循环利用对象，避免重复创建的目的，看来 <code>PendingPost</code> 也是使用了「享元模式」，在第一篇 <a href="https://juejin.cn/post/7104107150678917133">Android-EventBus修改纪实</a> 中我们也提到 <code>FindState</code> 也是使用了「享元模式」。</p>
<h2 id="handlerposter"><a class="markdownIt-Anchor" href="#handlerposter"></a> HandlerPoster</h2>
<p><code>HandlerPoster</code> 用于 <code>MAIN</code> 和 <code>MAIN_ORDERED</code> 线程模型，将事件分发到主线程处理。</p>
<p><code>HandlerPoster</code> 继承自 <code>Handler</code> 传入 <code>MainLooper</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerPoster</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Poster</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待发布事件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单轮最大处理时长，默认10毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否活跃，可以理解为队列是否还有数据，并发修改由 this 守护</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> handlerActive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandlerPoster</span><span class="params">(EventBus eventBus, Looper looper, <span class="type">int</span> maxMillisInsideHandleMessage)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper);</span><br><span class="line">        <span class="built_in">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="built_in">this</span>.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">PendingPostQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取队列元素(事件包装类型)</span></span><br><span class="line">        <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 元素入队</span></span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不活跃时，发送一个空的消息给当前Handler</span></span><br><span class="line">            <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">                handlerActive = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rescheduled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取处理此轮消息的开始时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">started</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 不加锁，快速取出头部元素，类似使用双重校验锁获取单例</span></span><br><span class="line">                <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果为空再加锁获取头部元素</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                        <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 还是为空，重置活跃状态，退出循环</span></span><br><span class="line">                            handlerActive = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 分发事件，调用订阅方法</span></span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 每次分发事件后都判断本轮事件分发耗时是否超过单轮最大处理时长，避免 while 死循环阻塞主线程</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">timeInMethod</span> <span class="operator">=</span> SystemClock.uptimeMillis() - started;</span><br><span class="line">                <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                    <span class="comment">// 超过单轮最大处理时长，重新发送一个空的消息给当前Handler等待调度</span></span><br><span class="line">                    <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rescheduled = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            handlerActive = rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HandlerPoster</code> 实现 <code>Poster</code> 接口中的 <code>enqueue</code> 方法用于事件入队，在 <code>handleMessage</code> 方法中调用 <code>EventBus#invokeSubscriber</code> 方法传入待发布事件队列元素分发事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">event</span> <span class="operator">=</span> pendingPost.event;</span><br><span class="line">    <span class="type">Subscription</span> <span class="variable">subscription</span> <span class="operator">=</span> pendingPost.subscription;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处回收元素</span></span><br><span class="line">    PendingPost.releasePendingPost(pendingPost);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断订阅关系是否活跃</span></span><br><span class="line">    <span class="keyword">if</span> (subscription.active) &#123;</span><br><span class="line">        <span class="comment">// 反射调用订阅方法</span></span><br><span class="line">        invokeSubscriber(subscription, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HandlerPoster</code> 为避免阻塞主线程，默认单轮事件分发最多执行 <strong>10 毫秒</strong>，即 10 毫秒内可以分发多个事件，多个订阅方法的执行耗时之和超时 10 毫秒后，就会停止本轮事件分发，重新发送一个空消息给 Handler 等待执行下轮事件分发。这里的处理思路，我们可以借鉴。</p>
<h2 id="backgroundposter"><a class="markdownIt-Anchor" href="#backgroundposter"></a> BackgroundPoster</h2>
<p><code>BackgroundPoster</code> 用于 <code>BACKGROUND</code> 线程模型，将事件分发到后台线程。</p>
<p><code>BackgroundPoster</code> 实现了 <code>Runnable</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Poster &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待发布事件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否活跃，可以理解为队列是否还有数据，volatile 禁止重排序，保证多线程可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> executorRunning;</span><br><span class="line"></span><br><span class="line">    BackgroundPoster(EventBus eventBus) &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventBus = eventBus;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">PendingPostQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取队列元素(事件包装类型)</span></span><br><span class="line">        <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 元素入队</span></span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不活跃时，由线程池执行此 Runnable</span></span><br><span class="line">            <span class="keyword">if</span> (!executorRunning) &#123;</span><br><span class="line">                executorRunning = <span class="literal">true</span>;</span><br><span class="line">                eventBus.getExecutorService().execute(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件分发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 最长等待1000毫秒，取出头部元素</span></span><br><span class="line">                    <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> queue.poll(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果为空再加锁获取头部元素</span></span><br><span class="line">                        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                            <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                            pendingPost = queue.poll();</span><br><span class="line">                            <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 还是为空，重置活跃状态，退出循环</span></span><br><span class="line">                                executorRunning = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 分发事件，调用订阅方法</span></span><br><span class="line">                    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + <span class="string">&quot; was interruppted&quot;</span>, e);</span><br><span class="line">				<span class="comment">// 忽略中断事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 此时已退出 while 循环，即认为待发布事件队列为空</span></span><br><span class="line">            executorRunning = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BackgroundPoster</code> 同样实现了 <code>Poster</code> 接口中的 <code>enqueue</code> 方法用于事件入队，不过 <code>BackgroundPoster</code> 使用线程池进行事件分发，所以在 <code>run</code> 方法中调用 <code>EventBus#invokeSubscriber</code> 方法传入待发布事件队列元素分发事件。</p>
<p><code>BackgroundPoster</code> 在处理时间分发时，第一次获取元素时调用了 <code>poll(int)</code> 方法，如果队列为空，最长等待1000毫秒后再次取头部元素，为何要这样实现？</p>
<p>这里笔者猜测是想提高事件分发效率与线程利用率，因为 <code>BackgroundPoster</code> 是在子线程中分发事件，如果队列为空，可以接收最长等待1000毫秒后再次取头部元素，减小在第二次加锁取头部元素还为空的几率，及减小线程切换导致的资源开销，充分利用线程资源，提高事件分发效率。</p>
<p><code>BackgroundPoster</code> 默认使用 EventBus 中的线程池 <code>CachedThreadPool</code>，<strong>在事件分发时，<code>BackgroundPoster</code> 忽略了 <code>InterruptedException</code> ，即没有响应线程中断，如果我们使用自定义的线程池，我们在外边关闭线程池后，这可能导致事件分发还在继续。</strong></p>
<p>最后，<code>BACKGROUND</code> 线程模型描述中说使用单线程进行事件分发，为何在 <code>BackgroundPoster</code> 中却是使用的线程池呢？</p>
<p>其实这个问题我们很容易就解答了。因为在 <code>BackgroundPoster</code> 中使用了 <code>executorRunning</code> 变量，这个变量保证执行单轮事件分发时，都使用线程池中的一个线程，单轮事件分发完成后，新的一轮事件分发可能就使用其他的线程了。</p>
<h2 id="asyncposter"><a class="markdownIt-Anchor" href="#asyncposter"></a> AsyncPoster</h2>
<p><code>AsyncPoster</code> 用于 <code>ASYNC</code> 线程模型，将事件分发到异步线程。</p>
<p><code>AsyncPoster</code> 实现了 <code>Runnable</code> 和 <code>Poster</code> 接口，使用线程池实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncPoster</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Poster &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待发布事件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    AsyncPoster(EventBus eventBus) &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventBus = eventBus;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">PendingPostQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">        <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="comment">// 由线程池执行此 Runnable</span></span><br><span class="line">        eventBus.getExecutorService().execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件分发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No pending post available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AsyncPoster</code> 的实现比较简单，调用 <code>enqueue</code> 方法将事件入队并交由线程池进行事件分发，<code>run</code> 方法处理事件分发。</p>
<p><code>AsyncPoster</code> 默认使用 EventBus 中的线程池 <code>CachedThreadPool</code>，<code>CachedThreadPool</code> 没有核心线程，允许创建 <code>Integer.MAX_VALUE</code> 个工作线程且线程空闲时的存活时长为 60 秒，如果发布多个耗时较短的事件或多个耗时较长的时间，都会导致创建多个工作线程而浪费资源。</p>
<p>至此，EventBus 的线程调度分析完成。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本文对 EventBus 的线程调度进行了分析，最后我们做下总结：</p>
<h3 id="pendingpostqueue"><a class="markdownIt-Anchor" href="#pendingpostqueue"></a> PendingPostQueue</h3>
<p>在 <code>PendingPostQueue</code> 中，我们学到了如何使用单链表实现先进先出(FIFO)队列。</p>
<h3 id="pendingpost"><a class="markdownIt-Anchor" href="#pendingpost"></a> PendingPost</h3>
<p>在 <code>PendingPost</code> 中，我们学到了「享元模式」的使用以及如何定义单链表数据结构。</p>
<h3 id="handlerposter-2"><a class="markdownIt-Anchor" href="#handlerposter-2"></a> HandlerPoster</h3>
<p>在 <code>HandlerPoster</code> 中判断单轮事件分发最大处理时长机制，及时让出主线程的执行权，避免阻塞主线程；不过这个机制适用于耗时短的订阅方法，如果订阅方法耗时较长，一样会阻塞主线程。</p>
<h3 id="backgroundposter-2"><a class="markdownIt-Anchor" href="#backgroundposter-2"></a> BackgroundPoster</h3>
<p>在 <code>BackgroundPoster</code> 中调用 <code>poll(int)</code> 提高事件分发效率和线程利用率，不过 <code>BackgroundPoster</code> 忽略了线程中断异常，使用自定义线程池时需要注意这里，最后我们解答了 <code>BACKGROUND</code> 线程模型描述中说使用单线程进行事件分发，而 <code>BackgroundPoster</code> 却是使用的线程池问题。</p>
<h3 id="asyncposter-2"><a class="markdownIt-Anchor" href="#asyncposter-2"></a> AsyncPoster</h3>
<p><code>AsyncPoster</code> 比较简单，一般简单的地方反而意味着是比较危险的，我们通常会看不到它的危险性，因为我们认为它足够简单。</p>
<h3 id="poster"><a class="markdownIt-Anchor" href="#poster"></a> Poster</h3>
<p><code>Poster</code> 说一下吧，设计框架时尽量使用接口或抽象类。</p>
<p>最后，还是那句话：<strong>无论使用哪种线程模型，在订阅方法中都应该尽量避免进行耗时操作。</strong></p>
<p>happy~，希望可以帮你更好的使用 EventBus</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>eventbus</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-EventBus修改纪实(二)-线程模型</title>
    <url>/2022/06/02/Android/Android-EventBus%E4%BF%AE%E6%94%B9%E7%BA%AA%E5%AE%9E(%E4%BA%8C)-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="android-eventbus修改纪实二"><a class="markdownIt-Anchor" href="#android-eventbus修改纪实二"></a> Android-EventBus修改纪实(二)</h1>
<p>持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第 4 天，<a href="https://juejin.cn/post/7099702781094674468">点击查看活动详情</a></p>
<hr />
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>在上一篇 <a href="https://juejin.cn/post/7104107150678917133">Android-EventBus修改纪实</a> 中笔者分析了 EventBus 黏性事件的发送流程并对 EventBus 进行增强实现了必达事件的支持，上一篇文章最后笔者没有实现以下方法：</p>
<ul>
<li>获取必达事件，</li>
<li>移除必达事件，</li>
<li>编写必达事件单元测试</li>
</ul>
<p>本篇文章补全上一篇文章未实现的部分，最后应上一篇文章中掘友的需求对 EventBus 的线程切换做下分析。</p>
<h2 id="纪实"><a class="markdownIt-Anchor" href="#纪实"></a> 纪实</h2>
<h3 id="getrendezvousevent"><a class="markdownIt-Anchor" href="#getrendezvousevent"></a> getRendezvousEvent</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择List存储必达事件，使用Pair封装必达事件的Key和Value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Pair&lt;Class&lt;?&gt;, Object&gt;&gt; rendezvousEvents;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getRendezvousEvent</span><span class="params">(Class&lt;T&gt; eventType)</span> &#123;</span><br><span class="line">    <span class="comment">// 对`rendezvousEvents`加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (rendezvousEvents) &#123;</span><br><span class="line">        <span class="comment">// 遍历必达事件集合</span></span><br><span class="line">        <span class="keyword">for</span> (Pair&lt;Class&lt;?&gt;, Object&gt; next : rendezvousEvents) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 取出Key</span></span><br><span class="line">            Class&lt;?&gt; first = next.first;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 与入参进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (eventType.equals(first)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 把Value转换为入参的类型</span></span><br><span class="line">                <span class="keyword">return</span> eventType.cast(next.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过仿照 EventBus 中获取黏性事件的实现来写出获取必达事件的实现，在源码实现中首先对存储必达事件的集合 <code>rendezvousEvents</code> 进行加锁，防止并发修改必达事件集合，其次遍历必达集合，取出必达事件的 Key，即必达事件的 Class 对象，与入参的 Class 对象进行比较，如果相等，则取出必达事件的 Value，强制转换为入参类型。</p>
<h3 id="removerendezvousevent"><a class="markdownIt-Anchor" href="#removerendezvousevent"></a> removeRendezvousEvent</h3>
<p>有两个移除必达事件的方法，一个根据必达事件的 Class 对象进行移除，另外一个根据必达事件的实例进行移除，下面我们一一实现：</p>
<h4 id="removerendezvouseventclasst-eventtype"><a class="markdownIt-Anchor" href="#removerendezvouseventclasst-eventtype"></a> removeRendezvousEvent(Class<T> eventType)</h4>
<p>我们先实现根据必达事件的 Class 对象进行移除的方法，实现源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择List存储必达事件，使用Pair封装必达事件的Key和Value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Pair&lt;Class&lt;?&gt;, Object&gt;&gt; rendezvousEvents;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入参必达事件的 Class 对象</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">removeRendezvousEvent</span><span class="params">(Class&lt;T&gt; eventType)</span> &#123;</span><br><span class="line">    <span class="comment">// 对`rendezvousEvents`加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (rendezvousEvents) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> rendezvousEvents.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用普通的 for 循环，避免产生 ConcurrentModificationException</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Pair&lt;Class&lt;?&gt;, Object&gt; pair = rendezvousEvents.get(i);</span><br><span class="line">            Class&lt;?&gt; first = pair.first;</span><br><span class="line">            <span class="comment">// 比较必达事件的 Class 对象与入参是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (eventType.equals(first)) &#123;</span><br><span class="line">                rendezvousEvents.remove(i);</span><br><span class="line">                <span class="keyword">return</span> eventType.cast(pair.second);</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的源码中首先对 <code>rendezvousEvents</code> 进行加锁，在临界区内使用普通的 for 循环，而不使用增强的 forEach 循环遍历 <code>rendezvousEvents</code> 是避免发生同步修改异常 <code>ConcurrentModificationException</code>，虽然 <code>rendezvousEvents</code> 的实例是 <code>CopyOnWriteArrayList</code>。</p>
<p>在循环体内，取出存储必达事件的 Class 对象与入参比较，判断是否相等，相等即移除此必达事件，同时返回必达事件的实例。</p>
<p>不知读者有没有发现这里移除必达事件有什么问题？</p>
<p>我们的 <code>rendezvousEvents</code> 是 List 集合结构，上面的实现中，我们是不是只移除了第一个必达事件方法就返回了，如何实现根据必达事件的 Class 对象移除必达事件相信读者可以自行修改实现，笔者这里就不实现了。</p>
<h4 id="removerendezvouseventobject-event"><a class="markdownIt-Anchor" href="#removerendezvouseventobject-event"></a> removeRendezvousEvent(Object event)</h4>
<p>接下来我们实现根据必达事件的实例进行移除，实现源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择List存储必达事件，使用Pair封装必达事件的Key和Value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Pair&lt;Class&lt;?&gt;, Object&gt;&gt; rendezvousEvents;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入参必达事件的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeRendezvousEvent</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对`rendezvousEvents`加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (rendezvousEvents) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> rendezvousEvents.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用普通的 for 循环，避免产生 ConcurrentModificationException</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Pair&lt;Class&lt;?&gt;, Object&gt; pair = rendezvousEvents.get(i);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">second</span> <span class="operator">=</span> pair.second;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 比较必达事件的实例与入参是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (event.equals(second)) &#123;</span><br><span class="line">                rendezvousEvents.remove(i);</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们根据 <code>removeRendezvousEvent(Class&lt;T&gt; eventType)</code> 的实现，很容易就可以实现根据必达事件的实例进行移除的逻辑，与 <code>removeRendezvousEvent(Class&lt;T&gt; eventType)</code> 的实现类似，首先对 <code>rendezvousEvents</code> 进行加锁，在临界区内使用普通的 for 循环，在循环体内，取出存储必达事件的实例与入参比较，判断是否相等，相等即移除此必达事件，同时把移除结果置为 True ，最后返回移除结果。</p>
<p>至此，我们终于完成了对 EventBus 增加必达事件的所有逻辑。</p>
<h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3>
<p>接下来让我们编写单元测试逻辑来测试我们必达事件的逻辑正确性吧。</p>
<h4 id="eventbusstickyeventtest"><a class="markdownIt-Anchor" href="#eventbusstickyeventtest"></a> EventBusStickyEventTest</h4>
<p>我们先看看 EventBus 中对黏性事件的单元测试用例，用例较多，笔者挑选几个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusStickyEventTest</span> <span class="keyword">extends</span> <span class="title class_">AbstractEventBusTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试发送黏性事件的逻辑</span></span><br><span class="line">    <span class="comment">// 先发送黏性事件，再注册订阅者，然后断言最后一个事件与发送的黏性事件相等，最后断言最后一个订阅方法的线程是当前线程</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostSticky</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postSticky(<span class="string">&quot;Sticky&quot;</span>);</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Sticky&quot;</span>, lastEvent);</span><br><span class="line">        assertEquals(Thread.currentThread(), lastThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试没有黏性事件订阅方法时的逻辑</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostNonStickyRegisterSticky</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.post(<span class="string">&quot;NonSticky&quot;</span>);</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertNull(lastEvent);</span><br><span class="line">        assertEquals(<span class="number">0</span>, eventCount.intValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试注册与反注册订阅者对黏性事件的影响</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostStickyWithRegisterAndUnregister</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        eventBus.postSticky(<span class="string">&quot;Sticky&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Sticky&quot;</span>, lastEvent);</span><br><span class="line"></span><br><span class="line">        eventBus.unregister(<span class="built_in">this</span>);</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Sticky&quot;</span>, lastEvent);</span><br><span class="line">        assertEquals(<span class="number">2</span>, eventCount.intValue());</span><br><span class="line"></span><br><span class="line">        eventBus.postSticky(<span class="string">&quot;NewSticky&quot;</span>);</span><br><span class="line">        assertEquals(<span class="number">3</span>, eventCount.intValue());</span><br><span class="line">        assertEquals(<span class="string">&quot;NewSticky&quot;</span>, lastEvent);</span><br><span class="line"></span><br><span class="line">        eventBus.unregister(<span class="built_in">this</span>);</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertEquals(<span class="number">4</span>, eventCount.intValue());</span><br><span class="line">        assertEquals(<span class="string">&quot;NewSticky&quot;</span>, lastEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试获取黏性事件</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostStickyAndGet</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postSticky(<span class="string">&quot;Sticky&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Sticky&quot;</span>, eventBus.getStickyEvent(String.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试移除黏性事件</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostStickyRemoveEvent</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postSticky(<span class="string">&quot;Sticky&quot;</span>);</span><br><span class="line">        assertTrue(eventBus.removeStickyEvent(<span class="string">&quot;Sticky&quot;</span>));</span><br><span class="line">        assertNull(eventBus.getStickyEvent(String.class));</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertNull(lastEvent);</span><br><span class="line">        assertEquals(<span class="number">0</span>, eventCount.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="eventbusrendezvouseventtest"><a class="markdownIt-Anchor" href="#eventbusrendezvouseventtest"></a> EventBusRendezvousEventTest</h4>
<p>我们可以根据 <code>EventBusStickyEventTest</code> 编写必达事件的测试用例，以下为笔者实现的测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusRendezvousEventTest</span> <span class="keyword">extends</span> <span class="title class_">AbstractEventBusTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRendezvousSticky</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Rendezvous&quot;</span>, lastEvent);</span><br><span class="line">        assertEquals(Thread.currentThread(), lastThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostRendezvousTwoEvents</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        eventBus.postRendezvous(<span class="keyword">new</span> <span class="title class_">IntTestEvent</span>(<span class="number">7</span>));</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertEquals(<span class="number">2</span>, eventCount.intValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostRendezvousTwoSubscribers</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        eventBus.postRendezvous(<span class="keyword">new</span> <span class="title class_">IntTestEvent</span>(<span class="number">7</span>));</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">RendezvousIntTestSubscriber</span> <span class="variable">subscriber2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RendezvousIntTestSubscriber</span>();</span><br><span class="line">        eventBus.register(subscriber2);</span><br><span class="line">        assertEquals(<span class="number">3</span>, eventCount.intValue());</span><br><span class="line"></span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        assertEquals(<span class="number">4</span>, eventCount.intValue());</span><br><span class="line"></span><br><span class="line">        eventBus.postRendezvous(<span class="keyword">new</span> <span class="title class_">IntTestEvent</span>(<span class="number">8</span>));</span><br><span class="line">        assertEquals(<span class="number">6</span>, eventCount.intValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostRendezvousRegisterNonRendezvous</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">NonRendezvousSubscriber</span>());</span><br><span class="line">        assertNull(lastEvent);</span><br><span class="line">        assertEquals(<span class="number">0</span>, eventCount.intValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostNonRendezvousRegisterRendezvous</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.post(<span class="string">&quot;NonRendezvous&quot;</span>);</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertNull(lastEvent);</span><br><span class="line">        assertEquals(<span class="number">0</span>, eventCount.intValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostRendezvousTwice</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;NewRendezvous&quot;</span>);</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertEquals(<span class="number">2</span>, eventCount.intValue());</span><br><span class="line">        assertEquals(<span class="string">&quot;NewRendezvous&quot;</span>, lastEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostRendezvousThenPostNormal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        eventBus.post(<span class="string">&quot;NonRendezvous&quot;</span>);</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertEquals(<span class="number">1</span>, eventCount.intValue());</span><br><span class="line">        assertEquals(<span class="string">&quot;Rendezvous&quot;</span>, lastEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostRendezvousWithRegisterAndUnregister</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Rendezvous&quot;</span>, lastEvent);</span><br><span class="line"></span><br><span class="line">        eventBus.unregister(<span class="built_in">this</span>);</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Rendezvous&quot;</span>, lastEvent);</span><br><span class="line">        assertEquals(<span class="number">2</span>, eventCount.intValue());</span><br><span class="line"></span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;NewRendezvous&quot;</span>);</span><br><span class="line">        assertEquals(<span class="number">3</span>, eventCount.intValue());</span><br><span class="line">        assertEquals(<span class="string">&quot;NewRendezvous&quot;</span>, lastEvent);</span><br><span class="line"></span><br><span class="line">        eventBus.unregister(<span class="built_in">this</span>);</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertEquals(<span class="number">5</span>, eventCount.intValue());</span><br><span class="line">        assertEquals(<span class="string">&quot;NewRendezvous&quot;</span>, lastEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostRendezvousAndGet</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Rendezvous&quot;</span>, eventBus.getRendezvousEvent(String.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostRendezvousRemoveClass</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        eventBus.removeRendezvousEvent(String.class);</span><br><span class="line">        assertNull(eventBus.getRendezvousEvent(String.class));</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertNull(lastEvent);</span><br><span class="line">        assertEquals(<span class="number">0</span>, eventCount.intValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostRendezvousRemoveEvent</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        assertTrue(eventBus.removeRendezvousEvent(<span class="string">&quot;Rendezvous&quot;</span>));</span><br><span class="line">        assertNull(eventBus.getRendezvousEvent(String.class));</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertNull(lastEvent);</span><br><span class="line">        assertEquals(<span class="number">0</span>, eventCount.intValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostRendezvousRemoveAll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        eventBus.postRendezvous(<span class="keyword">new</span> <span class="title class_">IntTestEvent</span>(<span class="number">77</span>));</span><br><span class="line">        eventBus.removeAllRendezvousEvents();</span><br><span class="line">        assertNull(eventBus.getRendezvousEvent(String.class));</span><br><span class="line">        assertNull(eventBus.getRendezvousEvent(IntTestEvent.class));</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertNull(lastEvent);</span><br><span class="line">        assertEquals(<span class="number">0</span>, eventCount.intValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRemoveRendezvousEventInSubscriber</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">RendezvousStickySubscriber</span>());</span><br><span class="line">        eventBus.postRendezvous(<span class="string">&quot;Rendezvous&quot;</span>);</span><br><span class="line">        eventBus.register(<span class="built_in">this</span>);</span><br><span class="line">        assertNull(lastEvent);</span><br><span class="line">        assertEquals(<span class="number">0</span>, eventCount.intValue());</span><br><span class="line">        assertNull(eventBus.getRendezvousEvent(String.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe(rendezvous = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(String event)</span> &#123;</span><br><span class="line">        trackEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe(rendezvous = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(IntTestEvent event)</span> &#123;</span><br><span class="line">        trackEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RendezvousStickySubscriber</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        <span class="meta">@Subscribe(rendezvous = true)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(String event)</span> &#123;</span><br><span class="line">            eventBus.removeRendezvousEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonRendezvousSubscriber</span> &#123;</span><br><span class="line">        <span class="meta">@Subscribe</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(String event)</span> &#123;</span><br><span class="line">            trackEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Subscribe</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(IntTestEvent event)</span> &#123;</span><br><span class="line">            trackEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RendezvousIntTestSubscriber</span> &#123;</span><br><span class="line">        <span class="meta">@Subscribe(rendezvous = true)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(IntTestEvent event)</span> &#123;</span><br><span class="line">            trackEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的测试用例源码中，笔者编写了 13 个测试用例，涉及发送一个必达事件，发送两个必达事件，发送必达事件与普通事件，注册订阅者与反注册对必达事件的影响，获取和移除必达事件等。</p>
<h3 id="线程调度"><a class="markdownIt-Anchor" href="#线程调度"></a> 线程调度</h3>
<h4 id="线程模型"><a class="markdownIt-Anchor" href="#线程模型"></a> 线程模型</h4>
<p>目前 EventBus 对订阅方法支持 5 种线程模型的调度，分别是：</p>
<ol>
<li><code>ThreadMode.POSTING</code> // <strong>对于普通事件来说在事件发布线程来分发事件</strong></li>
<li><code>ThreadMode.MAIN</code> // 在主线程来分发事件，根据是否在 Android 上使用，处理逻辑不同</li>
<li><code>ThreadMode.MAIN_ORDERED</code> // 在主线程按顺序来分发事件</li>
<li><code>ThreadMode.BACKGROUND</code> // 在后台线程来分发事件，根据是否在 Android 上使用，处理逻辑不同。使用单线程处理，尽量不要进行耗时操作以免阻塞后台线程</li>
<li><code>ThreadMode.ASYNC</code> // 在异步线程来分发事件，使用线程池处理</li>
</ol>
<p>在上一篇文章中我们分析黏性事件发送的流程时，事件的发送都会调用 <code>postToSubscription</code> 方法，最终调用 <code>invokeSubscriber</code> 方法来反射调用订阅方法，下面再贴出 <code>postToSubscription</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="type">boolean</span> isMainThread)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="comment">// 处理POSTING</span></span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            <span class="comment">// 直接分发事件</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 处理MAIN</span></span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="comment">// 是否是主线程，在非 Android 平台上时，isMainThread 也是 true</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此时 mainThreadPoster != null，可以认为是在 Android 平台上</span></span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理MAIN_ORDERED</span></span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="comment">// 不管是否是主线程，总是先判断是否可以入队</span></span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="literal">null</span>) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                <span class="comment">// 否则直接分发事件</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理BACKGROUND</span></span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="comment">// 如果是主线程则入队，backgroundPoster使用单个后台线程依次分发事件，订阅方法应尽快返回以免阻塞后台线程</span></span><br><span class="line">            <span class="comment">// 在非 Android 平台上时，isMainThread 也是 true，即在非 Android 平台上时，始终在后台线程分发事件</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则直接分发事件</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理ASYNC</span></span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            <span class="comment">// 始终异步分发事件</span></span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unknown thread mode: &quot;</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="posting"><a class="markdownIt-Anchor" href="#posting"></a> POSTING</h4>
<p>这是 <code>@Subscribe</code> 注解中线程模型的默认配置，对于该线程调度模型，这里需要注意：</p>
<ol>
<li><strong>对于普通事件来说，事件发布与订阅方法将在同一个线程，这是该线程调度模型的本意</strong></li>
<li><strong>但是对于黏性事件和必达事件来说，事件发布与订阅方法可能不在同一个线程</strong></li>
</ol>
<p>比如以下代码示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainActivity.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    </span><br><span class="line">    thread &#123;</span><br><span class="line">        <span class="comment">// 在子线程中发布黏性事件</span></span><br><span class="line">        EventBus.getDefault().postSticky(<span class="string">&quot;Event-1&quot;</span>)</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onCreate: postSticky-1, ThreadName = <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        runOnUiThread &#123;</span><br><span class="line">            <span class="comment">// 在主线程中注册订阅者</span></span><br><span class="line">            Log.e(TAG, <span class="string">&quot;onCreate: register, ThreadName = <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            EventBus.getDefault().register(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再在主线程发布一个黏性事件</span></span><br><span class="line">            Log.e(TAG, <span class="string">&quot;onCreate: postSticky-2, ThreadName = <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            EventBus.getDefault().postSticky(<span class="string">&quot;Event-2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅方法 使用 POSTING 线程模型</span></span><br><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.POSTING, sticky = true)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eventBusTest</span><span class="params">(event: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;eventBusTest: event = <span class="variable">$event</span>, ThreadName = <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logcat</span></span><br><span class="line">&gt;&gt; onCreate: postSticky-<span class="number">1</span>, ThreadName = Thread-<span class="number">290</span>   ①</span><br><span class="line">&gt;&gt; onCreate: register, ThreadName = main             ②</span><br><span class="line">&gt;&gt; eventBusTest: event = Event-<span class="number">1</span>, ThreadName = main  ③</span><br><span class="line">&gt;&gt; onCreate: postSticky-<span class="number">2</span>, ThreadName = main         ④</span><br><span class="line">&gt;&gt; eventBusTest: event = Event-<span class="number">2</span>, ThreadName = main  ⑤</span><br></pre></td></tr></table></figure>
<p>在上述代码示例中，有一个使用 <code>POSTING</code> 线程模型的订阅方法，我们分析下示例代码：</p>
<ol>
<li>我们先在子线程中发布一个黏性事件 <code>Event-1</code>，</li>
<li>然后切换到主线程去注册订阅者，</li>
<li>最后在主线程再发布一个黏性事件 <code>Event-2</code>。</li>
</ol>
<p>接下来我们分析下 Logcat 的输出，一共 5 条日志输出，我们一一分析：</p>
<ol>
<li>第一条日志是在子线程发布第一个黏性事件时输出的，标识事件发布是在子线程：<strong>Thread-290</strong></li>
<li>第二条日志是在主线程中注册订阅者时输出的，标识注册订阅者是在主线程</li>
<li>第三条日志是订阅方法收到第一个黏性事件时输出的，标识订阅方法此时是在主线程</li>
<li>第四条日志是在主线程中发布第二个黏性事件时输出的，标识事件发布是在主线程</li>
<li>第五条日志是订阅方法收到第二个黏性事件时输出的，标识订阅方法此时是在主线程</li>
</ol>
<p>我们根据 Logcat 的日志输出发现订阅方法收到 <code>Event-1</code> 黏性事件是在 <code>main</code> 线程，这与 <code>POSTING</code> 线程模型的描述不符，再往下看收到 <code>Event-2</code> 黏性事件是在 <code>main</code> 线程，与 <code>POSTING</code> 线程模型的描述符合。</p>
<p>以上发现与上一篇 <a href="https://juejin.cn/post/7104107150678917133">Android-EventBus修改纪实</a> 中黏性事件的发送流程分析吻合：</p>
<ol>
<li>黏性事件发布时如果没有订阅者，那么黏性事件的发送将在订阅者 <code>register</code> 时发送</li>
<li>黏性事件发布时有订阅者，那么已有的订阅者会收到黏性事件，发布后注册的订阅者会在 <code>register</code> 时收到</li>
</ol>
<p>最后得出结论：</p>
<ol>
<li><strong>谨慎把 <code>POSTING</code> 线程模型用于黏性事件和必达事件，此时 <code>POSTING</code> 线程模型将失效，订阅方法将在订阅者注册的线程中调用</strong></li>
<li><strong>对于普通事件，使用 <code>POSTING</code> 线程模型时，最好不用进行耗时操作，以免阻塞事件发布线程</strong></li>
</ol>
<h4 id="main和main_ordered"><a class="markdownIt-Anchor" href="#main和main_ordered"></a> MAIN和MAIN_ORDERED</h4>
<p><code>MAIN</code> 和 <code>MAIN_ORDERED</code> 线程模型都会在主线程分发事件，后者有个排序作用：</p>
<ol>
<li><code>MAIN</code> 线程模型首先尝试直接在主线程分发事件(这可能会阻塞事件发布线程)，如果不行再切换至主线程分发，</li>
<li><code>MAIN_ORDERED</code> 线程模型不管当前线程是否是主线程，始终会切换至主线程依次分发，这保证不会阻塞事件发布线程。</li>
</ol>
<p><strong>不管使用哪种线程模型都不应在订阅方法中进行耗时操作。</strong></p>
<h4 id="background"><a class="markdownIt-Anchor" href="#background"></a> BACKGROUND</h4>
<p><code>BACKGROUND</code> 线程模式也需要注意普通事件与黏性事件和必达事件不同的分发逻辑：</p>
<ol>
<li>如果是普通事件，事件将始终在 EventBus 的单个后台线程中依次分发，</li>
<li>如果是黏性事件或必达事件，事件可能不在 EventBus 的单个后台线程中依次分发，原因见 <code>POSTING</code> 线程模型。</li>
</ol>
<h4 id="async"><a class="markdownIt-Anchor" href="#async"></a> ASYNC</h4>
<p><code>ASYNC</code> 线程模型都将异步的分发事件，在此线程模型下可以执行耗时操作，但也应该避免触发大量耗时操作，以限制并发线程数。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本篇文章提供了一版在上一篇文章中必达事件未实现方法的实现，并对必达事件编写了单元测试，最后通过分析 EventBus 提供的 5 种线程模型，明白了 EventBus 是如何实现线程切换的。</p>
<p>EventBus 对外提供了 5 种线程模型，方便使用者做事件的线程调度，但无论使用哪种线程模型，在订阅方法中都应该尽量避免进行耗时操作。</p>
<p>不过我们最后没有分析线程切换的具体源码，下篇一定~~</p>
<p>happy~~，希望可以帮你更好的使用 EventBus</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>eventbus</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-TextView跑马灯探秘</title>
    <url>/2022/05/05/Android/Android-TextView%E8%B7%91%E9%A9%AC%E7%81%AF%E6%8E%A2%E7%A7%98/</url>
    <content><![CDATA[<h1 id="android-textview跑马灯探秘"><a class="markdownIt-Anchor" href="#android-textview跑马灯探秘"></a> Android-TextView跑马灯探秘</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>自定义View实现的跑马灯一直没有实现类似 <code>Android TextView</code> 的跑马灯首尾相接的效果，所以一直想看看<code>Android TextView</code> 的跑马灯是如何实现</p>
<p>本文主要探秘 <code>Android TextView</code> 的跑马灯实现原理及实现自下往上效果的跑马灯</p>
<h2 id="探秘"><a class="markdownIt-Anchor" href="#探秘"></a> 探秘</h2>
<h3 id="textviewondraw"><a class="markdownIt-Anchor" href="#textviewondraw"></a> TextView#onDraw</h3>
<p>原生 <code>Android TextView</code> 如何设置开启跑马灯效果，此处不再描述</p>
<p><code>View</code> 的绘制都在 <code>onDraw</code> 方法中，这里直接查看 <code>TextView#onDraw()</code> 方法，删减一些不关心的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">	<span class="comment">// 是否需要重新启动跑马灯</span></span><br><span class="line">	restartMarqueeIfNeeded();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw the background for this view</span></span><br><span class="line">    <span class="built_in">super</span>.onDraw(canvas);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 删减不关心的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建`mLayout`对象, 此处为`StaticLayout`</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="literal">null</span>) &#123;</span><br><span class="line">        assumeLayout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Layout</span> <span class="variable">layout</span> <span class="operator">=</span> mLayout;</span><br><span class="line"></span><br><span class="line">    canvas.save();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删减不关心的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">layoutDirection</span> <span class="operator">=</span> getLayoutDirection();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">absoluteGravity</span> <span class="operator">=</span> Gravity.getAbsoluteGravity(mGravity, layoutDirection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断跑马灯设置项是否正确</span></span><br><span class="line">	<span class="keyword">if</span> (isMarqueeFadeEnabled()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mSingleLine &amp;&amp; getLineCount() == <span class="number">1</span> &amp;&amp; canMarquee()</span><br><span class="line">              &amp;&amp; (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) != Gravity.LEFT) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> mRight - mLeft;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> getCompoundPaddingLeft() + getCompoundPaddingRight();</span><br><span class="line">           <span class="keyword">final</span> <span class="type">float</span> <span class="variable">dx</span> <span class="operator">=</span> mLayout.getLineRight(<span class="number">0</span>) - (width - padding);</span><br><span class="line">           canvas.translate(layout.getParagraphDirection(<span class="number">0</span>) * dx, <span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断跑马灯是否启动</span></span><br><span class="line">        <span class="keyword">if</span> (mMarquee != <span class="literal">null</span> &amp;&amp; mMarquee.isRunning()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span> <span class="variable">dx</span> <span class="operator">=</span> -mMarquee.getScroll();</span><br><span class="line">            <span class="comment">// 移动画布</span></span><br><span class="line">            canvas.translate(layout.getParagraphDirection(<span class="number">0</span>) * dx, <span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cursorOffsetVertical</span> <span class="operator">=</span> voffsetCursor - voffsetText;</span><br><span class="line"></span><br><span class="line">    <span class="type">Path</span> <span class="variable">highlight</span> <span class="operator">=</span> getUpdatedHighlightPath();</span><br><span class="line">    <span class="keyword">if</span> (mEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">        mEditor.onDraw(canvas, layout, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 绘制文本</span></span><br><span class="line">        layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否可以绘制尾部文本</span></span><br><span class="line">    <span class="keyword">if</span> (mMarquee != <span class="literal">null</span> &amp;&amp; mMarquee.shouldDrawGhost()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">dx</span> <span class="operator">=</span> mMarquee.getGhostOffset();</span><br><span class="line">        <span class="comment">// 移动画布</span></span><br><span class="line">        canvas.translate(layout.getParagraphDirection(<span class="number">0</span>) * dx, <span class="number">0.0f</span>);</span><br><span class="line">        <span class="comment">// 绘制尾部文本</span></span><br><span class="line">        layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="marquee"><a class="markdownIt-Anchor" href="#marquee"></a> Marquee</h3>
<p>根据 <code>onDraw()</code> 方法分析，跑马灯效果的实现主要依赖 <code>mMarquee</code> 这个对象来实现，好的，看下 <code>Marquee</code> 吧，<code>Marquee</code> 代码较少，就贴上全部源码吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Marquee</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Add an option to configure this</span></span><br><span class="line">    <span class="comment">// 缩放相关，不关心此字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">MARQUEE_DELTA_MAX</span> <span class="operator">=</span> <span class="number">0.07f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跑马灯跑完一次后多久开始下一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MARQUEE_DELAY</span> <span class="operator">=</span> <span class="number">1200</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制一次跑多长距离因子，此字段与速度相关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MARQUEE_DP_PER_SECOND</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跑马灯状态常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">MARQUEE_STOPPED</span> <span class="operator">=</span> <span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">MARQUEE_STARTING</span> <span class="operator">=</span> <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">MARQUEE_RUNNING</span> <span class="operator">=</span> <span class="number">0x2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对TextView进行弱引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;TextView&gt; mView;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 帧率相关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Choreographer mChoreographer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> <span class="variable">mStatus</span> <span class="operator">=</span> MARQUEE_STOPPED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制一次跑多长距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> mPixelsPerMs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最大滚动距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mMaxScroll;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否可以绘制右阴影, 右侧淡入淡出效果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mMaxFadeScroll;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尾部文本什么时候开始绘制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mGhostStart;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尾部文本绘制位置偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mGhostOffset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否可以绘制左阴影，左侧淡入淡出效果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mFadeStop;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重复限制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mRepeatLimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跑动距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mScroll;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一次跑动时间，单位毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mLastAnimationMs;</span><br><span class="line"></span><br><span class="line">    Marquee(TextView v) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">density</span> <span class="operator">=</span> v.getContext().getResources().getDisplayMetrics().density;</span><br><span class="line">        <span class="comment">// 计算每次跑多长距离</span></span><br><span class="line">        mPixelsPerMs = MARQUEE_DP_PER_SECOND * density / <span class="number">1000f</span>;</span><br><span class="line">        mView = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;TextView&gt;(v);</span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 帧率回调，用于跑马灯跑动</span></span><br><span class="line">    <span class="keyword">private</span> Choreographer.<span class="type">FrameCallback</span> <span class="variable">mTickCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>.FrameCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">            tick();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 帧率回调，用于跑马灯开始跑动</span></span><br><span class="line">    <span class="keyword">private</span> Choreographer.<span class="type">FrameCallback</span> <span class="variable">mStartCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>.FrameCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">            mStatus = MARQUEE_RUNNING;</span><br><span class="line">            mLastAnimationMs = mChoreographer.getFrameTime();</span><br><span class="line">            tick();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 帧率回调，用于跑马灯重新跑动</span></span><br><span class="line">    <span class="keyword">private</span> Choreographer.<span class="type">FrameCallback</span> <span class="variable">mRestartCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>.FrameCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mStatus == MARQUEE_RUNNING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRepeatLimit &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    mRepeatLimit--;</span><br><span class="line">                &#125;</span><br><span class="line">                start(mRepeatLimit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跑马灯跑动实现</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tick</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStatus != MARQUEE_RUNNING) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mChoreographer.removeFrameCallback(mTickCallback);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> mView.get();</span><br><span class="line">        <span class="comment">// 判断TextView是否处于获取焦点或选中状态</span></span><br><span class="line">        <span class="keyword">if</span> (textView != <span class="literal">null</span> &amp;&amp; (textView.isFocused() || textView.isSelected())) &#123;</span><br><span class="line">            <span class="comment">// 获取当前时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">currentMs</span> <span class="operator">=</span> mChoreographer.getFrameTime();</span><br><span class="line">            <span class="comment">// 计算当前时间与上次时间的差值</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">deltaMs</span> <span class="operator">=</span> currentMs - mLastAnimationMs;</span><br><span class="line">            mLastAnimationMs = currentMs;</span><br><span class="line">            <span class="comment">// 根据时间差计算本次跑动的距离，减轻视觉上跳动/卡顿</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">deltaPx</span> <span class="operator">=</span> deltaMs * mPixelsPerMs;</span><br><span class="line">            <span class="comment">// 计算跑动距离</span></span><br><span class="line">            mScroll += deltaPx;</span><br><span class="line">            <span class="comment">// 判断是否已经跑完</span></span><br><span class="line">            <span class="keyword">if</span> (mScroll &gt; mMaxScroll) &#123;</span><br><span class="line">                mScroll = mMaxScroll;</span><br><span class="line">                <span class="comment">// 发送重新开始跑动事件</span></span><br><span class="line">                mChoreographer.postFrameCallbackDelayed(mRestartCallback, MARQUEE_DELAY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 发送下一次跑动事件</span></span><br><span class="line">                mChoreographer.postFrameCallback(mTickCallback);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用此方法会触发执行`onDraw`方法</span></span><br><span class="line">            textView.invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止跑马灯</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        mStatus = MARQUEE_STOPPED;</span><br><span class="line">        mChoreographer.removeFrameCallback(mStartCallback);</span><br><span class="line">        mChoreographer.removeFrameCallback(mRestartCallback);</span><br><span class="line">        mChoreographer.removeFrameCallback(mTickCallback);</span><br><span class="line">        resetScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resetScroll</span><span class="params">()</span> &#123;</span><br><span class="line">        mScroll = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> mView.get();</span><br><span class="line">        <span class="keyword">if</span> (textView != <span class="literal">null</span>) textView.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动跑马灯</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> repeatLimit)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (repeatLimit == <span class="number">0</span>) &#123;</span><br><span class="line">            stop();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRepeatLimit = repeatLimit;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> mView.get();</span><br><span class="line">        <span class="keyword">if</span> (textView != <span class="literal">null</span> &amp;&amp; textView.mLayout != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置状态为在跑</span></span><br><span class="line">            mStatus = MARQUEE_STARTING;</span><br><span class="line">            <span class="comment">// 重置跑动距离</span></span><br><span class="line">            mScroll = <span class="number">0.0f</span>;</span><br><span class="line">            <span class="comment">// 计算TextView宽度</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">textWidth</span> <span class="operator">=</span> textView.getWidth() - textView.getCompoundPaddingLeft()</span><br><span class="line">                - textView.getCompoundPaddingRight();</span><br><span class="line">            <span class="comment">// 获取文本第0行的宽度</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span> <span class="variable">lineWidth</span> <span class="operator">=</span> textView.mLayout.getLineWidth(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 取TextView宽度的三分之一</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span> <span class="variable">gap</span> <span class="operator">=</span> textWidth / <span class="number">3.0f</span>;</span><br><span class="line">            <span class="comment">// 计算什么时候可以开始绘制尾部文本：首部文本跑动到哪里可以绘制尾部文本</span></span><br><span class="line">            mGhostStart = lineWidth - textWidth + gap;</span><br><span class="line">            <span class="comment">// 计算最大滚动距离：什么时候认为跑完一次</span></span><br><span class="line">            mMaxScroll = mGhostStart + textWidth;</span><br><span class="line">            <span class="comment">// 尾部文本绘制偏移量</span></span><br><span class="line">            mGhostOffset = lineWidth + gap;</span><br><span class="line">            <span class="comment">// 跑动到哪里时不绘制左侧阴影</span></span><br><span class="line">            mFadeStop = lineWidth + textWidth / <span class="number">6.0f</span>;</span><br><span class="line">            <span class="comment">// 跑动到哪里时不绘制右侧阴影</span></span><br><span class="line">            mMaxFadeScroll = mGhostStart + lineWidth + lineWidth;</span><br><span class="line"></span><br><span class="line">            textView.invalidate();</span><br><span class="line">            <span class="comment">// 开始跑动</span></span><br><span class="line">            mChoreographer.postFrameCallback(mStartCallback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取尾部文本绘制位置偏移量</span></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getGhostOffset</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mGhostOffset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前滚动距离</span></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getScroll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScroll;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取可以右侧阴影绘制的最大距离</span></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getMaxFadeScroll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mMaxFadeScroll;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否可以绘制左侧阴影</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldDrawLeftFade</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScroll &lt;= mFadeStop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否可以绘制尾部文本</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldDrawGhost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mStatus == MARQUEE_RUNNING &amp;&amp; mScroll &gt; mGhostStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跑马灯是否在跑</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mStatus == MARQUEE_RUNNING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跑马灯是否不跑</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isStopped</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mStatus == MARQUEE_STOPPED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，分析完 <code>Marquee</code>，跑马灯实现原理豁然明亮</p>
<ol>
<li>在 <code>TextView</code> 开启跑马灯效果时调用 <code>Marquee#start()</code> 方法</li>
<li>在 <code>Marquee#start()</code> 方法中触发 <code>TextView</code> 重绘，开始计算跑动距离</li>
<li>在 <code>TextView#onDraw()</code> 方法中根据跑动距离移动画布并绘制首部文本，再根据跑动距离判断是否可以移动画布绘制尾部文本</li>
</ol>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p><code>TextView</code> 通过移动画布绘制两次文本实现跑马灯效果，根据两帧绘制的时间差计算跑动距离，怎一个&quot;妙&quot;了得</p>
<h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2>
<p>上面分析完原生 <code>Android TextView</code> 跑马灯的实现原理，但是原生 <code>Android TextView</code> 跑马灯有几点不足：</p>
<ol>
<li>无法设置跑动速度</li>
<li>无法设置重跑间隔时长</li>
<li>无法实现上下跑动</li>
</ol>
<p>以上第1、2点在上面 <code>Marquee</code> 分析中已经有解决方案，接下来根据原生实现原理实现第3点上下跑动</p>
<h3 id="marqueetextview"><a class="markdownIt-Anchor" href="#marqueetextview"></a> MarqueeTextView</h3>
<p>这里给出实现方案，列出主要实现逻辑，继承 <code>AppCompatTextView</code>，复写 <code>onDraw()</code> 方法，上下跑动主要是计算上下跑动的距离，然后再次重绘 <code>TextView</code> 上下移动画布绘制文本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承AppCompatTextView，复写onDraw方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarqueeTextView</span> <span class="keyword">extends</span> <span class="title class_">AppCompatTextView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_BG_COLOR</span> <span class="operator">=</span> Color.parseColor(<span class="string">&quot;#FFEFEFEF&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IntDef(&#123;HORIZONTAL, VERTICAL&#125;)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> OrientationMode &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HORIZONTAL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VERTICAL</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Marquee mMarquee;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mRestartMarquee;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isMarquee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mOrientation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MarqueeTextView</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MarqueeTextView</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MarqueeTextView</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line"></span><br><span class="line">        <span class="type">TypedArray</span> <span class="variable">ta</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, R.styleable.MarqueeTextView, defStyleAttr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        mOrientation = ta.getInt(R.styleable.MarqueeTextView_orientation, HORIZONTAL);</span><br><span class="line"></span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onSizeChanged</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> oldw, <span class="type">int</span> oldh)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mOrientation == HORIZONTAL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getWidth() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mRestartMarquee = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getHeight() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mRestartMarquee = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">restartMarqueeIfNeeded</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRestartMarquee) &#123;</span><br><span class="line">            mRestartMarquee = <span class="literal">false</span>;</span><br><span class="line">            startMarquee();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMarquee</span><span class="params">(<span class="type">boolean</span> marquee)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasStart</span> <span class="operator">=</span> isMarquee();</span><br><span class="line"></span><br><span class="line">        isMarquee = marquee;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wasStart != marquee) &#123;</span><br><span class="line">            <span class="keyword">if</span> (marquee) &#123;</span><br><span class="line">                startMarquee();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stopMarquee();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrientation</span><span class="params">(<span class="meta">@OrientationMode</span> <span class="type">int</span> orientation)</span> &#123;</span><br><span class="line">        mOrientation = orientation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrientation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOrientation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMarquee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isMarquee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopMarquee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == HORIZONTAL) &#123;</span><br><span class="line">            setHorizontalFadingEdgeEnabled(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setVerticalFadingEdgeEnabled(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        requestLayout();</span><br><span class="line">        invalidate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mMarquee != <span class="literal">null</span> &amp;&amp; !mMarquee.isStopped()) &#123;</span><br><span class="line">            mMarquee.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startMarquee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (canMarquee()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mOrientation == HORIZONTAL) &#123;</span><br><span class="line">                setHorizontalFadingEdgeEnabled(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setVerticalFadingEdgeEnabled(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mMarquee == <span class="literal">null</span>) mMarquee = <span class="keyword">new</span> <span class="title class_">Marquee</span>(<span class="built_in">this</span>);</span><br><span class="line">            mMarquee.start(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canMarquee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == HORIZONTAL) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">viewWidth</span> <span class="operator">=</span> getWidth() - getCompoundPaddingLeft() -</span><br><span class="line">                getCompoundPaddingRight();</span><br><span class="line">            <span class="type">float</span> <span class="variable">lineWidth</span> <span class="operator">=</span> getLayout().getLineWidth(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> (mMarquee == <span class="literal">null</span> || mMarquee.isStopped())</span><br><span class="line">                &amp;&amp; (isFocused() || isSelected() || isMarquee())</span><br><span class="line">                &amp;&amp; viewWidth &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; lineWidth &gt; viewWidth;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">viewHeight</span> <span class="operator">=</span> getHeight() - getCompoundPaddingTop() -</span><br><span class="line">                getCompoundPaddingBottom();</span><br><span class="line">            <span class="type">float</span> <span class="variable">textHeight</span> <span class="operator">=</span> getLayout().getHeight();</span><br><span class="line">            <span class="keyword">return</span> (mMarquee == <span class="literal">null</span> || mMarquee.isStopped())</span><br><span class="line">                &amp;&amp; (isFocused() || isSelected() || isMarquee())</span><br><span class="line">                &amp;&amp; viewHeight &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; textHeight &gt; viewHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仿照TextView#onDraw()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        restartMarqueeIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次绘制背景色，覆盖下面由TextView绘制的文本，视情况可以不调用`super.onDraw(canvas);`</span></span><br><span class="line">        <span class="comment">// 如果没有背景色则使用默认颜色</span></span><br><span class="line">        <span class="type">Drawable</span> <span class="variable">background</span> <span class="operator">=</span> getBackground();</span><br><span class="line">        <span class="keyword">if</span> (background != <span class="literal">null</span>) &#123;</span><br><span class="line">            background.draw(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            canvas.drawColor(DEFAULT_BG_COLOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.save();</span><br><span class="line"></span><br><span class="line">        canvas.translate(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现左右跑马灯</span></span><br><span class="line">        <span class="keyword">if</span> (mOrientation == HORIZONTAL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mMarquee != <span class="literal">null</span> &amp;&amp; mMarquee.isRunning()) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">float</span> <span class="variable">dx</span> <span class="operator">=</span> -mMarquee.getScroll();</span><br><span class="line">                canvas.translate(dx, <span class="number">0.0F</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            getLayout().draw(canvas, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mMarquee != <span class="literal">null</span> &amp;&amp; mMarquee.shouldDrawGhost()) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">float</span> <span class="variable">dx</span> <span class="operator">=</span> mMarquee.getGhostOffset();</span><br><span class="line">                canvas.translate(dx, <span class="number">0.0F</span>);</span><br><span class="line">                getLayout().draw(canvas, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 实现上下跑马灯</span></span><br><span class="line">            <span class="keyword">if</span> (mMarquee != <span class="literal">null</span> &amp;&amp; mMarquee.isRunning()) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">float</span> <span class="variable">dy</span> <span class="operator">=</span> -mMarquee.getScroll();</span><br><span class="line">                canvas.translate(<span class="number">0.0F</span>, dy);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            getLayout().draw(canvas, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mMarquee != <span class="literal">null</span> &amp;&amp; mMarquee.shouldDrawGhost()) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">float</span> <span class="variable">dy</span> <span class="operator">=</span> mMarquee.getGhostOffset();</span><br><span class="line">                canvas.translate(<span class="number">0.0F</span>, dy);</span><br><span class="line">                getLayout().draw(canvas, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="marquee-2"><a class="markdownIt-Anchor" href="#marquee-2"></a> Marquee</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Marquee</span> &#123;</span><br><span class="line">    <span class="comment">// 修改此字段设置重跑时间间隔 - 对应不足点2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MARQUEE_DELAY</span> <span class="operator">=</span> <span class="number">1200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改此字段设置跑动速度 - 对应不足点1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MARQUEE_DP_PER_SECOND</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">MARQUEE_STOPPED</span> <span class="operator">=</span> <span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">MARQUEE_STARTING</span> <span class="operator">=</span> <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">MARQUEE_RUNNING</span> <span class="operator">=</span> <span class="number">0x2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">METHOD_GET_FRAME_TIME</span> <span class="operator">=</span> <span class="string">&quot;getFrameTime&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MarqueeTextView&gt; mView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Choreographer mChoreographer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> <span class="variable">mStatus</span> <span class="operator">=</span> MARQUEE_STOPPED;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> mPixelsPerSecond;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mMaxScroll;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mMaxFadeScroll;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mGhostStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mGhostOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mFadeStop;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mRepeatLimit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mScroll;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mLastAnimationMs;</span><br><span class="line"></span><br><span class="line">    Marquee(MarqueeTextView v) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">density</span> <span class="operator">=</span> v.getContext().getResources().getDisplayMetrics().density;</span><br><span class="line">        mPixelsPerSecond = MARQUEE_DP_PER_SECOND * density;</span><br><span class="line">        mView = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(v);</span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Choreographer.<span class="type">FrameCallback</span> <span class="variable">mTickCallback</span> <span class="operator">=</span> frameTimeNanos -&gt; tick();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Choreographer.<span class="type">FrameCallback</span> <span class="variable">mStartCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>.FrameCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">            mStatus = MARQUEE_RUNNING;</span><br><span class="line">            mLastAnimationMs = getFrameTime();</span><br><span class="line">            tick();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * `getFrameTime`是隐藏api，此处使用反射调用，高系统版本可能失效，可使用某些方案绕过此限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;PrivateApi&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getFrameTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Choreographer</span>&gt; clz = mChoreographer.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">getFrameTime</span> <span class="operator">=</span> clz.getDeclaredMethod(METHOD_GET_FRAME_TIME);</span><br><span class="line">            getFrameTime.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>) getFrameTime.invoke(mChoreographer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Choreographer.<span class="type">FrameCallback</span> <span class="variable">mRestartCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>.FrameCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mStatus == MARQUEE_RUNNING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRepeatLimit &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    mRepeatLimit--;</span><br><span class="line">                &#125;</span><br><span class="line">                start(mRepeatLimit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tick</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStatus != MARQUEE_RUNNING) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mChoreographer.removeFrameCallback(mTickCallback);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">MarqueeTextView</span> <span class="variable">textView</span> <span class="operator">=</span> mView.get();</span><br><span class="line">        <span class="keyword">if</span> (textView != <span class="literal">null</span> &amp;&amp; (textView.isFocused() || textView.isSelected() || textView.isMarquee())) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">currentMs</span> <span class="operator">=</span> getFrameTime();</span><br><span class="line">            <span class="type">long</span> <span class="variable">deltaMs</span> <span class="operator">=</span> currentMs - mLastAnimationMs;</span><br><span class="line">            mLastAnimationMs = currentMs;</span><br><span class="line">            <span class="type">float</span> <span class="variable">deltaPx</span> <span class="operator">=</span> deltaMs / <span class="number">1000F</span> * mPixelsPerSecond;</span><br><span class="line">            mScroll += deltaPx;</span><br><span class="line">            <span class="keyword">if</span> (mScroll &gt; mMaxScroll) &#123;</span><br><span class="line">                mScroll = mMaxScroll;</span><br><span class="line">                mChoreographer.postFrameCallbackDelayed(mRestartCallback, MARQUEE_DELAY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mChoreographer.postFrameCallback(mTickCallback);</span><br><span class="line">            &#125;</span><br><span class="line">            textView.invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        mStatus = MARQUEE_STOPPED;</span><br><span class="line">        mChoreographer.removeFrameCallback(mStartCallback);</span><br><span class="line">        mChoreographer.removeFrameCallback(mRestartCallback);</span><br><span class="line">        mChoreographer.removeFrameCallback(mTickCallback);</span><br><span class="line">        resetScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resetScroll</span><span class="params">()</span> &#123;</span><br><span class="line">        mScroll = <span class="number">0.0F</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">MarqueeTextView</span> <span class="variable">textView</span> <span class="operator">=</span> mView.get();</span><br><span class="line">        <span class="keyword">if</span> (textView != <span class="literal">null</span>) textView.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> repeatLimit)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (repeatLimit == <span class="number">0</span>) &#123;</span><br><span class="line">            stop();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRepeatLimit = repeatLimit;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">MarqueeTextView</span> <span class="variable">textView</span> <span class="operator">=</span> mView.get();</span><br><span class="line">        <span class="keyword">if</span> (textView != <span class="literal">null</span> &amp;&amp; textView.getLayout() != <span class="literal">null</span>) &#123;</span><br><span class="line">            mStatus = MARQUEE_STARTING;</span><br><span class="line">            mScroll = <span class="number">0.0F</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分别计算左右和上下跑动所需的数据</span></span><br><span class="line">            <span class="keyword">if</span> (textView.getOrientation() == HORIZONTAL) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">viewWidth</span> <span class="operator">=</span> textView.getWidth() - textView.getCompoundPaddingLeft() -</span><br><span class="line">                    textView.getCompoundPaddingRight();</span><br><span class="line">                <span class="type">float</span> <span class="variable">lineWidth</span> <span class="operator">=</span> textView.getLayout().getLineWidth(<span class="number">0</span>);</span><br><span class="line">                <span class="type">float</span> <span class="variable">gap</span> <span class="operator">=</span> viewWidth / <span class="number">3.0F</span>;</span><br><span class="line">                mGhostStart = lineWidth - viewWidth + gap;</span><br><span class="line">                mMaxScroll = mGhostStart + viewWidth;</span><br><span class="line">                mGhostOffset = lineWidth + gap;</span><br><span class="line">                mFadeStop = lineWidth + viewWidth / <span class="number">6.0F</span>;</span><br><span class="line">                mMaxFadeScroll = mGhostStart + lineWidth + lineWidth;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">viewHeight</span> <span class="operator">=</span> textView.getHeight() - textView.getCompoundPaddingTop() -</span><br><span class="line">                    textView.getCompoundPaddingBottom();</span><br><span class="line">                <span class="type">float</span> <span class="variable">textHeight</span> <span class="operator">=</span> textView.getLayout().getHeight();</span><br><span class="line">                <span class="type">float</span> <span class="variable">gap</span> <span class="operator">=</span> viewHeight / <span class="number">3.0F</span>;</span><br><span class="line">                mGhostStart = textHeight - viewHeight + gap;</span><br><span class="line">                mMaxScroll = mGhostStart + viewHeight;</span><br><span class="line">                mGhostOffset = textHeight + gap;</span><br><span class="line">                mFadeStop = textHeight + viewHeight / <span class="number">6.0F</span>;</span><br><span class="line">                mMaxFadeScroll = mGhostStart + textHeight + textHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            textView.invalidate();</span><br><span class="line">            mChoreographer.postFrameCallback(mStartCallback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getGhostOffset</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mGhostOffset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getScroll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScroll;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getMaxFadeScroll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mMaxFadeScroll;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldDrawLeftFade</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScroll &lt;= mFadeStop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldDrawTopFade</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScroll &lt;= mFadeStop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldDrawGhost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mStatus == MARQUEE_RUNNING &amp;&amp; mScroll &gt; mGhostStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mStatus == MARQUEE_RUNNING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isStopped</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mStatus == MARQUEE_STOPPED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h3>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205051857334.png" alt="跑马灯" /></p>
<p>happy~</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>跑马灯</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-EventBus修改纪实(四)-注解处理器</title>
    <url>/2022/06/04/Android/Android-EventBus%E4%BF%AE%E6%94%B9%E7%BA%AA%E5%AE%9E(%E5%9B%9B)-%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="android-eventbus修改纪实四-注解处理器"><a class="markdownIt-Anchor" href="#android-eventbus修改纪实四-注解处理器"></a> Android-EventBus修改纪实(四)-注解处理器</h1>
<p>持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第 6 天，<a href="https://juejin.cn/post/7099702781094674468">点击查看活动详情</a></p>
<hr />
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>本文是 EventBus 修改纪实的第四篇，笔者在写第一篇文章时只是想记录下修改 EventBus 的过程，分享解决问题和查看源码的思路，没想到不知不觉会写这么多，“天下无不散之筵席”，本文将分析 EventBus 注解处理器的流程，也是 EventBus 修改纪实的最后一篇文章。</p>
<h2 id="纪实"><a class="markdownIt-Anchor" href="#纪实"></a> 纪实</h2>
<p>EventBus 的注解处理器程序只有一个类 <code>EventBusAnnotationProcessor</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes(&quot;com.yarward.org.greenrobot.eventbus.Subscribe&quot;)</span></span><br><span class="line"><span class="meta">@SupportedOptions(value = &#123;&quot;eventBusIndex&quot;, &quot;verbose&quot;&#125;)</span></span><br><span class="line"><span class="meta">@IncrementalAnnotationProcessor(AGGREGATING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusAnnotationProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EventBusAnnotationProcessor</code> 上有三个注解，下面一一介绍：</p>
<ul>
<li><code>@SupportedAnnotationTypes</code> 注解标识该注解处理器只处理 <code>@Subscribe</code> 注解，</li>
<li><code>@SupportedOptions</code> 注解标识改注解处理器可以有两个参数，<code>eventBusIndex</code> 标识要生成 Index 类的全量限定名称，<code>verbose</code> 主要用于日志输出</li>
<li><code>@IncrementalAnnotationProcessor</code> 注解方便构建增量注解处理器</li>
</ul>
<h3 id="process"><a class="markdownIt-Anchor" href="#process"></a> process</h3>
<p>接下来分析处理流程，处理流程主要在 <code>process</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OPTION_EVENT_BUS_INDEX</span> <span class="operator">=</span> <span class="string">&quot;eventBusIndex&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OPTION_VERBOSE</span> <span class="operator">=</span> <span class="string">&quot;verbose&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// annotations 是 `@Subscribe` 注解集合</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取日志输出器</span></span><br><span class="line">    <span class="type">Messager</span> <span class="variable">messager</span> <span class="operator">=</span> processingEnv.getMessager();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 `eventBusIndex` 参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="literal">null</span>) &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;No option &quot;</span> + OPTION_EVENT_BUS_INDEX +</span><br><span class="line">                                  <span class="string">&quot; passed to annotation processor&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取 `verbose` 参数</span></span><br><span class="line">        verbose = Boolean.parseBoolean(processingEnv.getOptions().get(OPTION_VERBOSE));</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastPeriod</span> <span class="operator">=</span> index.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="comment">// 获取 eventBusIndex 的包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">indexPackage</span> <span class="operator">=</span> lastPeriod != -<span class="number">1</span> ? index.substring(<span class="number">0</span>, lastPeriod) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        round++;</span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;Processing round &quot;</span> + round + <span class="string">&quot;, new annotations: &quot;</span> +</span><br><span class="line">                                  !annotations.isEmpty() + <span class="string">&quot;, processingOver: &quot;</span> + env.processingOver());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (env.processingOver()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!annotations.isEmpty()) &#123;</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.ERROR,</span><br><span class="line">                                      <span class="string">&quot;Unexpected processing state: annotations still available after processing over&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (annotations.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (writerRoundDone) &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.ERROR,</span><br><span class="line">                                  <span class="string">&quot;Unexpected processing state: annotations still available after writing.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 收集订阅者和订阅方法</span></span><br><span class="line">        collectSubscribers(annotations, env, messager);</span><br><span class="line">        <span class="comment">// 检查是否可以为订阅者生成 Index</span></span><br><span class="line">        checkForSubscribersToSkip(messager, indexPackage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!methodsByClass.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 生成 Index 文件</span></span><br><span class="line">            createInfoIndexFile(index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.WARNING, <span class="string">&quot;No @Subscribe annotations found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writerRoundDone = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// IntelliJ does not handle exceptions nicely, so log and print a message</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;Unexpected error in EventBusAnnotationProcessor: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="collectsubscribers"><a class="markdownIt-Anchor" href="#collectsubscribers"></a> collectSubscribers</h3>
<p>我们首先分析是如何收集订阅者和订阅方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义集合，实际上是 Map&lt;TypeElement, List&lt;ExecutableElement&gt;&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ListMap&lt;TypeElement, ExecutableElement&gt; methodsByClass = <span class="keyword">new</span> <span class="title class_">ListMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// annotations 是 `@Subscribe ` 注解集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">collectSubscribers</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env, Messager messager)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历 `@Subscribe` 注解集合</span></span><br><span class="line">    <span class="keyword">for</span> (TypeElement annotation : annotations) &#123;</span><br><span class="line">        <span class="comment">// 获取有 `@Subscribe` 注解的元素集合</span></span><br><span class="line">        Set&lt;? <span class="keyword">extends</span> <span class="title class_">Element</span>&gt; elements = env.getElementsAnnotatedWith(annotation);</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            <span class="comment">// 判断是不是可执行的元素，一般表示是 Java 方法</span></span><br><span class="line">            <span class="keyword">if</span> (element <span class="keyword">instanceof</span> ExecutableElement) &#123;</span><br><span class="line">                <span class="type">ExecutableElement</span> <span class="variable">method</span> <span class="operator">=</span> (ExecutableElement) element;</span><br><span class="line">                <span class="comment">// 检查是否是订阅方法</span></span><br><span class="line">                <span class="keyword">if</span> (checkHasNoErrors(method, messager)) &#123;</span><br><span class="line">                    <span class="type">TypeElement</span> <span class="variable">classElement</span> <span class="operator">=</span> (TypeElement) method.getEnclosingElement();</span><br><span class="line">                    <span class="comment">// 添加进 Map 集合</span></span><br><span class="line">                    methodsByClass.putElement(classElement, method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;@Subscribe is only valid for methods&quot;</span>, element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先遍历 <code>@Subscribe</code> 注解集合，通过 <code>getElementsAnnotatedWith</code> 获取有 <code>@Subscribe</code> 注解的元素集合，然后遍历元素集合，在遍历元素集合时判断元素是否是 <code>ExecutableElement</code>，即当前元素是不是方法，如何是方法再通过 <code>checkHasNoErrors</code> 检查此方法是否符合订阅方法的规范：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkHasNoErrors</span><span class="params">(ExecutableElement element, Messager messager)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否是静态方法</span></span><br><span class="line">    <span class="keyword">if</span> (element.getModifiers().contains(Modifier.STATIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;Subscriber method must not be static&quot;</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是公开方法</span></span><br><span class="line">    <span class="keyword">if</span> (!element.getModifiers().contains(Modifier.PUBLIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;Subscriber method must be public&quot;</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否只有一个入参</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">VariableElement</span>&gt; parameters = ((ExecutableElement) element).getParameters();</span><br><span class="line">    <span class="keyword">if</span> (parameters.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;Subscriber method must have exactly 1 parameter&quot;</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查方法比较简单，需要满足以下条件：</p>
<ul>
<li>必须不能是静态方法</li>
<li>必须是公开方法</li>
<li>方法有且仅有一个入参</li>
</ul>
<p><strong>注意这里没有判断是否是桥接方法和合成方法，因为注解处理器处于编译期，桥接方法和合成方法应该经过 javac 编译后才会有。</strong></p>
<p>最后把符合订阅方法规范的方法收集起来，存储在 <code>methodsByClass</code> 中，<code>methodsByClass</code> 是 greenrobot 自定义的，其实际类型是 <code>Map&lt;TypeElement, List&lt;ExecutableElement&gt;&gt;</code>，以订阅者为 Key，订阅者中的订阅方法集合为 Value。</p>
<h3 id="checkforsubscriberstoskip"><a class="markdownIt-Anchor" href="#checkforsubscriberstoskip"></a> checkForSubscribersToSkip</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkForSubscribersToSkip</span><span class="params">(Messager messager, String myPackage)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历 订阅者</span></span><br><span class="line">    <span class="keyword">for</span> (TypeElement skipCandidate : methodsByClass.keySet()) &#123;</span><br><span class="line">        <span class="type">TypeElement</span> <span class="variable">subscriberClass</span> <span class="operator">=</span> skipCandidate;</span><br><span class="line">        <span class="comment">// 循环判断订阅者及其父类</span></span><br><span class="line">        <span class="keyword">while</span> (subscriberClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断订阅者是否可见</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisible(myPackage, subscriberClass)) &#123;</span><br><span class="line">                <span class="comment">// 若不可见，则添加进跳过订阅者集合，退出 while 循环</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">added</span> <span class="operator">=</span> classesToSkip.add(skipCandidate);</span><br><span class="line">                <span class="keyword">if</span> (added) &#123;</span><br><span class="line">                    String msg;</span><br><span class="line">                    <span class="keyword">if</span> (subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                        msg = <span class="string">&quot;Falling back to reflection because class is not public&quot;</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        msg = <span class="string">&quot;Falling back to reflection because &quot;</span> + skipCandidate +</span><br><span class="line">                            <span class="string">&quot; has a non-public super class&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取订阅者中的订阅方法集合</span></span><br><span class="line">            List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberClass);</span><br><span class="line">            <span class="keyword">if</span> (methods != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环判断是否根据订阅方法跳过订阅者</span></span><br><span class="line">                <span class="keyword">for</span> (ExecutableElement method : methods) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">skipReason</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">VariableElement</span> <span class="variable">param</span> <span class="operator">=</span> method.getParameters().get(<span class="number">0</span>);</span><br><span class="line">                    <span class="type">TypeMirror</span> <span class="variable">typeMirror</span> <span class="operator">=</span> getParamTypeMirror(param, messager);</span><br><span class="line">                    <span class="comment">// 判断订阅方法的入参是否是声明类型，即不是基本类型；或者是声明类型但不是类或接口</span></span><br><span class="line">                    <span class="keyword">if</span> (!(typeMirror <span class="keyword">instanceof</span> DeclaredType) ||</span><br><span class="line">                        !(((DeclaredType) typeMirror).asElement() <span class="keyword">instanceof</span> TypeElement)) &#123;</span><br><span class="line">                        skipReason = <span class="string">&quot;event type cannot be processed&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (skipReason == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">TypeElement</span> <span class="variable">eventTypeElement</span> <span class="operator">=</span> (TypeElement) ((DeclaredType) typeMirror).asElement();</span><br><span class="line">                        <span class="comment">// 判断 Event 是否可见</span></span><br><span class="line">                        <span class="keyword">if</span> (!isVisible(myPackage, eventTypeElement)) &#123;</span><br><span class="line">                            skipReason = <span class="string">&quot;event type is not public&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (skipReason != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 添加进跳过订阅者集合，退出 for 循环</span></span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">added</span> <span class="operator">=</span> classesToSkip.add(skipCandidate);</span><br><span class="line">                        <span class="keyword">if</span> (added) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Falling back to reflection because &quot;</span> + skipReason;</span><br><span class="line">                            <span class="keyword">if</span> (!subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                                msg += <span class="string">&quot; (found in super class for &quot;</span> + skipCandidate + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            messager.printMessage(Diagnostic.Kind.NOTE, msg, param);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移动至父类</span></span><br><span class="line">            subscriberClass = getSuperclass(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用 <code>isVisible</code> 方法判断订阅者是否可见：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isVisible</span><span class="params">(String myPackage, TypeElement typeElement)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取描述符集合</span></span><br><span class="line">    Set&lt;Modifier&gt; modifiers = typeElement.getModifiers();</span><br><span class="line">    <span class="type">boolean</span> visible;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否是 PUBLIC</span></span><br><span class="line">    <span class="keyword">if</span> (modifiers.contains(Modifier.PUBLIC)) &#123;</span><br><span class="line">        visible = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 判断是否是 PRIVATE 或者 PROTECTED</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modifiers.contains(Modifier.PRIVATE) || modifiers.contains(Modifier.PROTECTED)) &#123;</span><br><span class="line">        visible = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他情况</span></span><br><span class="line">        <span class="comment">// 获取元素的包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subscriberPackage</span> <span class="operator">=</span> getPackageElement(typeElement).getQualifiedName().toString();</span><br><span class="line">        <span class="comment">// 若 Index 类包名为空，则根据元素包名的长度判断，否则比较 Index 类和元素是否在同一个包下</span></span><br><span class="line">        <span class="keyword">if</span> (myPackage == <span class="literal">null</span>) &#123;</span><br><span class="line">            visible = subscriberPackage.length() == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            visible = myPackage.equals(subscriberPackage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果订阅者符合以下条件即认为可见：</p>
<ul>
<li>订阅者含有 public 修饰符</li>
<li>Index 类包名为空时，订阅者包名长度为 0，</li>
<li>Index 类包名不为空，订阅者和 Index 类同属一个包下</li>
</ul>
<p>如果订阅者不符合可见性条件，则添加进 <code>classesToSkip</code> 集合，后续生成 Index 类时会忽略此这些订阅者。</p>
<p>如果订阅者符合可见性条件，接下来判断订阅方法是否符合规范：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ExecutableElement method : methods) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">skipReason</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">VariableElement</span> <span class="variable">param</span> <span class="operator">=</span> method.getParameters().get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">TypeMirror</span> <span class="variable">typeMirror</span> <span class="operator">=</span> getParamTypeMirror(param, messager);</span><br><span class="line">    <span class="comment">// 判断订阅方法的入参是否是声明类型，即不是基本类型；或者是声明类型但不是类或接口</span></span><br><span class="line">    <span class="keyword">if</span> (!(typeMirror <span class="keyword">instanceof</span> DeclaredType) ||</span><br><span class="line">        !(((DeclaredType) typeMirror).asElement() <span class="keyword">instanceof</span> TypeElement)) &#123;</span><br><span class="line">        skipReason = <span class="string">&quot;event type cannot be processed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (skipReason == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TypeElement</span> <span class="variable">eventTypeElement</span> <span class="operator">=</span> (TypeElement) ((DeclaredType) typeMirror).asElement();</span><br><span class="line">        <span class="comment">// 判断 Event 是否可见</span></span><br><span class="line">        <span class="keyword">if</span> (!isVisible(myPackage, eventTypeElement)) &#123;</span><br><span class="line">            skipReason = <span class="string">&quot;event type is not public&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (skipReason != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 添加进跳过订阅者集合，退出 for 循环</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">added</span> <span class="operator">=</span> classesToSkip.add(skipCandidate);</span><br><span class="line">        <span class="keyword">if</span> (added) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Falling back to reflection because &quot;</span> + skipReason;</span><br><span class="line">            <span class="keyword">if</span> (!subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                msg += <span class="string">&quot; (found in super class for &quot;</span> + skipCandidate + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.NOTE, msg, param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历订阅方法，判断订阅方法的入参如果不是声明类型，即不是基本类型；或者入参是声明类型但不是类或接口，则将订阅者添加进跳过订阅者集合并退出 for 循环，否则再判断入参是否可见，若是不可见，则将订阅者添加进跳过订阅者集合并退出 for 循环。</p>
<p>最后获取当前订阅者的父类，循环判断父类是否也符合以上规范，若是父类不符合以上规范，则将当前订阅者添加进跳过订阅者集合并退出 for 循环。</p>
<h3 id="createinfoindexfile"><a class="markdownIt-Anchor" href="#createinfoindexfile"></a> createInfoIndexFile</h3>
<p>收集和过滤完订阅者后，接下来就可以生成 Index 类了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createInfoIndexFile</span><span class="params">(String index)</span> &#123;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">JavaFileObject</span> <span class="variable">sourceFile</span> <span class="operator">=</span> processingEnv.getFiler().createSourceFile(index);</span><br><span class="line">        <span class="type">int</span> <span class="variable">period</span> <span class="operator">=</span> index.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">myPackage</span> <span class="operator">=</span> period &gt; <span class="number">0</span> ? index.substring(<span class="number">0</span>, period) : <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clazz</span> <span class="operator">=</span> index.substring(period + <span class="number">1</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(sourceFile.openWriter());</span><br><span class="line">        <span class="comment">// 包名不为空，写入包名</span></span><br><span class="line">        <span class="keyword">if</span> (myPackage != <span class="literal">null</span>) &#123;</span><br><span class="line">            writer.write(<span class="string">&quot;package &quot;</span> + myPackage + <span class="string">&quot;;\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 导包</span></span><br><span class="line">        writer.write(<span class="string">&quot;import com.yarward.org.greenrobot.eventbus.meta.SimpleSubscriberInfo;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import com.yarward.org.greenrobot.eventbus.meta.SubscriberMethodInfo;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import com.yarward.org.greenrobot.eventbus.meta.SubscriberInfo;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import com.yarward.org.greenrobot.eventbus.meta.SubscriberInfoIndex;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import com.yarward.org.greenrobot.eventbus.ThreadMode;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import java.util.HashMap;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import java.util.Map;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;/** This class is generated by EventBus, do not edit. */\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 类声明，实现 `SubscriberInfoIndex` 接口</span></span><br><span class="line">        writer.write(<span class="string">&quot;public class &quot;</span> + clazz + <span class="string">&quot; implements SubscriberInfoIndex &#123;\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 静态字段声明</span></span><br><span class="line">        writer.write(<span class="string">&quot;    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;\n\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 静态代码块</span></span><br><span class="line">        writer.write(<span class="string">&quot;    static &#123;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();\n\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入 Index</span></span><br><span class="line">        writeIndexLines(writer, myPackage);</span><br><span class="line">        writer.write(<span class="string">&quot;    &#125;\n\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">        writer.write(<span class="string">&quot;    private static void putIndex(SubscriberInfo info) &#123;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;    &#125;\n\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现 `SubscriberInfoIndex` 接口方法</span></span><br><span class="line">        writer.write(<span class="string">&quot;    @Override\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;        if (info != null) &#123;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;            return info;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;        &#125; else &#123;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;            return null;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;        &#125;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;    &#125;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Could not write source for &quot;</span> + index, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (writer != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">//Silent</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createInfoIndexFile</code> 方法比较简单，主要是模板代码，生成 Index 的逻辑主要在 <code>writeIndexLines</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeIndexLines</span><span class="params">(BufferedWriter writer, String myPackage)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 遍历订阅者</span></span><br><span class="line">    <span class="keyword">for</span> (TypeElement subscriberTypeElement : methodsByClass.keySet()) &#123;</span><br><span class="line">        <span class="comment">// 判断是否忽略当前订阅者</span></span><br><span class="line">        <span class="keyword">if</span> (classesToSkip.contains(subscriberTypeElement)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取订阅者类名，是内部类时包含外部类的类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subscriberClass</span> <span class="operator">=</span> getClassString(subscriberTypeElement, myPackage);</span><br><span class="line">        <span class="comment">// 再次判断订阅者是否可见</span></span><br><span class="line">        <span class="keyword">if</span> (isVisible(myPackage, subscriberTypeElement)) &#123;</span><br><span class="line">            writeLine(writer, <span class="number">2</span>,</span><br><span class="line">                      <span class="string">&quot;putIndex(new SimpleSubscriberInfo(&quot;</span> + subscriberClass + <span class="string">&quot;.class,&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;true,&quot;</span>, <span class="string">&quot;new SubscriberMethodInfo[] &#123;&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取当前订阅者中订阅方法集合</span></span><br><span class="line">            List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberTypeElement);</span><br><span class="line">            <span class="comment">// 生成订阅方法信息</span></span><br><span class="line">            writeCreateSubscriberMethods(writer, methods, <span class="string">&quot;new SubscriberMethodInfo&quot;</span>, myPackage);</span><br><span class="line">            writer.write(<span class="string">&quot;        &#125;));\n\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writer.write(<span class="string">&quot;        // Subscriber not visible to index: &quot;</span> + subscriberClass + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>writeIndexLines</code> 方法也比较简单，遍历之前收集的订阅者集合，首先判断是否忽略当前订阅者，随后获取订阅者类名，如果是内部类则包含外部类的类名，然后再次判断当前订阅者是否可见，如果可见则生成 <code>SimpleSubscriberInfo</code> 对象添加进 Index。</p>
<p><code>SimpleSubscriberInfo</code> 是 Index 元素，其构造方法有三个入参，第一个入参是：订阅者 Class 对象，第二个入参是：是否检查父类，默认为 true，第三个参数是：订阅方法信息数组。</p>
<p>接下来调用 <code>writeCreateSubscriberMethods</code> 方法生成订阅方法信息 <code>SubscriberMethodInfo</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeCreateSubscriberMethods</span><span class="params">(BufferedWriter writer, List&lt;ExecutableElement&gt; methods,</span></span><br><span class="line"><span class="params">                                          String callPrefix, String myPackage)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 遍历订阅方法集合</span></span><br><span class="line">    <span class="keyword">for</span> (ExecutableElement method : methods) &#123;</span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">VariableElement</span>&gt; parameters = method.getParameters();</span><br><span class="line">        <span class="type">TypeMirror</span> <span class="variable">paramType</span> <span class="operator">=</span> getParamTypeMirror(parameters.get(<span class="number">0</span>), <span class="literal">null</span>);</span><br><span class="line">        <span class="type">TypeElement</span> <span class="variable">paramElement</span> <span class="operator">=</span> (TypeElement) processingEnv.getTypeUtils().asElement(paramType);</span><br><span class="line">        <span class="comment">// 获取订阅方法名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getSimpleName().toString();</span><br><span class="line">        <span class="comment">// 获取 Event 事件 Class 对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">eventClass</span> <span class="operator">=</span> getClassString(paramElement, myPackage) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 `Subscribe` 注解</span></span><br><span class="line">        <span class="type">Subscribe</span> <span class="variable">subscribe</span> <span class="operator">=</span> method.getAnnotation(Subscribe.class);</span><br><span class="line">        List&lt;String&gt; parts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        parts.add(callPrefix + <span class="string">&quot;(\&quot;&quot;</span> + methodName + <span class="string">&quot;\&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">lineEnd</span> <span class="operator">=</span> <span class="string">&quot;),&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取 `Subscribe` 注解的参数，并根据参数生成 `SubscriberMethodInfo` 的入参</span></span><br><span class="line">        <span class="keyword">if</span> (subscribe.priority() == <span class="number">0</span> &amp;&amp; !subscribe.sticky()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subscribe.threadMode() == ThreadMode.POSTING) &#123;</span><br><span class="line">                parts.add(eventClass + lineEnd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parts.add(eventClass + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                parts.add(<span class="string">&quot;ThreadMode.&quot;</span> + subscribe.threadMode().name() + lineEnd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parts.add(eventClass + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            parts.add(<span class="string">&quot;ThreadMode.&quot;</span> + subscribe.threadMode().name() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            parts.add(subscribe.priority() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="comment">// 此处是笔者对必达事件的处理</span></span><br><span class="line">            <span class="comment">// begin - 添加必达事件</span></span><br><span class="line">            parts.add(subscribe.sticky() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            parts.add(subscribe.rendezvous() + lineEnd);</span><br><span class="line">            <span class="comment">// end - 添加必达事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        writeLine(writer, <span class="number">3</span>, parts.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[parts.size()]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;Indexed @Subscribe at &quot;</span> +</span><br><span class="line">                                                     method.getEnclosingElement().getSimpleName() + <span class="string">&quot;.&quot;</span> + methodName +</span><br><span class="line">                                                     <span class="string">&quot;(&quot;</span> + paramElement.getSimpleName() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历当前订阅者中所有的订阅方法，首先订阅方法的名称，入参 Event 事件的 Class 对象，然后获取 <code>@Subscribe</code> 注解的参数，并根据注解的参数生成 <code>SubscriberMethodInfo</code> 的入参，<strong>这里有笔者对必达事件的处理(注意：这里处理有Bug，不知读者有没有看出来呢？)</strong>，最后调用 <code>writeLine</code> 完整的生成 <code>SubscriberMethodInfo</code> 方法。</p>
<p>至此，EventBus 注解处理器的流程分析完毕，下面是生成的 Index 类示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusTestsIndex</span> <span class="keyword">implements</span> <span class="title class_">SubscriberInfoIndex</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> <span class="title class_">SimpleSubscriberInfo</span>(EventBusMainThreadTest.class, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">SubscriberMethodInfo</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SubscriberMethodInfo</span>(<span class="string">&quot;onEventMainThread&quot;</span>, String.class, ThreadMode.MAIN),</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putIndex</span><span class="params">(SubscriberInfo info)</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SubscriberInfo <span class="title function_">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line">        <span class="type">SubscriberInfo</span> <span class="variable">info</span> <span class="operator">=</span> SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ul>
<li>在第一篇 <a href="https://juejin.cn/post/7104107150678917133">Android-EventBus修改纪实</a> 文章中笔者记录了为 EventBus 增加 <strong>必达事件</strong> 的过程，</li>
<li>在第二篇 <a href="https://juejin.cn/post/7104536485428199437">Android-EventBus修改纪实(二)</a> 文章中笔者对第一篇文章中未实现的部分进行了补充，并简单介绍了 EventBus 提供的线程模型及使用注意事项，</li>
<li>在第三篇 <a href="https://juejin.cn/post/7104912340851621901">Android-EventBus修改纪实(三)</a> 文章中笔者详细分析了 EventBus 的线程调度过程及使用注意事项，</li>
<li>在第四篇文章中笔者详细分析了 EventBus 注解处理器生成 Index 类的流程，第一篇文章中添加 <strong>必达事件</strong> 时没有修改注解处理器，在本文中也进行了简单的描述。</li>
</ul>
<p>本文分析订阅者是否符合规范时，有一处根据订阅方法检查过滤订阅者，如果订阅者中有一个方法不符合规范，整个订阅者都要跳过，这里你认为是否合理呢？</p>
<p>大家求同存异，欢迎交流。</p>
<p>happy~，希望可以帮你更好的使用 EventBus</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>eventbus</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-WebView软键盘遮挡输入框优化纪实</title>
    <url>/2022/06/05/Android/Android-WebView%E8%BD%AF%E9%94%AE%E7%9B%98%E9%81%AE%E6%8C%A1%E8%BE%93%E5%85%A5%E6%A1%86%E4%BC%98%E5%8C%96%E7%BA%AA%E5%AE%9E/</url>
    <content><![CDATA[<h1 id="android-webview软键盘遮挡输入框优化纪实"><a class="markdownIt-Anchor" href="#android-webview软键盘遮挡输入框优化纪实"></a> Android-WebView软键盘遮挡输入框优化纪实</h1>
<p>持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第 7 天，<a href="https://juejin.cn/post/7099702781094674468">点击查看活动详情</a></p>
<hr />
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<p>笔者在使用 WebView 加载含有输入框的 H5 页面时，点击输入框后，输入框会被软键盘遮挡住，无法看到输入的内容，这很影响用户体验。</p>
<p>笔者想着这种业务场景比较常见，遂上网搜索一番，果不其然，有不少同志遇到这个问题，想来这个问题很好解决了。笔者一一尝试了同志们提供的解决方案，结果要不是没有作用，要不是效果不太满意，只好自己另辟蹊径了。</p>
<p><strong>注：在笔者的业务场景中，App是全屏的，即没有顶部的系统栏，也没有底部的导航栏，所以笔者的解决方案，可能不适用于其他场景。</strong></p>
<h2 id="纪实"><a class="markdownIt-Anchor" href="#纪实"></a> 纪实</h2>
<h3 id="方案"><a class="markdownIt-Anchor" href="#方案"></a> 方案</h3>
<p>好的，重新梳理下遇到的问题，目前的问题是：<strong>用户无法看到输入框里的内容</strong>，那么我们可以先让用户看到输入框里的内容。</p>
<p>笔者想到了第一种方案：**输入框被软键盘遮挡后，在软键盘输入时，可以在 H5 页面顶部实时显示输入框里的内容。**本方案解决了输入框被软键盘遮挡后看不到输入内容的问题，但是没有解决输入框被软键盘遮挡的问题，此方案一定程度上提升了用户体验，不过笔者认为本方案不是很完美，继续思考其他方案。</p>
<p>最后笔者想到了第二种方案，大体思路如下：</p>
<ol>
<li>笔者的业务场景，App是全屏的，所以整个 WebView 也是全屏的，</li>
<li>在点击 H5 页面的输入框时，H5 获取当前输入框左下角的 Y 坐标，然后把左下角的 Y 坐标通知到 Android 原生，</li>
<li>Android 原生获取软键盘顶部的 Y 坐标与输入框左下角的 Y 坐标进行比较，如果小于左下角的 Y 坐标，则认为此时输入框被软键盘遮挡，需要将 WebView 向上滚动相应的距离以显示出来输入框，否则判断 WebView 当前的滚动距离是否为 0，如果不为 0 则取当前距离的负值作为滚动距离，否则就不滚动。</li>
</ol>
<p>上述方案的文字描述可能比较绕，我们可以看下面的流程图跟上思路：</p>
<p><img data-src="https://guodongandroid.coding.net/p/typora/d/typora/git/raw/master/img/202206052140191.png" alt="image-20220605214012705" /></p>
<h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3>
<p>接下来笔者根据上面的方案二进行代码上的具体实现：</p>
<p>首先是获取输入框左下角的 Y 坐标，这一步如果让前端来实现的话，是比较容易的，不过笔者认为方案二是一种比较通用的解决方案，可以提取出来作为二方库来使用，如果让其他使用二方库项目组的前端同志也来实现一次的话就比较麻烦了，所以在这一步，笔者选择了在 Android 端注入 JS 的方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">ready</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;readystatechange&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> readyState = <span class="variable language_">document</span>.<span class="property">readyState</span>;</span><br><span class="line">    <span class="keyword">if</span> (readyState !== <span class="string">&quot;loading&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(readyState);</span><br><span class="line">        <span class="title function_">ready</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">ready</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ready</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMNodeInserted&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">webInput</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">webInput</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">webInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;input&quot;</span>) || [];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;input -&gt; &quot;</span> + input.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> type = value.<span class="title function_">getAttribute</span>(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type -&gt; &quot;</span> + type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type === <span class="literal">null</span></span><br><span class="line">            || type === <span class="string">&quot;number&quot;</span></span><br><span class="line">            || type === <span class="string">&quot;search&quot;</span></span><br><span class="line">            || type === <span class="string">&quot;password&quot;</span></span><br><span class="line">            || type === <span class="string">&quot;tel&quot;</span></span><br><span class="line">            || type === <span class="string">&quot;email&quot;</span></span><br><span class="line">            || type === <span class="string">&quot;url&quot;</span></span><br><span class="line">            || type === <span class="string">&quot;text&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">            value.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>, webInput2Android);</span><br><span class="line"></span><br><span class="line">            value.<span class="title function_">removeEventListener</span>(<span class="string">&quot;focus&quot;</span>, webInput2Android);</span><br><span class="line"></span><br><span class="line">            value.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, webInput2Android);</span><br><span class="line"></span><br><span class="line">            value.<span class="title function_">addEventListener</span>(<span class="string">&quot;focus&quot;</span>, webInput2Android);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">webInput2Android</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;webInput2Android&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> offset = <span class="title function_">getOffset</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">var</span> x = offset.<span class="property">x</span>;</span><br><span class="line">    <span class="keyword">var</span> y = offset.<span class="property">y</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x:y --&gt; &quot;</span> + x + <span class="string">&quot;:&quot;</span> + y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> width = <span class="variable language_">this</span>.<span class="property">offsetWidth</span>;</span><br><span class="line">    <span class="keyword">var</span> height = <span class="variable language_">this</span>.<span class="property">offsetHeight</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;w:h --&gt; &quot;</span> + width + <span class="string">&quot;:&quot;</span> + height);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send to Android</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getOffset</span> (el) &#123;</span><br><span class="line">    <span class="keyword">var</span> box = el.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">x</span>: box.<span class="property">left</span> + <span class="variable language_">window</span>.<span class="property">pageXOffset</span> - <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientLeft</span>,</span><br><span class="line">        <span class="attr">y</span>: box.<span class="property">top</span> + <span class="variable language_">window</span>.<span class="property">pageYOffset</span> - <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientTop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JS 中通过监听输入框的点击事件，在点击时获取输入框左上角的坐标和输入框的宽高，间接算出输入框左下角的坐标，然后通知到 Android 原生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> mActivityReference.get();</span><br><span class="line">    <span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> mWebViewReference.get();</span><br><span class="line">    <span class="keyword">if</span> (activity == <span class="literal">null</span> || webView == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JS 传入的输入框左下角 Y 坐标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> mWebInput.getBottom();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取软键盘顶部的 Y 坐标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">keyboardTop</span> <span class="operator">=</span> KeyboardHelper.getKeyboardTop(activity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// WebView 当前滚动的距离</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">scrollY</span> <span class="operator">=</span> webView.getScrollY();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断软键盘是否弹出</span></span><br><span class="line">    <span class="keyword">if</span> (keyboardTop != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断输入框是否被软键盘遮挡</span></span><br><span class="line">        <span class="keyword">if</span> (bottom &gt;= keyboardTop) &#123;</span><br><span class="line">            <span class="comment">// 计算滚动距离</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> bottom - keyboardTop - scrollY;</span><br><span class="line">            <span class="comment">// 滚动 WebView diff + mDistance 距离，mDistance 默认 50，</span></span><br><span class="line">            <span class="comment">// diff + mDistance：即软键盘距离输入框底部 50 距离 </span></span><br><span class="line">            webView.assistWebKeyboard(scrollY, diff + mDistance);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 WebView 是否有滚动</span></span><br><span class="line">            <span class="keyword">if</span> (scrollY != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 滚动 WebView</span></span><br><span class="line">                webView.assistWebKeyboard(scrollY, -scrollY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码实现方案二中第三步，首先获取 JS 传入的输入框左下角 Y 坐标，其次获取软键盘顶部的 Y 坐标，然后获取 WebView 当前滚动的距离，接下来根据软键盘顶部的 Y 坐标判断软键盘是否弹出，在软键盘弹出的情况下，判断输入框左下角 Y 坐标是否大于等于软键盘顶部 Y 坐标：</p>
<ol>
<li>如果大于等于，则认为输入框被软键盘遮挡，此时计算出 WebView 需要滚动多长的距离，输入框才能被显示出来，最后调用 <code>assistWebKeyboard</code> 方法滚动 WebView</li>
<li>如果小于，则认为输入框没有被软键盘遮挡，此时判定 WebView 之前是否有滚动，如果有滚动距离，则计算滚动距离为当前滚动距离的负值，最后调用 <code>assistWebKeyboard</code> 方法滚动 WebView</li>
</ol>
<p>至此完结。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本文提供了一种新的解决 WebView 输入框被软键盘遮挡的思路，不过这种思路也有它的局限性，目前来看仅适用于全屏的 WebView 中，后续笔者再想到其他方案时，另写一篇纪实续集吧。</p>
<p>期待与各位同志交流方案与思路😀</p>
<p>happy，希望可以帮到你~</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>webview</tag>
        <tag>软键盘</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-.git目录探秘</title>
    <url>/2022/07/19/Git/Git-.git%E7%9B%AE%E5%BD%95%E6%8E%A2%E7%A7%98/</url>
    <content><![CDATA[<h1 id="git-git目录探秘"><a class="markdownIt-Anchor" href="#git-git目录探秘"></a> Git-.git目录探秘</h1>
<hr />
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-第一篇</title>
    <url>/2022/07/19/Git/Git-%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="git-第一篇"><a class="markdownIt-Anchor" href="#git-第一篇"></a> Git-第一篇</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>Git学习系列文章本着重学Git目的，参考官方文档<a href="https://git-scm.com/book/zh/v2">Git - Book (git-scm.com)</a>及前人的经验，结合个人在使用Git过程中的一些感悟</p>
<p>本系列文章随心所欲，可能刚开始还有章可循，后续可能就记录在使用过程中遇到的问题及解决方案</p>
<h2 id="起步"><a class="markdownIt-Anchor" href="#起步"></a> 起步</h2>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程-Java内存模型(JMM)</title>
    <url>/2022/05/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B(JMM)/</url>
    <content><![CDATA[<h1 id="java并发编程-java内存模型jmm"><a class="markdownIt-Anchor" href="#java并发编程-java内存模型jmm"></a> Java并发编程-Java内存模型(JMM)</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>在上一章 <a href="https://juejin.cn/post/7098882471810301959">Java并发编程-Android的UI框架为什么是单线程的？</a> 中笔者介绍了并发编程线程安全「三大恶」：「可见性」、「原子性」以及「有序性」</p>
<p>广义上来说，并发编程问题笔者归纳为：是由于后续操作看不到前面操作的结果而引发的</p>
<p>首先「大恶-可见性」顾名思义，即线程B能否看见线程A对共享变量的操作结果</p>
<p>其次「二恶-原子性」CPU 指令/操作被中断/分割，广义上看笔者认为也是可见性问题，比如线程 A 修改共享变量 <code>x += 1</code> 时被中断，去执行线程 B <code>x = 40</code> ，线程 A 恢复执行时可能看不到 <code>x</code> 已经被修改为 40</p>
<p>最后「三恶-有序性」指的是程序按照代码的先后顺序执行，即先执行 <code>x = 40</code> ，后续读取 <code>x == 40</code> 一定为真，如果有各种优化导致指令重排序，后续读取 <code>x == 40</code> 时可能不为真</p>
<p>总而言之，并发编程的问题大部分都是「可见性」问题</p>
<h2 id="java内存模型jmm"><a class="markdownIt-Anchor" href="#java内存模型jmm"></a> Java内存模型(JMM)</h2>
<p>在上一章中笔者介绍了导致「可见性」的原因是缓存，导致「有序性」的原因是各种优化(编译时、处理器以及运行时)，首先笔者想到的是禁用缓存和禁止各种优化操作，在 Java 中如何禁用缓存和禁止各种优化呢？</p>
<h3 id="happens-before"><a class="markdownIt-Anchor" href="#happens-before"></a> Happens-Before</h3>
<p>Java 内存模型是通过各种操作来定义的<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，包括对变量的读 / 写操作，监视器锁的加锁和释放操作，以及线程的启动和合并操作。JMM 为程序中所有的操作定义了一个偏序关系<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，称之为 Happens-Before。要想保证执行操作 B 的线程看到操作 A 的结果（无论 A 和 B 是否在同一个线程中执行），那么在 A 和 B 之间必须满足 Happens-Before 关系。如果两个操作之间缺乏 Happens-Before 关系，那么 JVM 可以对它们任意的重排序。</p>
<p>Happens-Before 的规则包括：</p>
<h4 id="规则一程序顺序"><a class="markdownIt-Anchor" href="#规则一程序顺序"></a> 规则一：程序顺序</h4>
<p>这条规则比较符合我们的直觉，在单线程中代码的顺序即程序的执行顺序：<code>int x = 40</code> 将在 <code>int y = 41</code> 之前执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">41</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="规则二监视器锁"><a class="markdownIt-Anchor" href="#规则二监视器锁"></a> 规则二：监视器锁<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></h4>
<p>监视器锁即内置锁(synchronized)，在监视器锁上的解锁操作必须在同一个监视器锁的加锁操作之前执行，这条规则比较好理解，现实世界中的锁在关锁前必须处于打开状态</p>
<p><img data-src="https://guodongandroid.coding.net/p/typora/d/typora/git/raw/master/img/202205251421708.png" alt="image-20220525142109393" /></p>
<h4 id="规则三volatile-变量"><a class="markdownIt-Anchor" href="#规则三volatile-变量"></a> 规则三：volatile 变量<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></h4>
<p>对 volatile 变量的写入操作必须在对该变量的读取操作之前执行。</p>
<p>这条规则不大好理解，以下代码与文字摘自 <a href="https://www.infoq.cn/article/java-memory-model-4">深入理解Java内存模型（四）——volatile</a></p>
<blockquote>
<p>理解 volatile 特性的一个好方法是：把对 volatile 变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileFeaturesExample</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">vl</span> <span class="operator">=</span> <span class="number">0L</span>;  <span class="comment">// 使用 volatile 声明 64 位的 long 型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">        vl = l;   <span class="comment">// 单个 volatile 变量的写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndIncrement</span> <span class="params">()</span> &#123;</span><br><span class="line">        vl++;    <span class="comment">// 复合（多个）volatile 变量的读 / 写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vl;   <span class="comment">// 单个 volatile 变量的读</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileFeaturesExample</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">vl</span> <span class="operator">=</span> <span class="number">0L</span>;               <span class="comment">// 64 位的 long 型普通变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> l)</span> &#123;     <span class="comment">// 对单个的普通 变量的写用同一个监视器同步</span></span><br><span class="line">        vl = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndIncrement</span> <span class="params">()</span> &#123; <span class="comment">// 普通方法调用</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> get();           <span class="comment">// 调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>;                  <span class="comment">// 普通写操作</span></span><br><span class="line">        set(temp);                   <span class="comment">// 调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> vl; <span class="comment">// 对单个的普通变量的读用同一个监视器同步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面示例程序所示，对一个 volatile 变量的单个读 / 写操作，与对一个普通变量的读 / 写操作使用同一个监视器锁来同步，它们之间的执行效果相同。</p>
<p>从内存语义的角度来说，volatile 与监视器锁有相同的效果：volatile 写和监视器的释放有相同的内存语义；volatile 读与监视器的获取有相同的内存语义。</p>
<p>简而言之，volatile 变量自身具有下列特性：</p>
<ul>
<li>可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li>
<li>原子性：对任意单个 volatile 变量的读 / 写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li>
</ul>
<h4 id="规则四线程启动"><a class="markdownIt-Anchor" href="#规则四线程启动"></a> 规则四：线程启动</h4>
<p>在线程上对 Thread.start 的调用必须在该线程中执行任何操作之前执行。</p>
<p>这条规则比较好理解，即线程 A 启动操作先执行，然后再执行线程 A 内的操作，换言之，线程 A 启动前的操作结果对线程 A 中的操作可见，参考下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 线程中的操作, 可以看到线程启动前对共享变量的操作结果</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程启动前操作共享变量</span></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程启动</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<h4 id="规则五线程结束"><a class="markdownIt-Anchor" href="#规则五线程结束"></a> 规则五：线程结束</h4>
<p>线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从 Thread.join 中成功返回，或者在调用 Thread.isAlive 时返回 false。</p>
<p>这条规则也比较好理解，即线程结束前，线程内的任何操作都已经执行，换言之，线程结束后，线程内的操作结果对后续操作可见，参考下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 线程中的操作, 可以看到线程启动前对共享变量的操作结果</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程中操作共享变量</span></span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程启动前操作共享变量</span></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程启动</span></span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程join, 等待线程结束</span></span><br><span class="line">thread.join();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程中对共享变量的操作结果此处可见</span></span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure>
<h4 id="规则六线程中断"><a class="markdownIt-Anchor" href="#规则六线程中断"></a> 规则六：线程中断</h4>
<p>当一个线程在另一个线程上调用 interrupt 时，必须在被中断线程检测到 interrupt 调用之前执行（通过抛出 InterruptedException，或者调用 isInterrupted 和 interrupted）。</p>
<p>这条规则笔者不太理解，只是理解了表面意思即：线程 A 对线程 B interrupt 的调用，必须在线程 B 检测到中断事件之前执行。</p>
<h4 id="规则七终结器"><a class="markdownIt-Anchor" href="#规则七终结器"></a> 规则七：终结器</h4>
<p>对象的构造函数必须在启动该对象的终结器<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>之前完成。</p>
<p>这条规则好理解，可以理解为 Android Activity 的生命周期，这里说的构造函数与终结器就是对象的生命周期，调用终结器之前，对象必须已经初始化。</p>
<h4 id="规则八传递性"><a class="markdownIt-Anchor" href="#规则八传递性"></a> 规则八：传递性</h4>
<p>如果操作 A 在操作 B 之前执行，并且操作 B 在操作 C 之前执行，那么操作 A 必须在 操作 C 之前执行。</p>
<p>看到这条规则，笔者竟然首先想到了《秦时明月》中《白马非马》辩论：白马 == 传家宝，黑马 == 传家宝，传家宝 == 传家宝，白马 == 黑马；扯远了。</p>
<p>这条规则可以理解为大小关系，比如：a 大于 b，b 大于 c，那么 a 一定大于 c。</p>
<p>传递性规则可以与其他规则结合起来使用，达到意想不到的效果。</p>
<h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup></h4>
<p>上述规则虽然只满足偏序关系，但同步操作，如锁的获取与释放等操作，以及 volatile 变量的读取与写入操作，都满足全序关系。因此，在描述 Happens-Before 关系时，可以使用 “后续的锁获取操作” 和 “后续的 volatile 变量的读取操作” 等表达术语。</p>
<h3 id="final-域"><a class="markdownIt-Anchor" href="#final-域"></a> final 域</h3>
<p>在 Java 中，不管是在写类、写变量还是写方法时，大部分程序员可能都会忽视 <strong>final 关键字</strong> 的作用，从而导致一些不可预见的问题，在 Kotlin 中类和方法默认是 final 的，声明变量时建议使用 val 修饰而不是 var。</p>
<p>在 Java 中基于 final 关键字修饰的变量在多线程中也有不可变的特性，建议尽量优先考虑使用 final 来修饰变量。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Java 内存模型就是对 JVM 的一种规范，其中 Happens-Before 定义了与程序员相关的一些规则，可以理解为 Happens-Before 规则是底层对程序员暴露的一些接口，程序员正确的使用这些接口可以编写出正确的代码。</p>
<p>Happens-Before 规则可以说是强制规定了代码的一些执行顺序，同时表达出 <strong>后续操作可以看见前面一个操作的结果</strong></p>
<p>对 Java 内存模型的学习，有助于分析解决遇到的线程安全问题，理解线程安全问题出现的原因，以及重塑自己的编程思想。</p>
<p>笔者认为最重要的是重塑自己的编程思想，俗话说 “读书破万卷, 下笔如有神”，理解原理，掌握规则，重塑思想后，才能在编码时写出 “Bug”(狗头保命)。</p>
<p>Java 并发编程属实难，笔者水平有限，如有错误之处，还请不吝赐教。</p>
<h2 id="说明与参考文献"><a class="markdownIt-Anchor" href="#说明与参考文献"></a> 说明与参考文献</h2>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>《Java并发编程实战-第十六章》 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>偏序关系 π 是集合上的一种关系，具有反对称、自反和传递属性 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>显示锁与内置锁在加锁和解锁等操作上有相同的内存语义 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>原子变量与 volatile 变量在读/写操作上有相同的语义 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a href="http://ifeve.com/jmm-faq-volatile/">Java内存模型FAQ（十）volatile是干什么用的</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p><a href="https://www.infoq.cn/article/java-memory-model-4">深入理解Java内存模型（四）——volatile</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>即 finalize() 方法 <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程-发布与逸出</title>
    <url>/2022/07/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8F%91%E5%B8%83%E4%B8%8E%E9%80%B8%E5%87%BA/</url>
    <content><![CDATA[<h1 id="java并发编程-发布与逸出"><a class="markdownIt-Anchor" href="#java并发编程-发布与逸出"></a> Java并发编程-发布与逸出</h1>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Java 并发编程属实难，笔者水平有限，如有错误之处，还请不吝赐教。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程-Android的UI框架为什么是单线程的？</title>
    <url>/2022/05/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Android%E7%9A%84UI%E6%A1%86%E6%9E%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84/</url>
    <content><![CDATA[<h1 id="java并发编程-android的ui框架为什么是单线程的"><a class="markdownIt-Anchor" href="#java并发编程-android的ui框架为什么是单线程的"></a> Java并发编程-Android的UI框架为什么是单线程的？</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>众所周知，Android 会在 <code>ViewRootImpl</code> 中调用 <code>checkThread</code> 方法检测是否是在 UI 线程中更新 UI</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(Context context, Display display)</span> &#123;</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CalledFromWrongThreadException</span>(</span><br><span class="line">            <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么 Android 只能在 UI 线程中更新 UI，不能在子线程中更新 UI<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>？Android 为什么不使用多线程更新 UI呢？</p>
<h2 id="gui-框架为什么是单线程的"><a class="markdownIt-Anchor" href="#gui-框架为什么是单线程的"></a> GUI 框架为什么是单线程的<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></h2>
<blockquote>
<p>早期的 GUI 应用程序都是单线程的，并且 GUI 事件在 ”主事件循环“ 中进行处理。当前的 GUI 框架则使用了一种略有不同的模型：在该模型中创建一个专门事件分发线程（Event Dispatch Thread，EDT）来处理 GUI 事件</p>
</blockquote>
<blockquote>
<p>单线程的 GUI 框架并不仅限于在 Java 中，在 Qt、NexiStep、MacOS Cocoa、X Windows 以及其他环境中的 GUI 框架都是单线程的。许多人曾经尝试过编写多线程的 GUI 框架，但最终都由于静态条件和死锁导致的稳定性问题而又重新回到单线程的事件队列模型：采用一个专门的线程从队列中抽取事件，并将它们转发到应用程序定义的事件处理器。</p>
</blockquote>
<blockquote>
<p>在多线程的 GUI 框架中更容易发生死锁问题，其部分原因在于，在输入事件的处理过程中与 GUI 组件的面向对象模型之间会存在错误的交互。用户引发的动作将通过一种类似于 “气泡上升” 的方式从操作系统传递给应用程序：操作系统首先检测到一次鼠标点击，然后通过工具包将其转化为 “鼠标点击” 事件，该事件最终被转换为一个更高层事件（例如 “鼠标左键被按下” 事件）转发给应用程序的监听器。另一方面，应用程序引发的动作又会以 “气泡下沉” 的方式从应用程序返回给操作系统。例如，在应用程序中引发修改某个组件背景色的请求，该请求将被转发给某个特定的组件，并最终转发给操作系统进行绘制。因此，一方面这组操作将以完全相反的顺序来访问相同的 GUI 对象；另一方面又要确保每个对象都是线程安全的，从而导致不一致的锁定顺序，并引发死锁。</p>
</blockquote>
<blockquote>
<p>另一个在多线程 GUI 框架中导致死锁的原因就是 “模型 — 视图 — 控制 (MVC)” 这种设计模式的广泛应用。通过将用户的交互分解到模型、视图和控制等模块中，能极大的简化 GUI 应用程序的实现，但这却也进一步增加了出现不一致锁定顺序的风险。</p>
</blockquote>
<blockquote>
<p>单线程的 GUI 框架通过线程封闭机制来实现线程安全性。所有 GUI 对象，包括可视化组件和数据模型等，都只能在事件线程中访问。当然，这只是将确保线程安全性的一部分工作交给应用程序的开发人员来负责，他们必须确认这些对象被正确的封闭在事件线程中。</p>
</blockquote>
<p>从以上文档中不难发现，早期前辈们尝试过多线程的 GUI 框架，最终都以 “失败” 告终而又回归到单线程的事件队列模型</p>
<p>原因大致总结为：<strong>在多线程中操作 GUI 对象，会有线程安全问题</strong></p>
<h2 id="线程安全三大恶"><a class="markdownIt-Anchor" href="#线程安全三大恶"></a> 线程安全三大恶</h2>
<h3 id="何为线程安全性"><a class="markdownIt-Anchor" href="#何为线程安全性"></a> 何为线程安全性<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></h3>
<blockquote>
<p>要对线程安全性给出一个确切的定义是非常复杂的。定义越正式，就越复杂，不仅很难提供有实际意义的指导建议，而且也很难从直观上去理解。因此，下面给出了一些非正式的描述，看上去令人困惑。在互联网上可以搜到许多 “定义”，例如：</p>
<ul>
<li>可以在多个线程中调用，并且在线程之间不会出现错误的交互。</li>
<li>可以同时被多个线程调用，而调用者无需执行额外的动作。</li>
</ul>
<p>看看这些定义，难怪我们会对线程安全性感到困惑。它们听起来非常像 “如果某个类可以在多个线程中安全的使用，那么它就是一个线程安全的类”。对于这种说法，虽然没有太多的争议，但同样不会带来太多的帮助。我们如何区分线程安全的类以及非线程安全的类？进一步说，“安全” 的含义是什么？</p>
<p>在线程安全性的定义中，最核心的概念就是正确性。如果对线程安全性的定义是模糊的，那么就是因为缺乏对正确性的清晰定义。</p>
<p>正确性的含义是：某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（Postcondition）来描述对象操作的结果。由于我们通常不会编写详细的规范，那么如何知道这些类是否正确呢？我们无法知道，但这并不妨碍我们在确信 “类的代码能工作” 后使用它们。这种 “代码可信性” 非常接近于我们对正确性的理解，因此我们可以将单线程的正确性近似定义为 “所见即所知（we know it when we see it）”。在对 “正确性” 给出一个较为清晰的定义后，就可以定义线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。</p>
<p>由于单线程程序也可以看成是一个多线程程序，如果某个类在单线程环境中都不是正确的，那么它肯定不会是线程安全的。</p>
</blockquote>
<h3 id="大恶-可见性"><a class="markdownIt-Anchor" href="#大恶-可见性"></a> 大恶 - 可见性</h3>
<blockquote>
<p>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
</blockquote>
<p>在上个世纪的单核时代，所有的线程都在唯一的一颗 CPU 上执行，CPU 缓存与内存之间的就像两口子，你的就是我的，我的就是你的，不分彼此😂</p>
<p>因为只有一颗 CPU，也只有一个 CPU 缓存，所以一个线程花了大洋，对另一个线程来说，它一定能看到还剩多少大洋。例如在下面的图中，内存中一共有100大洋，如果线程A花了20大洋，线程B想再挥霍时，只能挥霍80大洋</p>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205171657411.png" alt="image-20220516195337629" /></p>
<p>一个线程对共享变量的修改，另外一个线程可以立刻看到，称为<strong>可见性</strong></p>
<p>在21世纪的多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存之间的事就不好掰扯了，就像古代的皇帝(内存)有后宫佳丽三千(CPU)，皇帝跟所有佳丽们说咱国库充足：白银100两，佳丽们都知道了国库有100两白银，皇后想花80两买面膜(操作 CPU-1 缓存)，贵妃想花70两买BB霜(操作 CPU-2 缓存)，过段时间皇帝一看(CPU 缓存同步到内存)，国库还有30两白银。例如在下面的图中，内存有100两白银，线程A花了80两，然后同步到内存，皇帝看了国库还有20两，线程B花了70两，然后同步到内存，国库变成30两了？啧啧，这国库白银越花越多😂</p>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205171657692.png" alt="image-20220516203133183" /></p>
<p><strong>这里想说明线程A对共享变量的操作对于线程B来说是不可见的</strong></p>
<p>接下来用一段代码来看一下可见性问题，下面代码<sup class="footnote-ref"><a href="#fn4" id="fnref4:1">[4:1]</a></sup>中说明了当多个线程在没有同步的情况下共享数据时出现的错误。在代码中，主线程和读线程都将访问共享变量 ready 和 number。主线程启动读线程，然后将 number 设为 45，并将 ready 设为 true。读线程一直循环直到发现 ready 的值变为 true，然后输出 number 的值。虽然程序看起来会输出 45，但事实上很可能输出 0，或者根本无法终止。这是因为在代码中没有使用足够的同步机制，因此无法保证主线程写入的 ready 值和 number 值对于读线程来说是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisibilityTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;number = &quot;</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        number = <span class="number">45</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二恶-原子性"><a class="markdownIt-Anchor" href="#二恶-原子性"></a> 二恶 - 原子性</h3>
<blockquote>
<p>与可见性类似，原子性也是一种复杂的属性，因为原子性中的错误也是会违背我们的直觉。</p>
</blockquote>
<p><strong>原子性：是指一个或多个指令(操作)在 CPU 执行过程中不被中断、不可分割的特性，这里强调在 CPU 指令(操作)的执行过程中，表示原子性是在 CPU 指令(操作)层面而不是语言层面</strong></p>
<p>下面介绍两种常见的原子性错误形式</p>
<h4 id="读取-修改-写入"><a class="markdownIt-Anchor" href="#读取-修改-写入"></a> 读取 - 修改 - 写入</h4>
<p>接下来用一段代码看一下 “读取 - 修改 - 写入” 问题，下面代码由 <code>Kotlin</code> 编写，在 <code>reduceCount</code> 方法中循环 100000 次执行 <code>count--</code> 操作，两个线程执行 <code>reduceCount</code> 方法，可以先想下程序运行后输出的 <code>count</code> 是多少？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> thread1 = thread &#123;</span><br><span class="line">        reduceCount()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> thread2 = thread &#123;</span><br><span class="line">        reduceCount()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;count = <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 20万</span></span><br><span class="line"><span class="keyword">var</span> count: <span class="built_in">Long</span> = <span class="number">200000L</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reduceCount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 循环10万次</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100000</span>) &#123;</span><br><span class="line">        count--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直观上感觉 <code>count</code> 应该是 0，但是程序输出的 <code>count</code> 是位于 0 至 100000 之间的随机数，这是为什么呢？</p>
<p>虽然递减操作 <code>count--</code> 是一种紧凑的语法，使其看上去只是一个操作，但这个操作并非原子的，因而它并不会作为一个不可分割的操作来执行。</p>
<p>实际上，它包含了三个独立的操作：</p>
<ul>
<li>读取 count 的值</li>
<li>将值加 1</li>
<li>然后将第二步计算结果写入 count</li>
</ul>
<p>对于上面的三个操作来说，count 的初始值为 200000，那么在某些情况下，两个线程读到的值都为 200000，接着执行递减操作，并且都将 count 的值设为 199999。这显然不是我们期望的结果。这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，这种情况称为：竞态条件 (Race Condition)</p>
<h4 id="先检查后执行"><a class="markdownIt-Anchor" href="#先检查后执行"></a> 先检查后执行</h4>
<p>先检查后执行是最常见的竞态条件类型，即通过一个可能失效的观测结果来决定下一步的动作。先检查后执行问题中常见的情况就是下面形式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// action</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面通过延迟初始化看一下 “先检查后执行” 问题，延迟初始化的目的是将对象的初始化操作推迟到实际使用时才进行，同时要确保只被初始化一次<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyInitRace</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">LazyInitRace</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> LazyInitRace <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先检查instace是否已经被初始化，如果已经初始化则返回现有的实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 否则将创建一个新的实例，返回一个实例引用</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazyInitRace</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyInitRace</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 LazyInitRace 中包含了一个竞态条件，它可能会破坏这个类的正确性。假定线程 A 和线程 B 同时执行 <code>getInstance</code>。线程 A 看到 instance 为空，因而创建一个新的 LazyInitRace 实例。线程 B 同样需要判断 instance 是否为空。此时的 instance 是否为空，要取决于不可预测的时序，包括线程的调度方式，以及线程 A 需要花多长时间来初始化 LazyInitRace 并设置 instance。如果当线程 B 检查时，instance 为空，那么在两次调用 <code>getInstance</code> 时可能会得到不同的结果，即使 <code>getInstance</code> 通常被认为是返回相同的实例。<sup class="footnote-ref"><a href="#fn3" id="fnref3:2">[3:2]</a></sup></p>
<p>例如在下图中，线程A 执行完 “检查” 阶段后做线程调度(切换)，线程 A 和线程 B 按图中序列执行，最终发现两个线程都创建了一个新的 LazyInitRace 实例，但这不是期望的结果。</p>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205171657294.png" alt="image-20220517165708450" /></p>
<h3 id="三恶-有序性"><a class="markdownIt-Anchor" href="#三恶-有序性"></a> 三恶 - 有序性</h3>
<p>在可见性章节中的示例代码中有一种情况：number 很可能输出 0，因为读线程可能看到了写入 ready 的值，但却没有看到之后写入 number 的值，这种现象被称为 “重排序 (Reordering)”。</p>
<blockquote>
<p>在没有同步的情况下，编译器、处理器以及运行时等都有可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得到正确的结论。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisibilityTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;number = &quot;</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        number = <span class="number">45</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有序性指的是程序按照代码的先后顺序执行</strong></p>
<p>下面再来个代码示例<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>来说明有序性问题，在程序 PossibleReordering 中说明了<sup class="footnote-ref"><a href="#fn5" id="fnref5:1">[5:1]</a></sup>，在没有正确同步的情况下，即使要推断最简单的并发程序的行为也很困难。很容易想象 PossibleReordering 是如何输出 (1, 0) 或 (0，1) 或 (1，1) 的：线程 A 可以在线程 B 开始之前就执行完成，线程 B 也可以在线程 A 开始之前执行完成，或者二者的操作交替进行。但奇怪的是，PossibleReordering 还可以输出 (0，0) 。由于每个线程中的各个操作之间不存在数据流依赖性，因此这些操作可以乱序执行。(即使这些操作按照顺序执行，但在将缓存刷新到主内存的不同时序中也可能出现这种情况，从线程 B 的角度看，线程 A 中的赋值操作可能以相反的次序执行。)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PossibleReordering</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            x = b;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            b = <span class="number">1</span>;</span><br><span class="line">            y = a;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        </span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;( &quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot; )&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图给出了一种可能由重排序导致的交替执行方式，在这种情况中会输出 (0，0) 。</p>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205171819633.png" alt="image-20220517181932852" /></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本文从多线程并发编程中的线程安全角度解读了 Android UI 框架为什么是单线程的，猜想 Android UI 框架设计人员也是汲取了前人多线程中线程安全问题，遂采取单线程的封闭机制来实现线程安全性。</p>
<h2 id="说明与参考文献"><a class="markdownIt-Anchor" href="#说明与参考文献"></a> 说明与参考文献</h2>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>在子线程中也能更新UI，这里不抬杠 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>摘自《Java并发编程实战-第九章》 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>摘自《Java并发编程实战-第二章》 <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a> <a href="#fnref3:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>摘自《Java并发编程实战-第三章》 <a href="#fnref4" class="footnote-backref">↩︎</a> <a href="#fnref4:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>摘自《Java并发编程实战-第十六章》 <a href="#fnref5" class="footnote-backref">↩︎</a> <a href="#fnref5:1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-KCP的应用-第一篇</title>
    <url>/2022/05/08/Kotlin/Kotlin-KCP%E7%9A%84%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="kotlin-kcp的应用-第一篇"><a class="markdownIt-Anchor" href="#kotlin-kcp的应用-第一篇"></a> Kotlin-KCP的应用-第一篇</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>KCP的应用计划分两篇，本文是第一篇</p>
<p>本文主要记录从发现问题到使用KCP解决问题的折腾过程，下一篇记录KCP的应用</p>
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<p><code>Kotlin</code> 号称百分百兼容 <code>Java</code> ，所以在 <code>Kotlin</code> 中一些修饰符，比如 <code>internal</code> ，在编译后放在纯 <code>Java</code> 的项目中使用(没有<code>Kotlin</code>环境)，<code>Java</code> 仍然可以访问被 <code>internal</code> 修饰的类、方法、字段等</p>
<p>在使用 <code>Kotlin</code> 开发过程中需要对外提供 <code>SDK</code> 包，在 <code>SDK</code> 中有一些 <code>API</code> 不想被外部调用，并且已经添加了 <code>internal</code> 修饰，但是受限于上诉问题且第三方使用 <code>SDK</code> 的环境不可控(不能要求第三方必须使用<code>Kotlin</code>)</p>
<p>带着问题Google一番，查到以下几个解决方案：</p>
<ol>
<li>使用 <code>JvmName</code> 注解设置一个不符合 <code>Java</code> 命名规则的标识符<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li>
<li>使用 <code>ˋˋ</code> 在 <code>Kotlin</code> 中把一个不合法的标识符强行合法化<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup></li>
<li>使用 <code>JvmSynthetic</code> 注解<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></li>
</ol>
<p>以上方案可以满足大部分需求，但是以上方案都不满足隐藏构造方法，可能会想什么情景下需要隐藏构造方法，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span>(<span class="keyword">internal</span> <span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">internal</span> <span class="keyword">val</span> b: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * non-public constructor for java</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">constructor</span>() : <span class="keyword">this</span>(-<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为此我还提了个Issue<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，期望官方把 <code>JvmSynthetic</code> 的作用域扩展到构造方法，不过官方好像没有打算实现😂</p>
<p>为解决隐藏构造方法，可以把构造方法私有化，对外暴露静态工厂方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span> <span class="keyword">private</span> <span class="keyword">constructor</span> (<span class="keyword">internal</span> <span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">internal</span> <span class="keyword">val</span> b: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * non-public constructor for java</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>() : <span class="keyword">this</span>(-<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newBuilder</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = Builder(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方案说完了，大家散了吧，散了吧~</p>
<p>开玩笑，开玩笑😛，必然要折腾一番</p>
<h2 id="折腾"><a class="markdownIt-Anchor" href="#折腾"></a> 折腾</h2>
<h3 id="探索jvmsynthetic实现原理"><a class="markdownIt-Anchor" href="#探索jvmsynthetic实现原理"></a> 探索<code>JvmSynthetic</code>实现原理</h3>
<p>先看下 <code>JvmSynthetic</code> 注解的注释文档</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Sets `ACC_SYNTHETIC` flag on the annotated target in the Java bytecode.</span><br><span class="line"> *</span><br><span class="line"> * Synthetic targets become inaccessible for Java sources at compile time while still being accessible for Kotlin sources.</span><br><span class="line"> * Marking target as synthetic is a binary compatible change, already compiled Java code will be able to access such target.</span><br><span class="line"> *</span><br><span class="line"> * This annotation is intended for *rare cases* when API designer needs to hide Kotlin-specific target from Java API</span><br><span class="line"> * while keeping it a part of Kotlin API so the resulting API is idiomatic for both languages.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>好家伙，实现原理都说了：在 <code>Java</code> 字节码中的注解目标上设置 <code>ACC_SYNTHETIC</code> 标识</p>
<p>此处涉及 <code>Java</code> 字节码知识点，<code>ACC_SYNTHETIC</code> 标识可以简单理解是 <code>Java</code> 隐藏的，非公开的一种修饰符，可以修饰类、方法、字段等<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<p>得看看 <code>Kotlin</code> 是如何设置 <code>ACC_SYNTHETIC</code> 标识的，打开 <a href="https://github.com/JetBrains/kotlin"><code>Github Kotlin</code> 仓库</a>，在仓库内搜索 <code>JvmSynthetic</code> 关键字 <a href="https://github.com/JetBrains/kotlin/search?q=JvmSynthetic">Search · JvmSynthetic (github.com)</a></p>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205081206919.png" alt="image-20220508120615028" /></p>
<p>在搜索结果中分析发现 <code>JVM_SYNTHETIC_ANNOTATION_FQ_NAME</code> 关联性较大，继续在仓库内搜索 <code>JVM_SYNTHETIC_ANNOTATION_FQ_NAME</code> 关键字 <a href="https://github.com/JetBrains/kotlin/search?q=JVM_SYNTHETIC_ANNOTATION_FQ_NAME">Search · JVM_SYNTHETIC_ANNOTATION_FQ_NAME (github.com)</a></p>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205081212412.png" alt="image-20220508121250275" /></p>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205081211833.png" alt="image-20220508121115651" /></p>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205081211011.png" alt="image-20220508121137580" /></p>
<p>在搜索结果中发现几个类名与代码生成相关，这里以 <a href="https://github.com/JetBrains/kotlin/blob/effd21d074fb07e64797aef4db624cae0decbf42/compiler/ir/backend.jvm/codegen/src/org/jetbrains/kotlin/backend/jvm/codegen/ClassCodegen.kt"><code>ClassCodegen.kt</code></a> 为例，附上相关代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Class的SynthAccessFlag</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IrClass.<span class="title">getSynthAccessFlag</span><span class="params">(languageVersionSettings: <span class="type">LanguageVersionSettings</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 如果有`JvmSynthetic`注解，返回`ACC_SYNTHETIC`标识</span></span><br><span class="line">    <span class="keyword">if</span> (hasAnnotation(JVM_SYNTHETIC_ANNOTATION_FQ_NAME))</span><br><span class="line">        <span class="keyword">return</span> Opcodes.ACC_SYNTHETIC</span><br><span class="line">    <span class="keyword">if</span> (origin == IrDeclarationOrigin.GENERATED_SAM_IMPLEMENTATION &amp;&amp;</span><br><span class="line">        languageVersionSettings.supportsFeature(LanguageFeature.SamWrapperClassesAreSynthetic)</span><br><span class="line">    )</span><br><span class="line">        <span class="keyword">return</span> Opcodes.ACC_SYNTHETIC</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字段的AccessFlag</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IrField.<span class="title">computeFieldFlags</span><span class="params">(context: <span class="type">JvmBackendContext</span>, languageVersionSettings: <span class="type">LanguageVersionSettings</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    origin.flags or visibility.flags or</span><br><span class="line">            (<span class="keyword">if</span> (isDeprecatedCallable(context) ||</span><br><span class="line">                correspondingPropertySymbol?.owner?.isDeprecatedCallable(context) == <span class="literal">true</span></span><br><span class="line">            ) Opcodes.ACC_DEPRECATED <span class="keyword">else</span> <span class="number">0</span>) or</span><br><span class="line">            (<span class="keyword">if</span> (isFinal) Opcodes.ACC_FINAL <span class="keyword">else</span> <span class="number">0</span>) or</span><br><span class="line">            (<span class="keyword">if</span> (isStatic) Opcodes.ACC_STATIC <span class="keyword">else</span> <span class="number">0</span>) or</span><br><span class="line">            (<span class="keyword">if</span> (hasAnnotation(VOLATILE_ANNOTATION_FQ_NAME)) Opcodes.ACC_VOLATILE <span class="keyword">else</span> <span class="number">0</span>) or</span><br><span class="line">            (<span class="keyword">if</span> (hasAnnotation(TRANSIENT_ANNOTATION_FQ_NAME)) Opcodes.ACC_TRANSIENT <span class="keyword">else</span> <span class="number">0</span>) or</span><br><span class="line">			<span class="comment">// 如果有`JvmSynthetic`注解，返回`ACC_SYNTHETIC`标识</span></span><br><span class="line">            (<span class="keyword">if</span> (hasAnnotation(JVM_SYNTHETIC_ANNOTATION_FQ_NAME) ||</span><br><span class="line">                isPrivateCompanionFieldInInterface(languageVersionSettings)</span><br><span class="line">            ) Opcodes.ACC_SYNTHETIC <span class="keyword">else</span> <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>上述源码中 <code>Opcodes</code> 是字节码操作库 <code>ASM</code> 中的类</p>
<p>猜想 <code>Kotlin</code> 编译器也是使用 <code>ASM</code> 编译生成/修改Class文件</p>
<p>🆗，知道了 <code>JvmSynthetic</code> 注解的实现原理，是不是可以仿照 <code>JvmSynthetic</code> 给构造方法也添加 <code>ACC_SYNTHETIC</code> 标识呢❓</p>
<p>首先想到的就是利用 AGP Transform 进行字节码修改</p>
<h3 id="agp-transform"><a class="markdownIt-Anchor" href="#agp-transform"></a> AGP Transform</h3>
<p>AGP Transform 的搭建、使用，网上有很多相关文章，此处不再描述，下图是本仓库的组织架构</p>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205081312860.png" alt="image-20220508131245185" /></p>
<p>这里简单说明下：</p>
<h4 id="api-xxx"><a class="markdownIt-Anchor" href="#api-xxx"></a> api-xxx</h4>
<p>api-xxx模块中只有一个注解类 <code>Hide</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Hide &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(</span></span><br><span class="line"><span class="meta">    AnnotationTarget.FIELD,</span></span><br><span class="line"><span class="meta">    AnnotationTarget.CONSTRUCTOR,</span></span><br><span class="line"><span class="meta">    AnnotationTarget.FUNCTION,</span></span><br><span class="line"><span class="meta">    AnnotationTarget.PROPERTY_GETTER,</span></span><br><span class="line"><span class="meta">    AnnotationTarget.PROPERTY_SETTER,</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.BINARY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Hide</span></span><br></pre></td></tr></table></figure>
<h4 id="kcp"><a class="markdownIt-Anchor" href="#kcp"></a> kcp</h4>
<p>kcp相关，下篇再讲</p>
<h4 id="lib-xxx"><a class="markdownIt-Anchor" href="#lib-xxx"></a> lib-xxx</h4>
<p>lib-xxx模块中包含对注解api-xxx的测试，打包成<code>SDK</code>，供app模块使用</p>
<h4 id="plugin"><a class="markdownIt-Anchor" href="#plugin"></a> plugin</h4>
<p>plugin模块包含AGP Transform</p>
<h3 id="实现plugin模块"><a class="markdownIt-Anchor" href="#实现plugin模块"></a> 实现plugin模块</h3>
<h4 id="创建maskplugin"><a class="markdownIt-Anchor" href="#创建maskplugin"></a> 创建MaskPlugin</h4>
<p>创建 <code>MaskPlugin</code> 类，实现 <code>org.gradle.api.Plugin</code> 接口</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaskPlugin</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span>&lt;Project&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">void</span> apply(Project project) &#123;</span><br><span class="line">        <span class="comment">// 输出日志，查看Plugin是否生效</span></span><br><span class="line">        project.logger.error(<span class="string">&quot;Welcome to guodongAndroid mask plugin.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前增加了限制仅能用于`AndroidLibrary`</span></span><br><span class="line">        LibraryExtension extension = project.extensions.findByType(LibraryExtension)</span><br><span class="line">        <span class="keyword">if</span> (extension == <span class="literal">null</span>) &#123;</span><br><span class="line">            project.logger.error(<span class="string">&quot;Only support [AndroidLibrary].&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        extension.registerTransform(<span class="keyword">new</span> MaskTransform(project))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建masktransform"><a class="markdownIt-Anchor" href="#创建masktransform"></a> 创建MaskTransform</h4>
<p>创建 <code>MaskTransform</code>，继承 <code>com.android.build.api.transform.Transform</code> 抽象类，主要实现 <code>transform</code> 方法，以下为核心代码</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaskTransform</span> <span class="keyword">extends</span> <span class="title class_">Transform</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">void</span> transform(TransformInvocation transformInvocation) <span class="keyword">throws</span> TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        <span class="type">long</span> start = System.currentTimeMillis()</span><br><span class="line">        logE(<span class="string">&quot;$TAG - start&quot;</span>)</span><br><span class="line"></span><br><span class="line">        TransformOutputProvider outputProvider = transformInvocation.outputProvider</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 没有适配增量编译</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只关心本项目生成的Class文件</span></span><br><span class="line">        transformInvocation.inputs.each &#123; transformInput -&gt;</span><br><span class="line">            transformInput.directoryInputs.each &#123; dirInput -&gt;</span><br><span class="line">                <span class="keyword">if</span> (dirInput.file.isDirectory()) &#123;</span><br><span class="line">                    dirInput.file.eachFileRecurse &#123; file -&gt;</span><br><span class="line">                        <span class="keyword">if</span> (file.name.endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                            <span class="comment">// 使用ASM修改Class文件</span></span><br><span class="line">                            ClassReader cr = <span class="keyword">new</span> ClassReader(file.bytes)</span><br><span class="line">                            ClassWriter cw = <span class="keyword">new</span> ClassWriter(cr, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">                            ClassVisitor cv = <span class="keyword">new</span> CheckClassAdapter(cw)</span><br><span class="line">                            cv = <span class="keyword">new</span> MaskClassNode(Opcodes.ASM9, cv, mProject)</span><br><span class="line">                            <span class="type">int</span> parsingOptions = <span class="number">0</span></span><br><span class="line">                            cr.accept(cv, parsingOptions)</span><br><span class="line">                            <span class="type">byte</span>[] bytes = cw.toByteArray()</span><br><span class="line"></span><br><span class="line">                            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file)</span><br><span class="line">                            fos.write(bytes)</span><br><span class="line">                            fos.flush()</span><br><span class="line">                            fos.close()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                File dest = outputProvider.getContentLocation(dirInput.name, dirInput.contentTypes, dirInput.scopes, Format.DIRECTORY)</span><br><span class="line">                FileUtils.copyDirectory(dirInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不关心第三方Jar中的Class文件</span></span><br><span class="line">            transformInput.jarInputs.each &#123; jarInput -&gt;</span><br><span class="line">                String jarName = jarInput.name</span><br><span class="line">                String md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath())</span><br><span class="line">                <span class="keyword">if</span> (jarName.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                    jarName = jarName.substring(<span class="number">0</span>, jarName.length() - <span class="number">4</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                File dest = outputProvider.getContentLocation(jarName + md5Name, jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class="line">                FileUtils.copyFile(jarInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> cost = System.currentTimeMillis() - start</span><br><span class="line">        logE(String.format(Locale.CHINA, <span class="string">&quot;$TAG - end, cost: %dms&quot;</span>, cost))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">void</span> logE(String msg) &#123;</span><br><span class="line">        mProject.logger.error(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建maskclassnode"><a class="markdownIt-Anchor" href="#创建maskclassnode"></a> 创建MaskClassNode</h4>
<p>创建 <code>MaskClassNode</code>，继承 <code>org.objectweb.asm.tree.ClassNode</code>，主要实现 <code>visitEnd</code> 方法</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaskClassNode</span> <span class="keyword">extends</span> <span class="title class_">ClassNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MaskClassNode.<span class="keyword">class</span>.simpleName</span><br><span class="line"></span><br><span class="line">    <span class="comment">// api-java中`Hide`注解的描述符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HIDE_JAVA_DESCRIPTOR = <span class="string">&quot;Lcom/guodong/android/mask/api/Hide;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// api-kt中`Hide`注解的描述符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HIDE_KOTLIN_DESCRIPTOR = <span class="string">&quot;Lcom/guodong/android/mask/api/kt/Hide;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; HIDE_DESCRIPTOR_SET = <span class="keyword">new</span> HashSet&lt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        HIDE_DESCRIPTOR_SET.add(HIDE_JAVA_DESCRIPTOR)</span><br><span class="line">        HIDE_DESCRIPTOR_SET.add(HIDE_KOTLIN_DESCRIPTOR)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Project project</span><br><span class="line"></span><br><span class="line">    MaskClassNode(<span class="type">int</span> api, ClassVisitor cv, Project project) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(api)</span><br><span class="line">        <span class="variable language_">this</span>.project = project</span><br><span class="line">        <span class="variable language_">this</span>.cv = cv</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">void</span> visitEnd() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理Field</span></span><br><span class="line">        <span class="keyword">for</span> (fn <span class="keyword">in</span> fields) &#123;</span><br><span class="line">            <span class="type">boolean</span> has = hasHideAnnotation(fn.invisibleAnnotations)</span><br><span class="line">            <span class="keyword">if</span> (has) &#123;</span><br><span class="line">                project.logger.error(<span class="string">&quot;$TAG, before --&gt; typeName = $name, fieldName = $&#123;fn.name&#125;, access = $&#123;fn.access&#125;&quot;</span>)</span><br><span class="line">                <span class="comment">// 修改字段的访问标识</span></span><br><span class="line">                fn.access += Opcodes.ACC_SYNTHETIC</span><br><span class="line">                project.logger.error(<span class="string">&quot;$TAG, after --&gt; typeName = $name, fieldName = $&#123;fn.name&#125;, access = $&#123;fn.access&#125;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理Method</span></span><br><span class="line">        <span class="keyword">for</span> (mn <span class="keyword">in</span> methods) &#123;</span><br><span class="line">            <span class="type">boolean</span> has = hasHideAnnotation(mn.invisibleAnnotations)</span><br><span class="line">            <span class="keyword">if</span> (has) &#123;</span><br><span class="line">                project.logger.error(<span class="string">&quot;$TAG, before --&gt; typeName = $name, methodName = $&#123;mn.name&#125;, access = $&#123;mn.access&#125;&quot;</span>)</span><br><span class="line">                <span class="comment">// 修改方法的访问标识</span></span><br><span class="line">                mn.access += Opcodes.ACC_SYNTHETIC</span><br><span class="line">                project.logger.error(<span class="string">&quot;$TAG, after --&gt; typeName = $name, methodName = $&#123;mn.name&#125;, access = $&#123;mn.access&#125;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">super</span>.visitEnd()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cv != <span class="literal">null</span>) &#123;</span><br><span class="line">            accept(cv)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有`Hide`注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> hasHideAnnotation(List&lt;AnnotationNode&gt; annotationNodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (annotationNodes == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (node <span class="keyword">in</span> annotationNodes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (HIDE_DESCRIPTOR_SET.contains(node.desc)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用transform"><a class="markdownIt-Anchor" href="#使用transform"></a> 使用Transform</h3>
<h4 id="buildgradle-project-level"><a class="markdownIt-Anchor" href="#buildgradle-project-level"></a> build.gradle - project level</h4>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.plugin_version = <span class="string">&#x27;x.x.x&#x27;</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;com.guodong.android:mask-gradle-plugin:$&#123;plugin_version&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="buildgradle-module-level"><a class="markdownIt-Anchor" href="#buildgradle-module-level"></a> build.gradle - module level</h4>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"># lib-kotlin</span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;maven-publish&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;com.guodong.android.mask&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lib-kotlin"><a class="markdownIt-Anchor" href="#lib-kotlin"></a> lib-kotlin</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用api-kt中的注解</span></span><br><span class="line">    <span class="meta">@Hide</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testInterface</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KotlinTest</span>(a: <span class="built_in">Int</span>) : InterfaceTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用api-kt中的注解</span></span><br><span class="line">    <span class="meta">@Hide</span></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newKotlinTest</span><span class="params">()</span></span> = KotlinTest()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding: LayoutKotlinTestBinding? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用api-kt中的注解</span></span><br><span class="line">    <span class="keyword">var</span> a = a</span><br><span class="line">        <span class="meta">@Hide</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@Hide</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getA1</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        a = <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">testInterface</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Interface function test&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="app"><a class="markdownIt-Anchor" href="#app"></a> app</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># MainActivity.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testKotlinLib</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建对象时不能访问无参构造方法，可以访问有参构造方法或访问静态工厂方法</span></span><br><span class="line">    <span class="type">KotlinTest</span> <span class="variable">test</span> <span class="operator">=</span> KotlinTest.newKotlinTest();</span><br><span class="line">    <span class="comment">// 调用时不能访问`test.getA()`方法，仅能访问`getA1()方法</span></span><br><span class="line">    Log.e(TAG, <span class="string">&quot;testKotlinLib: before --&gt; &quot;</span> + test.getA1());</span><br><span class="line">    test.test();</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;testKotlinLib: after --&gt; &quot;</span> + test.getA1());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    test.testInterface();</span><br><span class="line">    </span><br><span class="line">    <span class="type">InterfaceTest</span> <span class="variable">interfaceTest</span> <span class="operator">=</span> test;</span><br><span class="line">    <span class="comment">// Error - cannot resolve method &#x27;testInterface&#x27; in &#x27;InterfaceTest&#x27;</span></span><br><span class="line">    interfaceTest.testInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>happy:happy:</p>
<h2 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h2>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/qq_23626713/article/details/90698534">正确地使用 Kotlin 的 internal</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://youtrack.jetbrains.com/issue/KT-24981/Support-more-targets-for-JvmSynthetic">Support more targets for @JvmSynthetic : KT-24981 (jetbrains.com)</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://youtrack.jetbrains.com/issue/KT-50609/Support-constructor-target-for-JvmSynthetic-annotation">Support ‘constructor’ target for JvmSynthetic annotation : KT-50609 (jetbrains.com)</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">Chapter 4. The class File Format (oracle.com)</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>kotlin</tag>
        <tag>kcp</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-KCP的应用-修改SDK版本号</title>
    <url>/2022/05/23/Kotlin/Kotlin-KCP%E7%9A%84%E5%BA%94%E7%94%A8-%E4%BF%AE%E6%94%B9SDK%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="kotlin-kcp的应用-修改sdk版本号"><a class="markdownIt-Anchor" href="#kotlin-kcp的应用-修改sdk版本号"></a> Kotlin-KCP的应用-修改SDK版本号</h1>
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<p>在 SDK 开发中，一般会暴露获取 SDK 版本号的接口，获取的版本号一般为 String 类型，比如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sdk接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Sdk</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getVersion</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sdk调用方</span></span><br><span class="line">sdk.getVersion()</span><br></pre></td></tr></table></figure>
<p>上述方式可以通过在 <code>gradle.properties</code> 中配置版本号，然后在 <code>build.gradle</code> 中读取版本号生成至 <code>BuildConfig.java</code> 中，例如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gradle.properties</span></span><br><span class="line">VERSION=<span class="number">1.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// builde.gradle</span></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;SDK_VERSION&quot;</span>, <span class="string">&quot;\&quot;$VERSION\&quot;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SdkImple.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SdkImpl</span> : Sdk &#123;</span><br><span class="line">    override fun getVersion(): String &#123;</span><br><span class="line">        <span class="comment">// 返回 BuildConfig 中的 SDK_VERSION</span></span><br><span class="line">        <span class="keyword">return</span> BuildConfig.SDK_VERSION</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方式在 SDK 发版时只需修改 <code>gradle.properties</code> 中的版本号即可</p>
<p>但是上述方式有一个弊端：SDK 提供的版本号为 String 类型，第三方根据版本号进行适配开发时不太方便，第三方需要自己实现版本号大小的判断，笔者希望 SDK 自身可以暴露判断版本号大小的接口</p>
<h2 id="方案"><a class="markdownIt-Anchor" href="#方案"></a> 方案</h2>
<p>基于上述需求，SDK 暴露的获取版本号接口就不能返回 String 类型了，<code>Sdk</code> 接口修改如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Sdk</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个 Version 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getVersion</span><span class="params">()</span></span>: Version</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SdkImpl</span> : <span class="type">Sdk</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getVersion</span><span class="params">()</span></span>: Version &#123;</span><br><span class="line">        <span class="comment">// 返回 Version 中的 CURRENT</span></span><br><span class="line">        <span class="keyword">return</span> Version.CURRENT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 <code>Version</code> 对象的定义<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，版本号规则不尽相同，以下是示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Version</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> major: <span class="built_in">Int</span>, <span class="comment">// 主版本 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> minor: <span class="built_in">Int</span>, <span class="comment">// 次版本 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> patch: <span class="built_in">Int</span>, <span class="comment">// 补丁版本 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> extra: <span class="built_in">Int</span>, <span class="comment">// 保留版本 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> suffix: String?, <span class="comment">// 后缀版本, 比如：alpha01、beta01</span></span><br><span class="line">) : Comparable&lt;Version&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> version = versionOf(major, minor, patch, extra)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本校验</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">versionOf</span><span class="params">(major: <span class="type">Int</span>, minor: <span class="type">Int</span>, patch: <span class="type">Int</span>, extra: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        require(</span><br><span class="line">            major <span class="keyword">in</span> <span class="number">0.</span>.MAX_COMPONENT_VALUE &amp;&amp;</span><br><span class="line">                    minor <span class="keyword">in</span> <span class="number">0.</span>.MAX_COMPONENT_VALUE &amp;&amp;</span><br><span class="line">                    patch <span class="keyword">in</span> <span class="number">0.</span>.MAX_COMPONENT_VALUE &amp;&amp;</span><br><span class="line">                    extra <span class="keyword">in</span> <span class="number">0.</span>.MAX_COMPONENT_VALUE</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="string">&quot;Version components are out of range: <span class="variable">$major</span>.<span class="variable">$minor</span>.<span class="variable">$patch</span>.<span class="variable">$extra</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> major.shl(<span class="number">24</span>) + minor.shl(<span class="number">16</span>) + patch.shl(<span class="number">8</span>) + extra</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String =</span><br><span class="line">        <span class="keyword">if</span> (suffix.isNullOrEmpty()) <span class="string">&quot;<span class="variable">$major</span>.<span class="variable">$minor</span>.<span class="variable">$patch</span>.<span class="variable">$extra</span>&quot;</span> <span class="keyword">else</span> <span class="string">&quot;<span class="variable">$major</span>.<span class="variable">$minor</span>.<span class="variable">$patch</span>.<span class="variable">$extra</span>-<span class="variable">$suffix</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">val</span> otherVersion = (other <span class="keyword">as</span>? Version) ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.version == otherVersion.version</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> = version</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本比较1</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Version</span>)</span></span>: <span class="built_in">Int</span> = version - other.version</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本比较2</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isAtLeast</span><span class="params">(major: <span class="type">Int</span>, minor: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">        <span class="keyword">this</span>.major &gt; major || (<span class="keyword">this</span>.major == major &amp;&amp;</span><br><span class="line">                <span class="keyword">this</span>.minor &gt;= minor)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本比较2</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isAtLeast</span><span class="params">(major: <span class="type">Int</span>, minor: <span class="type">Int</span>, patch: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">        <span class="keyword">this</span>.major &gt; major || (<span class="keyword">this</span>.major == major &amp;&amp;</span><br><span class="line">                (<span class="keyword">this</span>.minor &gt; minor || <span class="keyword">this</span>.minor == minor &amp;&amp;</span><br><span class="line">                        <span class="keyword">this</span>.patch &gt;= patch))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本比较2</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isAtLeast</span><span class="params">(major: <span class="type">Int</span>, minor: <span class="type">Int</span>, patch: <span class="type">Int</span>, extra: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">        <span class="keyword">this</span>.major &gt; major || (<span class="keyword">this</span>.major == major &amp;&amp;</span><br><span class="line">                (<span class="keyword">this</span>.minor &gt; minor || <span class="keyword">this</span>.minor == minor &amp;&amp;</span><br><span class="line">                        (<span class="keyword">this</span>.patch &gt; patch || <span class="keyword">this</span>.patch == patch &amp;&amp;</span><br><span class="line">                                <span class="keyword">this</span>.extra &gt;= extra)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">const</span> <span class="keyword">val</span> MAX_COMPONENT_VALUE = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前版本</span></span><br><span class="line">        <span class="meta">@JvmField</span></span><br><span class="line">        <span class="keyword">val</span> CURRENT: Version = VersionCurrentValue.<span class="keyword">get</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">object</span> VersionCurrentValue &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: Version =</span><br><span class="line">        Version(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>) <span class="comment">// value is written here automatically during build</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三方进行版本适配开发时，可以如下操作，就比较方便了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> version = sdk.getVersion()</span><br><span class="line">println(<span class="string">&quot;version = <span class="variable">$version</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (version.isAtLeast(<span class="number">1</span>, <span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="comment">// 当前版本大于等于 1.2.0.0</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当前版本小于 1.2.0.0</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方案是不是比较友好了？:happy:，不知道读者有没有发现，在哪里修改版本号呢？</p>
<p>细心的读者可能已经发现，<code>Version.CURRENT</code> 是调用的 <code>VersionCurrentValue#get()</code> 方法，<code>VersionCurrentValue#get()</code> 方法会创建 <code>Version</code> 对象的实例，只需要修改 <code>VersionCurrentValue#get()</code> 方法传入版本号即可。等下，每次发版时都要修改 <code>VersionCurrentValue#get()</code> 方法？</p>
<p>隐隐感觉到一丝不妥，要是哪次发版时忘记修改 <code>VersionCurrentValue#get()</code> 方法，这不惨了😢</p>
<p>“人非圣贤孰能无过” 呢，还是让程序帮我们生成版本号吧，同时兼容方案一：只修改 <code>gradle.properties</code> 即可</p>
<p>使用 KCP 在编译阶段修改 <code>VersionCurrentValue#get()</code> 方法</p>
<h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2>
<p>在上篇 <a href="https://juejin.cn/post/7096720525799473165">Kotlin-KCP的应用-第二篇</a> 中笔者记录了搭建 KCP 环境的基本步骤，这里不再赘述，有兴趣的读者可以先看下上篇文章</p>
<p><img data-src="https://guodongandroid.coding.net/p/typora/d/typora/git/raw/master/img/202205222241364.png" alt="image-20220522224118965" /></p>
<p>上图是本项目的组织架构，简单介绍下：</p>
<ul>
<li>
<p>sample：包含 <code>Version</code> 及测试类</p>
</li>
<li>
<p>version-plugin-gradle：kcp 中的 gradle plugin 部分</p>
</li>
<li>
<p>version-plugin-kotlin：kcp 中的 kotlin compiler plugin 部分</p>
</li>
</ul>
<p>sample 模块不做介绍，下面主要实现其他两个模块</p>
<h3 id="buildgradlekts-project-level"><a class="markdownIt-Anchor" href="#buildgradlekts-project-level"></a> build.gradle.kts - project level</h3>
<p>在项目级别的 build.gradle.kts 脚本中配置插件依赖</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    <span class="comment">// 配置 Kotlin 插件唯一ID</span></span><br><span class="line">    extra[<span class="string">&quot;kotlin_plugin_id&quot;</span>] = <span class="string">&quot;com.guodong.android.version.kcp&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">&quot;jvm&quot;</span>) version <span class="string">&quot;1.5.31&quot;</span> apply <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置 Gradle 发布插件，可以不再写 META-INF</span></span><br><span class="line">    id(<span class="string">&quot;com.gradle.plugin-publish&quot;</span>) version <span class="string">&quot;0.16.0&quot;</span> apply <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置生成 BuildConfig 插件</span></span><br><span class="line">    id(<span class="string">&quot;com.github.gmazzo.buildconfig&quot;</span>) version <span class="string">&quot;3.0.3&quot;</span> apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    <span class="comment">// 配置 Kotlin 插件版本</span></span><br><span class="line">    version = <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="version-plugin-gradle"><a class="markdownIt-Anchor" href="#version-plugin-gradle"></a> version-plugin-gradle</h3>
<p>首先配置下 build.gradle.kts 脚本</p>
<h4 id="buildgradlekts-module-level"><a class="markdownIt-Anchor" href="#buildgradlekts-module-level"></a> build.gradle.kts - module level</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;java-gradle-plugin&quot;</span>)</span><br><span class="line">    kotlin(<span class="string">&quot;jvm&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;com.github.gmazzo.buildconfig&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(kotlin(<span class="string">&quot;gradle-plugin-api&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildConfig &#123;</span><br><span class="line">    <span class="comment">// 配置 BuildConfig 的包名</span></span><br><span class="line">    packageName(<span class="string">&quot;com.guodong.android.version.kcp.plugin.gradle&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Kotlin 插件唯一 ID</span></span><br><span class="line">    buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;KOTLIN_PLUGIN_ID&quot;</span>, <span class="string">&quot;\&quot;<span class="subst">$&#123;rootProject.extra[<span class="string">&quot;kotlin_plugin_id&quot;</span>]&#125;</span>\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Kotlin 插件 GroupId</span></span><br><span class="line">    buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;KOTLIN_PLUGIN_GROUP&quot;</span>, <span class="string">&quot;\&quot;com.guodong.android\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Kotlin 插件 ArtifactId</span></span><br><span class="line">    buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;KOTLIN_PLUGIN_NAME&quot;</span>, <span class="string">&quot;\&quot;version-kcp-kotlin-plugin\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Kotlin 插件 Version</span></span><br><span class="line">    buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;KOTLIN_PLUGIN_VERSION&quot;</span>, <span class="string">&quot;\&quot;<span class="subst">$&#123;project.version&#125;</span>\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradlePlugin &#123;</span><br><span class="line">    plugins &#123;</span><br><span class="line">        create(<span class="string">&quot;Version&quot;</span>) &#123;</span><br><span class="line">            id = rootProject.extra[<span class="string">&quot;kotlin_plugin_id&quot;</span>] <span class="keyword">as</span> String <span class="comment">// `apply plugin: &quot;com.guodong.android.version.kcp&quot;`</span></span><br><span class="line">            displayName = <span class="string">&quot;Version Kcp&quot;</span></span><br><span class="line">            description = <span class="string">&quot;Version Kcp&quot;</span></span><br><span class="line">            implementationClass = <span class="string">&quot;com.guodong.android.version.kcp.gradle.VersionGradlePlugin&quot;</span> <span class="comment">// 插件入口类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType&lt;KotlinCompile&gt; &#123;</span><br><span class="line">    kotlinOptions.jvmTarget = <span class="string">&quot;1.8&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="versiongradleplugin"><a class="markdownIt-Anchor" href="#versiongradleplugin"></a> VersionGradlePlugin</h4>
<p>创建 <code>VersionGradlePlugin</code> 实现 <code>KotlinCompilerPluginSupportPlugin</code> 接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionGradlePlugin</span> : <span class="type">KotlinCompilerPluginSupportPlugin</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(target: <span class="type">Project</span>)</span></span>: <span class="built_in">Unit</span> = with(target) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Welcome to guodongAndroid-version kcp gradle plugin.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此处配置 Gradle 插件扩展</span></span><br><span class="line">        extensions.create(<span class="string">&quot;version&quot;</span>, VersionExtension::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否适用, 默认True</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isApplicable</span><span class="params">(kotlinCompilation: <span class="type">KotlinCompilation</span>&lt;*&gt;)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Kotlin 插件唯一ID</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCompilerPluginId</span><span class="params">()</span></span>: String = BuildConfig.KOTLIN_PLUGIN_ID</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Kotlin 插件 Maven 坐标信息</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPluginArtifact</span><span class="params">()</span></span>: SubpluginArtifact = SubpluginArtifact(</span><br><span class="line">        groupId = BuildConfig.KOTLIN_PLUGIN_GROUP,</span><br><span class="line">        artifactId = BuildConfig.KOTLIN_PLUGIN_NAME,</span><br><span class="line">        version = BuildConfig.KOTLIN_PLUGIN_VERSION</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 Gradle 插件扩展信息并写入 SubpluginOption</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyToCompilation</span><span class="params">(kotlinCompilation: <span class="type">KotlinCompilation</span>&lt;*&gt;)</span></span>: Provider&lt;List&lt;SubpluginOption&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> project = kotlinCompilation.target.project</span><br><span class="line">        <span class="keyword">val</span> extension = project.extensions.getByType(VersionExtension::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">return</span> project.provider &#123;</span><br><span class="line">            listOf(</span><br><span class="line">                SubpluginOption(key = <span class="string">&quot;version&quot;</span>, value = extension.version)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为版本号需要在外部配置传入 Gradle Plugin，这里需要创建 VersionExtension：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">VersionExtension</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> version: String = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;VersionExtension(version=<span class="variable">$version</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此 Gradle 插件编写完成</p>
<h3 id="version-plugin-kotlin"><a class="markdownIt-Anchor" href="#version-plugin-kotlin"></a> version-plugin-kotlin</h3>
<p>接下来编写 Kotlin 编译器插件，首先配置下 build.gradle.kts 脚本</p>
<h4 id="buildgradlekts-module-level-2"><a class="markdownIt-Anchor" href="#buildgradlekts-module-level-2"></a> build.gradle.kts - module level</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">&quot;jvm&quot;</span>)</span><br><span class="line">    kotlin(<span class="string">&quot;kapt&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;com.github.gmazzo.buildconfig&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 依赖 Kotlin 编译器库</span></span><br><span class="line">    compileOnly(<span class="string">&quot;org.jetbrains.kotlin:kotlin-compiler-embeddable&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖 Google auto service</span></span><br><span class="line">    kapt(<span class="string">&quot;com.google.auto.service:auto-service:1.0&quot;</span>)</span><br><span class="line">    compileOnly(<span class="string">&quot;com.google.auto.service:auto-service-annotations:1.0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildConfig &#123;</span><br><span class="line">    <span class="comment">// 配置 BuildConfig 的包名</span></span><br><span class="line">    packageName(<span class="string">&quot;com.guodong.android.version.kcp.plugin.kotlin&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 Kotlin 插件唯一 ID</span></span><br><span class="line">    buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;KOTLIN_PLUGIN_ID&quot;</span>, <span class="string">&quot;\&quot;<span class="subst">$&#123;rootProject.extra[<span class="string">&quot;kotlin_plugin_id&quot;</span>]&#125;</span>\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType&lt;KotlinCompile&gt; &#123;</span><br><span class="line">    kotlinOptions.jvmTarget = <span class="string">&quot;1.8&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="versioncommandlineprocessor"><a class="markdownIt-Anchor" href="#versioncommandlineprocessor"></a> VersionCommandLineProcessor</h4>
<p>实现 <code>CommandLineProcessor</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService(CommandLineProcessor::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VersionCommandLineProcessor</span> : <span class="type">CommandLineProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">// OptionName 对应 VersionGradlePlugin#applyToCompilation() 传入的 Key</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> OPTION_VERSION = <span class="string">&quot;version&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ConfigurationKey</span></span><br><span class="line">        <span class="keyword">val</span> ARG_VERSION = CompilerConfigurationKey&lt;String&gt;(OPTION_VERSION)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 Kotlin 插件唯一 ID</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> pluginId: String = BuildConfig.KOTLIN_PLUGIN_ID</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 `SubpluginOptions` 参数，并写入 `CliOption`</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> pluginOptions: Collection&lt;AbstractCliOption&gt; = listOf(</span><br><span class="line">        CliOption(</span><br><span class="line">            optionName = OPTION_VERSION,</span><br><span class="line">            valueDescription = <span class="string">&quot;string&quot;</span>,</span><br><span class="line">            description = <span class="string">&quot;version string&quot;</span>,</span><br><span class="line">            required = <span class="literal">true</span>,</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 `CliOption` 写入 `CompilerConfiguration`</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">processOption</span><span class="params">(option: <span class="type">AbstractCliOption</span>, value: <span class="type">String</span>, configuration: <span class="type">CompilerConfiguration</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (option.optionName) &#123;</span><br><span class="line">            OPTION_VERSION -&gt; configuration.put(ARG_VERSION, value)</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unexpected config option <span class="subst">$&#123;option.optionName&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="versioncomponentregistrar"><a class="markdownIt-Anchor" href="#versioncomponentregistrar"></a> VersionComponentRegistrar</h4>
<p>实现 <code>ComponentRegistrar</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService(ComponentRegistrar::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VersionComponentRegistrar</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> defaultVersion: String,</span><br><span class="line">) : ComponentRegistrar &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">const</span> <span class="keyword">val</span> DEFAULT_VERSION = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;unused&quot;</span>)</span> <span class="comment">// Used by service loader</span></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(DEFAULT_VERSION)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerProjectComponents</span><span class="params">(project: <span class="type">MockProject</span>, configuration: <span class="type">CompilerConfiguration</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 获取日志收集器</span></span><br><span class="line">        <span class="keyword">val</span> messageCollector = configuration.<span class="keyword">get</span>(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY, MessageCollector.NONE)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取传入的版本号</span></span><br><span class="line">        <span class="keyword">val</span> version = configuration.<span class="keyword">get</span>(VersionCommandLineProcessor.ARG_VERSION, defaultVersion)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出日志，查看是否执行</span></span><br><span class="line">        <span class="comment">// CompilerMessageSeverity.INFO - 没有看到日志输出</span></span><br><span class="line">        <span class="comment">// CompilerMessageSeverity.ERROR - 编译过程停止执行</span></span><br><span class="line">        messageCollector.report(CompilerMessageSeverity.STRONG_WARNING, <span class="string">&quot;Welcome to guodongAndroid-version kcp kotlin plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处在 `ClassBuilderInterceptorExtension` 中注册扩展</span></span><br><span class="line">        ClassBuilderInterceptorExtension.registerExtension(</span><br><span class="line">            project,</span><br><span class="line">            VersionClassGenerationInterceptor(</span><br><span class="line">                messageCollector = messageCollector,</span><br><span class="line">                <span class="comment">// 传入版本号</span></span><br><span class="line">                version = version</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="versionclassgenerationinterceptor"><a class="markdownIt-Anchor" href="#versionclassgenerationinterceptor"></a> VersionClassGenerationInterceptor</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionClassGenerationInterceptor</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messageCollector: MessageCollector,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> version: String,</span><br><span class="line">) : ClassBuilderInterceptorExtension &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截 ClassBuilderFactory</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">interceptClassBuilderFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        interceptedFactory: <span class="type">ClassBuilderFactory</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        bindingContext: <span class="type">BindingContext</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        diagnostics: <span class="type">DiagnosticSink</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 自定义 ClassBuilderFactory 委托给 源ClassBuilderFactory</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: ClassBuilderFactory = <span class="keyword">object</span> : ClassBuilderFactory <span class="keyword">by</span> interceptedFactory &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复写 newClassBuilder</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newClassBuilder</span><span class="params">(origin: <span class="type">JvmDeclarationOrigin</span>)</span></span>: ClassBuilder &#123;</span><br><span class="line">            <span class="comment">// 自定义 ClassBuilder</span></span><br><span class="line">            <span class="keyword">return</span> VersionClassBuilder(</span><br><span class="line">                messageCollector = messageCollector,</span><br><span class="line">                <span class="comment">// 传入版本号</span></span><br><span class="line">                version = version,</span><br><span class="line">                <span class="comment">// 传入源ClassBuilder</span></span><br><span class="line">                delegate = interceptedFactory.newClassBuilder(origin),</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="versionclassbuilder"><a class="markdownIt-Anchor" href="#versionclassbuilder"></a> VersionClassBuilder</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionClassBuilder</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messageCollector: MessageCollector,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> version: String,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> delegate: ClassBuilder,</span><br><span class="line">) : DelegatingClassBuilder() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> VERSION_NAME = <span class="string">&quot;com/guodong/android/VersionCurrentValue&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> MIN_COMPONENT_VALUE = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> MAX_COMPONENT_VALUE = <span class="number">255</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDelegate</span><span class="params">()</span></span>: ClassBuilder &#123;</span><br><span class="line">        <span class="keyword">return</span> delegate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        origin: <span class="type">JvmDeclarationOrigin</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        access: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        desc: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        signature: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        exceptions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: MethodVisitor &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> original = <span class="keyword">super</span>.newMethod(origin, access, name, desc, signature, exceptions)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> thisName = delegate.thisName</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 校验VersionCurrentValue的完全限定名</span></span><br><span class="line">        <span class="keyword">if</span> (thisName != VERSION_NAME) &#123;</span><br><span class="line">            <span class="keyword">return</span> original</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验是否在`build.gradle`中设置了版本号</span></span><br><span class="line">        <span class="keyword">if</span> (version == VersionComponentRegistrar.DEFAULT_VERSION) &#123;</span><br><span class="line">            messageCollector.report(</span><br><span class="line">                CompilerMessageSeverity.ERROR,</span><br><span class="line">                <span class="string">&quot;Missing version, need to set version in build.gradle, like this:\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;version &#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;\tversion = \&quot;1.0.0.0\&quot;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结构版本号</span></span><br><span class="line">        <span class="keyword">val</span> (major, minor, patch, extra, suffix) = parseVersion()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回ASM MethodVisitor</span></span><br><span class="line">        <span class="keyword">return</span> VersionMethodVisitor(Opcodes.ASM9, original, major, minor, patch, extra, suffix)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析版本号为`Multiple`</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseVersion</span><span class="params">()</span></span>: Multiple&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>, <span class="built_in">Int</span>, <span class="built_in">Int</span>, String?&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (version.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Version must not be empty.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> major: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">val</span> minor: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">val</span> patch: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">val</span> extra: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">val</span> suffix: String?</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (version.contains(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">val</span> split = version.split(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (split.size != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Version components must be only contains one `-`.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> versions = split[<span class="number">0</span>].split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> length = versions.size</span><br><span class="line">            <span class="keyword">if</span> (length != <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Version components must be four digits, it is [ <span class="variable">$version</span> ] now.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                major = versions[<span class="number">0</span>].toInt()</span><br><span class="line">                minor = versions[<span class="number">1</span>].toInt()</span><br><span class="line">                patch = versions[<span class="number">2</span>].toInt()</span><br><span class="line">                extra = versions[<span class="number">3</span>].toInt()</span><br><span class="line">                suffix = split[<span class="number">1</span>]</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">                <span class="keyword">val</span> errMsg = <span class="string">&quot;Version components must consist of numbers.&quot;</span></span><br><span class="line">                <span class="keyword">val</span> exception = IllegalArgumentException(errMsg)</span><br><span class="line">                exception.addSuppressed(e)</span><br><span class="line">                <span class="keyword">throw</span> exception</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> versions = version.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> length = versions.size</span><br><span class="line">            <span class="keyword">if</span> (length != <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Version components must be four digits, it is [ <span class="variable">$version</span> ] now.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                major = versions[<span class="number">0</span>].toInt()</span><br><span class="line">                minor = versions[<span class="number">1</span>].toInt()</span><br><span class="line">                patch = versions[<span class="number">2</span>].toInt()</span><br><span class="line">                extra = versions[<span class="number">3</span>].toInt()</span><br><span class="line">                suffix = <span class="literal">null</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">                <span class="keyword">val</span> errMsg = <span class="string">&quot;Version components must consist of numbers.&quot;</span></span><br><span class="line">                <span class="keyword">val</span> exception = IllegalArgumentException(errMsg)</span><br><span class="line">                exception.addSuppressed(e)</span><br><span class="line">                <span class="keyword">throw</span> exception</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (suffix.isNullOrEmpty()) &#123;</span><br><span class="line">            messageCollector.report(</span><br><span class="line">                CompilerMessageSeverity.WARNING,</span><br><span class="line">                String.format(Locale.CHINA, <span class="string">&quot;version = %d.%d.%d.%d&quot;</span>, major, minor, patch, extra)</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            messageCollector.report(</span><br><span class="line">                CompilerMessageSeverity.WARNING,</span><br><span class="line">                String.format(Locale.CHINA, <span class="string">&quot;version = %d.%d.%d.%d-%s&quot;</span>, major, minor, patch, extra, suffix)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkVersion(major) || checkVersion(minor) || checkVersion(patch) || checkVersion(extra)) &#123;</span><br><span class="line">            <span class="keyword">val</span> msg = String.format(</span><br><span class="line">                Locale.CHINA,</span><br><span class="line">                <span class="string">&quot;Version components are out of range: %d.%d.%d.%d.&quot;</span>,</span><br><span class="line">                major,</span><br><span class="line">                minor,</span><br><span class="line">                patch,</span><br><span class="line">                extra</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(msg)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Multiple(major, minor, patch, extra, suffix)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkVersion</span><span class="params">(version: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> version &lt; MIN_COMPONENT_VALUE || version &gt; MAX_COMPONENT_VALUE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="multiple"><a class="markdownIt-Anchor" href="#multiple"></a> Multiple</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Multiple</span>&lt;<span class="type">out A, out B, out C, out D, out E</span>&gt;(</span><br><span class="line">    <span class="keyword">val</span> first: A,</span><br><span class="line">    <span class="keyword">val</span> second: B,</span><br><span class="line">    <span class="keyword">val</span> third: C,</span><br><span class="line">    <span class="keyword">val</span> fourth: D,</span><br><span class="line">    <span class="keyword">val</span> fifth: E?</span><br><span class="line">) : Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;(<span class="variable">$first</span>, <span class="variable">$second</span>, <span class="variable">$third</span>, <span class="variable">$fourth</span>, <span class="variable">$fifth</span>)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="versionmethodvisitor"><a class="markdownIt-Anchor" href="#versionmethodvisitor"></a> VersionMethodVisitor</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionMethodVisitor</span>(</span><br><span class="line">    api: <span class="built_in">Int</span>,</span><br><span class="line">    mv: MethodVisitor,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> major: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> minor: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> patch: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> extra: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> suffix: String?</span><br><span class="line">) : MethodPatternAdapter(api, mv) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SEEN_ICONST_0 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SEEN_ICONST_0_ICONST_0 = <span class="number">2</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SEEN_ICONST_0_ICONST_0_ICONST_0 = <span class="number">3</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SEEN_ICONST_0_ICONST_0_ICONST_0_ICONST_0 = <span class="number">4</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SEEN_ICONST_0_ICONST_0_ICONST_0_ICONST_0_ACONST_NULL = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Version完全限定名</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> OWNER = <span class="string">&quot;com/guodong/android/Version&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> METHOD_NAME = <span class="string">&quot;&lt;init&gt;&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> METHOD_DESCRIPTOR = <span class="string">&quot;(IIIILjava/lang/String;)V&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * val version = Version(0, 0, 0, 0, null)</span></span><br><span class="line"><span class="comment">     * ICONST_0</span></span><br><span class="line"><span class="comment">     * ICONST_0</span></span><br><span class="line"><span class="comment">     * ICONST_0</span></span><br><span class="line"><span class="comment">     * ICONST_0</span></span><br><span class="line"><span class="comment">     * ACONST_NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitInsn</span><span class="params">(opcode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 状态机</span></span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            SEEN_NOTHING -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (opcode == Opcodes.ICONST_0) &#123;</span><br><span class="line">                    state = SEEN_ICONST_0</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SEEN_ICONST_0 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (opcode == Opcodes.ICONST_0) &#123;</span><br><span class="line">                    state = SEEN_ICONST_0_ICONST_0</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SEEN_ICONST_0_ICONST_0 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (opcode == Opcodes.ICONST_0) &#123;</span><br><span class="line">                    state = SEEN_ICONST_0_ICONST_0_ICONST_0</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SEEN_ICONST_0_ICONST_0_ICONST_0 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (opcode == Opcodes.ICONST_0) &#123;</span><br><span class="line">                    state = SEEN_ICONST_0_ICONST_0_ICONST_0_ICONST_0</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SEEN_ICONST_0_ICONST_0_ICONST_0_ICONST_0 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (opcode == Opcodes.ACONST_NULL) &#123;</span><br><span class="line">                    state = SEEN_ICONST_0_ICONST_0_ICONST_0_ICONST_0_ACONST_NULL</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SEEN_ICONST_0_ICONST_0_ICONST_0_ICONST_0_ACONST_NULL -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (opcode == Opcodes.ACONST_NULL) &#123;</span><br><span class="line">                    mv.visitInsn(opcode)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.visitInsn(opcode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitMethodInsn</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        opcode: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        owner: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        descriptor: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        isInterface: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> flag = opcode == Opcodes.INVOKESPECIAL</span><br><span class="line">        &amp;&amp; OWNER == owner</span><br><span class="line">        &amp;&amp; METHOD_NAME == name</span><br><span class="line">        &amp;&amp; METHOD_DESCRIPTOR == descriptor</span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            SEEN_ICONST_0_ICONST_0_ICONST_0_ICONST_0_ACONST_NULL -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    weaveCode(major)</span><br><span class="line">                    weaveCode(minor)</span><br><span class="line">                    weaveCode(patch)</span><br><span class="line">                    weaveCode(extra)</span><br><span class="line">                    weaveSuffix()</span><br><span class="line">                    state = SEEN_NOTHING</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.visitMethodInsn(opcode, owner, name, descriptor, isInterface)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 补发</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitInsn</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            SEEN_ICONST_0 -&gt; &#123;</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">            &#125;</span><br><span class="line">            SEEN_ICONST_0_ICONST_0 -&gt; &#123;</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">            &#125;</span><br><span class="line">            SEEN_ICONST_0_ICONST_0_ICONST_0 -&gt; &#123;</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">            &#125;</span><br><span class="line">            SEEN_ICONST_0_ICONST_0_ICONST_0_ICONST_0 -&gt; &#123;</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">            &#125;</span><br><span class="line">            SEEN_ICONST_0_ICONST_0_ICONST_0_ICONST_0_ACONST_NULL -&gt; &#123;</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">                mv.visitInsn(Opcodes.ICONST_0)</span><br><span class="line">                mv.visitInsn(Opcodes.ACONST_NULL)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state = SEEN_NOTHING</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 织入版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">weaveCode</span><span class="params">(code: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            code &lt;= <span class="number">5</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> opcode = <span class="keyword">when</span> (code) &#123;</span><br><span class="line">                    <span class="number">0</span> -&gt; Opcodes.ICONST_0</span><br><span class="line">                    <span class="number">1</span> -&gt; Opcodes.ICONST_1</span><br><span class="line">                    <span class="number">2</span> -&gt; Opcodes.ICONST_2</span><br><span class="line">                    <span class="number">3</span> -&gt; Opcodes.ICONST_3</span><br><span class="line">                    <span class="number">4</span> -&gt; Opcodes.ICONST_4</span><br><span class="line">                    <span class="number">5</span> -&gt; Opcodes.ICONST_5</span><br><span class="line">                    <span class="keyword">else</span> -&gt; Opcodes.ICONST_0</span><br><span class="line">                &#125;</span><br><span class="line">                mv.visitInsn(opcode)</span><br><span class="line">            &#125;</span><br><span class="line">            code &lt;= <span class="number">127</span> -&gt; &#123;</span><br><span class="line">                mv.visitIntInsn(Opcodes.BIPUSH, code)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                mv.visitIntInsn(Opcodes.SIPUSH, code)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 织入后缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">weaveSuffix</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (suffix.isNullOrEmpty()) &#123;</span><br><span class="line">            mv.visitInsn(Opcodes.ACONST_NULL)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mv.visitLdcInsn(suffix)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2>
<h3 id="sample-buildgradlekts"><a class="markdownIt-Anchor" href="#sample-buildgradlekts"></a> sample - build.gradle.kts</h3>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">&quot;jvm&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;com.guodong.android.version.kcp&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">version &#123;</span><br><span class="line">    version = <span class="string">&quot;1.0.0.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="test"><a class="markdownIt-Anchor" href="#test"></a> Test</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;version = <span class="subst">$&#123;Version.CURRENT&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">version = <span class="number">1.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>happy~</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>参考 <code>KotlinVersion.kt</code> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>kotlin</tag>
        <tag>kcp</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-KCP的应用-第二篇</title>
    <url>/2022/05/12/Kotlin/Kotlin-KCP%E7%9A%84%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
    <content><![CDATA[<h1 id="kotlin-kcp的应用-第二篇"><a class="markdownIt-Anchor" href="#kotlin-kcp的应用-第二篇"></a> Kotlin-KCP的应用-第二篇</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>接<a href="https://juejin.cn/post/7095248182912745502">Kotlin-KCP的应用-第一篇</a>，本文是第二篇，以下是本文的目标：</p>
<ol>
<li>记录如何简单搭建 KCP 开发环境</li>
<li>使用 KCP 解决第一篇中的问题</li>
</ol>
<h2 id="何为kcp为何不使用ksp"><a class="markdownIt-Anchor" href="#何为kcp为何不使用ksp"></a> 何为KCP？为何不使用KSP？</h2>
<h3 id="ksp"><a class="markdownIt-Anchor" href="#ksp"></a> KSP</h3>
<p><code>KSP</code> 即 <a href="https://github.com/google/ksp"><code>Kotlin Symbol Processing(Kotlin符号处理器)</code></a>，KSP 目前只能生成代码，不能修改字节码，第一篇中的问题需要修改字节码，因此 KSP 不能满足需求</p>
<h3 id="kcp"><a class="markdownIt-Anchor" href="#kcp"></a> KCP</h3>
<p><code>KCP</code> 即 <code>Kotlin Compiler Plugin(Kotlin编译器插件)</code>，在 <code>kotlinc</code> 过程中提供 hook 时机，在此期间可以生成代码、修改字节码等</p>
<p>标准的 KCP 架构如下<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205120932971.png" alt="KCP架构" /></p>
<h3 id="plugin"><a class="markdownIt-Anchor" href="#plugin"></a> Plugin</h3>
<ul>
<li>Gradle 插件，与 Kotlin 无关，在 build.gradle 脚本中提供一个入口</li>
<li>通过 Gradle 扩展设置配置信息</li>
</ul>
<h3 id="subplugin"><a class="markdownIt-Anchor" href="#subplugin"></a> Subplugin</h3>
<ul>
<li>介于 Gradle 和 Kotlin 直接的 APIs 接口</li>
<li>读取 Gradle 扩展配置信息并写入 <code>SubpluginOptions</code></li>
<li>定义编译器插件的唯一<code>ID</code></li>
<li>定义 Kotlin 插件的 Maven 坐标信息，便于编译器下载它</li>
</ul>
<h3 id="commandlinprocessor"><a class="markdownIt-Anchor" href="#commandlinprocessor"></a> CommandLinProcessor</h3>
<ul>
<li>设置 Kotlin 插件唯一 ID</li>
<li>读取 kotlinc -Xplugin 参数</li>
<li>读取 <code>SubpluginOptions</code> 配置信息，并写入 <code>CompilerConfigurationKeys</code></li>
</ul>
<h3 id="componentregistrar"><a class="markdownIt-Anchor" href="#componentregistrar"></a> ComponentRegistrar</h3>
<ul>
<li>读取 <code>CompilerConfigurationKeys</code></li>
<li>注册 <code>Extension</code> 到各编译流程</li>
</ul>
<h3 id="extension"><a class="markdownIt-Anchor" href="#extension"></a> Extension</h3>
<ul>
<li>生成代码</li>
<li>修改字节码</li>
<li>多种类型的扩展，比如
<ul>
<li>ExpressionCodegenExtension</li>
<li>ClassBuilderInterceptorExtension</li>
<li>StorageComponentContainerContributor</li>
<li>IrGenerationExtension</li>
</ul>
</li>
</ul>
<h2 id="实现kcp"><a class="markdownIt-Anchor" href="#实现kcp"></a> 实现KCP</h2>
<h3 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h3>
<p>根据 KCP 的架构，下面一一进行实现</p>
<p><img data-src="https://gitee.com/guodongAndroid/typora/raw/master/img/202205120959782.png" alt="image-20220512095927050" /></p>
<p>上图是本仓库架构，旨在通过 KCP 在 Java 字节码中 <code>@Hide</code> 注解目标上设置 <code>ACC_SYNTHETIC</code> 标识，使其在 Java 中不能正常调用，达到隐藏 API 的效果</p>
<h3 id="buildgradle-project-level"><a class="markdownIt-Anchor" href="#buildgradle-project-level"></a> build.gradle - project level</h3>
<p>在项目级别的 build.gradle 脚本中配置插件依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    <span class="comment">// 配置 Kotlin 插件唯一ID</span></span><br><span class="line">    ext.kotlin_plugin_id = <span class="string">&quot;com.guodong.android.mask.kcp&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置 Kotlin 插件版本</span></span><br><span class="line">    ext.plugin_version = <span class="string">&#x27;x.x.x&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    <span class="comment">// 配置 Gradle 发布插件，可以不再写 META-INF</span></span><br><span class="line">    id(<span class="string">&quot;com.gradle.plugin-publish&quot;</span>) version <span class="string">&quot;0.16.0&quot;</span> apply <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置生成 BuildConfig 插件</span></span><br><span class="line">    id(<span class="string">&quot;com.github.gmazzo.buildconfig&quot;</span>) version <span class="string">&quot;3.0.3&quot;</span> apply <span class="literal">false</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.kotlin.jvm&#x27;</span> version <span class="string">&#x27;1.6.10&#x27;</span> apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="plugin-gradle"><a class="markdownIt-Anchor" href="#plugin-gradle"></a> plugin-gradle</h3>
<p>接下来编写 Gradle 插件，此插件对应 KCP 架构中的 <code>Plugin</code> 和 <code>Subplugin</code></p>
<p>首先配置下 build.gradle.kts 脚本</p>
<h4 id="buildgradlekts-module-level"><a class="markdownIt-Anchor" href="#buildgradlekts-module-level"></a> build.gradle.kts - module level</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;java-gradle-plugin&quot;</span>)</span><br><span class="line">    kotlin(<span class="string">&quot;jvm&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;com.github.gmazzo.buildconfig&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(kotlin(<span class="string">&quot;gradle-plugin-api&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildConfig &#123;</span><br><span class="line">    <span class="comment">// 配置 BuildConfig 的包名</span></span><br><span class="line">    packageName(<span class="string">&quot;com.guodong.android.mask.kcp.gradle&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 Kotlin 插件唯一 ID</span></span><br><span class="line">    buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;KOTLIN_PLUGIN_ID&quot;</span>, <span class="string">&quot;\&quot;<span class="subst">$&#123;rootProject.extra[<span class="string">&quot;kotlin_plugin_id&quot;</span>]&#125;</span>\&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 Kotlin 插件 GroupId</span></span><br><span class="line">    buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;KOTLIN_PLUGIN_GROUP&quot;</span>, <span class="string">&quot;\&quot;com.guodong.android\&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 Kotlin 插件 ArtifactId</span></span><br><span class="line">    buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;KOTLIN_PLUGIN_NAME&quot;</span>, <span class="string">&quot;\&quot;mask-kcp-kotlin-plugin\&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 Kotlin 插件 Version</span></span><br><span class="line">    buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;KOTLIN_PLUGIN_VERSION&quot;</span>, <span class="string">&quot;\&quot;<span class="subst">$&#123;rootProject.extra[<span class="string">&quot;PLUGIN_VERSION&quot;</span>]&#125;</span>\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradlePlugin &#123;</span><br><span class="line">    plugins &#123;</span><br><span class="line">        create(<span class="string">&quot;Mask&quot;</span>) &#123;</span><br><span class="line">            id = rootProject.extra[<span class="string">&quot;kotlin_plugin_id&quot;</span>] <span class="keyword">as</span> String <span class="comment">// `apply plugin: &quot;com.guodong.android.mask.kcp&quot;`</span></span><br><span class="line">            displayName = <span class="string">&quot;Mask Kcp&quot;</span></span><br><span class="line">            description = <span class="string">&quot;Mask Kcp&quot;</span></span><br><span class="line">            implementationClass = <span class="string">&quot;com.guodong.android.mask.kcp.gradle.MaskGradlePlugin&quot;</span> <span class="comment">// 插件入口类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType&lt;KotlinCompile&gt; &#123;</span><br><span class="line">    kotlinOptions.jvmTarget = <span class="string">&quot;1.8&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="maskgradleplugin"><a class="markdownIt-Anchor" href="#maskgradleplugin"></a> MaskGradlePlugin</h4>
<p>创建 <code>MaskGradlePlugin</code> 实现 <code>KotlinCompilerPluginSupportPlugin</code> 接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaskGradlePlugin</span> : <span class="type">KotlinCompilerPluginSupportPlugin</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(target: <span class="type">Project</span>)</span></span> = with(target) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Welcome to guodongAndroid mask kcp gradle plugin.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此处可以配置 Gradle 插件扩展</span></span><br><span class="line">        <span class="comment">// 本插件没有配置项, 无需配置扩展</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否适用, 默认True</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isApplicable</span><span class="params">(kotlinCompilation: <span class="type">KotlinCompilation</span>&lt;*&gt;)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Kotlin 插件唯一ID</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCompilerPluginId</span><span class="params">()</span></span>: String = BuildConfig.KOTLIN_PLUGIN_ID</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Kotlin 插件 Maven 坐标信息</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPluginArtifact</span><span class="params">()</span></span>: SubpluginArtifact = SubpluginArtifact(</span><br><span class="line">        groupId = BuildConfig.KOTLIN_PLUGIN_GROUP,</span><br><span class="line">        artifactId = BuildConfig.KOTLIN_PLUGIN_NAME,</span><br><span class="line">        version = BuildConfig.KOTLIN_PLUGIN_VERSION,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 Gradle 插件扩展信息并写入 SubpluginOption</span></span><br><span class="line">    <span class="comment">// 本插件没有扩展信息，所以返回空集合</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyToCompilation</span><span class="params">(kotlinCompilation: <span class="type">KotlinCompilation</span>&lt;*&gt;)</span></span>: Provider&lt;List&lt;SubpluginOption&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> project = kotlinCompilation.target.project</span><br><span class="line">        <span class="keyword">return</span> project.provider &#123; emptyList() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此 Gradle 插件编写完成，是不是很简单😄</p>
<h3 id="plugin-kotlin"><a class="markdownIt-Anchor" href="#plugin-kotlin"></a> plugin-kotlin</h3>
<p>接下来编写 Kotlin 编译器插件，此插件对应 KCP 架构中的 <code>CommandLineProcessor</code> 、 <code>ComponentRegistrar</code> 和 <code>Extension</code></p>
<p>首先配置下 build.gradle.kts 脚本</p>
<h4 id="buildgradlekts-module-level-2"><a class="markdownIt-Anchor" href="#buildgradlekts-module-level-2"></a> build.gradle.kts - module level</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">&quot;jvm&quot;</span>)</span><br><span class="line">    kotlin(<span class="string">&quot;kapt&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;com.github.gmazzo.buildconfig&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 依赖 Kotlin 编译器库</span></span><br><span class="line">    compileOnly(<span class="string">&quot;org.jetbrains.kotlin:kotlin-compiler-embeddable&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖 Google auto service</span></span><br><span class="line">    kapt(<span class="string">&quot;com.google.auto.service:auto-service:1.0&quot;</span>)</span><br><span class="line">    compileOnly(<span class="string">&quot;com.google.auto.service:auto-service-annotations:1.0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildConfig &#123;</span><br><span class="line">    <span class="comment">// 配置 BuildConfig 的包名</span></span><br><span class="line">    packageName(<span class="string">&quot;com.guodong.android.mask.kcp.kotlin&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 Kotlin 插件唯一 ID</span></span><br><span class="line">    buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;KOTLIN_PLUGIN_ID&quot;</span>, <span class="string">&quot;\&quot;<span class="subst">$&#123;rootProject.extra[<span class="string">&quot;kotlin_plugin_id&quot;</span>]&#125;</span>\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType&lt;KotlinCompile&gt; &#123;</span><br><span class="line">    kotlinOptions.jvmTarget = <span class="string">&quot;1.8&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 KCP 架构，下面实现 <code>CommandLineProcessor</code></p>
<h4 id="maskcommandlineprocessor"><a class="markdownIt-Anchor" href="#maskcommandlineprocessor"></a> MaskCommandLineProcessor</h4>
<p>创建 <code>MaskCommandLineProcessor</code> 实现 <code>CommandLineProcessor</code> 接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService(CommandLineProcessor::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaskCommandLineProcessor</span> : <span class="type">CommandLineProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 Kotlin 插件唯一 ID</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> pluginId: String = BuildConfig.KOTLIN_PLUGIN_ID</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 `SubpluginOptions` 参数，并写入 `CliOption`</span></span><br><span class="line">    <span class="comment">// 本插件没有配置信息，返回空集合</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> pluginOptions: Collection&lt;AbstractCliOption&gt; = emptyList()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理 `CliOption` 写入 `CompilerConfiguration`</span></span><br><span class="line">    <span class="comment">// 本插件没有配置信息，此处没有实现</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">processOption</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        option: <span class="type">AbstractCliOption</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        value: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        configuration: <span class="type">CompilerConfiguration</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.processOption(option, value, configuration)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CommandLineProcessor</code> 编写完成</p>
<p>接下来实现 <code>ComponentRegistrar</code></p>
<h4 id="maskcomponentregistrar"><a class="markdownIt-Anchor" href="#maskcomponentregistrar"></a> MaskComponentRegistrar</h4>
<p>创建 <code>MaskComponentRegistrar</code> 实现 <code>ComponentRegistrar</code> 接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService(ComponentRegistrar::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaskComponentRegistrar</span> : <span class="type">ComponentRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerProjectComponents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        project: <span class="type">MockProject</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        configuration: <span class="type">CompilerConfiguration</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">// 获取日志收集器</span></span><br><span class="line">        <span class="keyword">val</span> messageCollector =</span><br><span class="line">            configuration.<span class="keyword">get</span>(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY, MessageCollector.NONE)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出日志，查看是否执行</span></span><br><span class="line">        <span class="comment">// CompilerMessageSeverity.INFO - 没有看到日志输出</span></span><br><span class="line">        <span class="comment">// CompilerMessageSeverity.ERROR - 编译过程停止执行</span></span><br><span class="line">        messageCollector.report(</span><br><span class="line">            CompilerMessageSeverity.WARNING,</span><br><span class="line">            <span class="string">&quot;Welcome to guodongAndroid mask kcp kotlin plugin&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处在 `ClassBuilderInterceptorExtension` 中注册扩展</span></span><br><span class="line">        ClassBuilderInterceptorExtension.registerExtension(</span><br><span class="line">            project,</span><br><span class="line">            MaskClassGenerationInterceptor(messageCollector)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后实现 <code>Extension</code></p>
<h4 id="maskclassgenerationinterceptor"><a class="markdownIt-Anchor" href="#maskclassgenerationinterceptor"></a> MaskClassGenerationInterceptor</h4>
<p>创建 <code>MaskClassGenerationInterceptor</code> 实现 <code>ClassBuilderInterceptorExtension</code> 接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaskClassGenerationInterceptor</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messageCollector: MessageCollector,</span><br><span class="line">) : ClassBuilderInterceptorExtension &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截 ClassBuilderFactory</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">interceptClassBuilderFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        interceptedFactory: <span class="type">ClassBuilderFactory</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        bindingContext: <span class="type">BindingContext</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        diagnostics: <span class="type">DiagnosticSink</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 自定义 ClassBuilderFactory 委托给 源ClassBuilderFactory</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: ClassBuilderFactory = <span class="keyword">object</span> : ClassBuilderFactory <span class="keyword">by</span> interceptedFactory &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复写 newClassBuilder，自定义 ClassBuilder</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newClassBuilder</span><span class="params">(origin: <span class="type">JvmDeclarationOrigin</span>)</span></span>: ClassBuilder &#123;</span><br><span class="line">            <span class="comment">// 传入源ClassBuilder</span></span><br><span class="line">            <span class="keyword">return</span> MaskClassBuilder(messageCollector, interceptedFactory.newClassBuilder(origin))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="maskclassbuilder"><a class="markdownIt-Anchor" href="#maskclassbuilder"></a> MaskClassBuilder</h4>
<p>创建 <code>MaskClassBuilder</code> 继承 <code>DelegatingClassBuilder</code>，实现 <code>getDelegate</code> 方法，复写 <code>newField</code> 和 <code>newMethod</code> 方法</p>
<h6 id="getdelegate"><a class="markdownIt-Anchor" href="#getdelegate"></a> getDelegate</h6>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaskClassBuilder</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messageCollector: MessageCollector,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> delegate: ClassBuilder</span><br><span class="line">) : DelegatingClassBuilder() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Hide注解的完全限定名(fully qualified name)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> annotations: List&lt;FqName&gt; = listOf(</span><br><span class="line">        FqName(<span class="string">&quot;com.guodong.android.mask.api.kt.Hide&quot;</span>),</span><br><span class="line">        FqName(<span class="string">&quot;com.guodong.android.mask.api.Hide&quot;</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回代理</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDelegate</span><span class="params">()</span></span>: ClassBuilder = delegate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="newfield"><a class="markdownIt-Anchor" href="#newfield"></a> newField</h6>
<p>处理 <code>@Hide</code> 注解目标为字段</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaskClassBuilder</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messageCollector: MessageCollector,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> delegate: ClassBuilder</span><br><span class="line">) : DelegatingClassBuilder() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Hide注解的完全限定名(fully qualified name)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> annotations: List&lt;FqName&gt; = listOf(</span><br><span class="line">        FqName(<span class="string">&quot;com.guodong.android.mask.api.kt.Hide&quot;</span>),</span><br><span class="line">        FqName(<span class="string">&quot;com.guodong.android.mask.api.Hide&quot;</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newField</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        origin: <span class="type">JvmDeclarationOrigin</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        access: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        desc: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        signature: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        value: <span class="type">Any</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: FieldVisitor &#123;</span><br><span class="line">        <span class="comment">// 判断描述符是否是字段</span></span><br><span class="line">        <span class="keyword">val</span> field = origin.descriptor <span class="keyword">as</span>? FieldDescriptor</span><br><span class="line">        	?: <span class="keyword">return</span> <span class="keyword">super</span>.newField(origin, access, name, desc, signature, value)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断字段上是否有`@Hide`注解</span></span><br><span class="line">        <span class="keyword">if</span> (annotations.none &#123; field.annotations.hasAnnotation(it) &#125;) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.newField(origin, access, name, desc, signature, value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出字段源访问标志</span></span><br><span class="line">        messageCollector.report(</span><br><span class="line">            CompilerMessageSeverity.WARNING,</span><br><span class="line">            <span class="string">&quot;Mask Class = <span class="subst">$&#123;delegate.thisName&#125;</span>, fieldName = <span class="variable">$name</span>, originalAccess = <span class="variable">$access</span>&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加`ACC_SYNTHETIC`标识</span></span><br><span class="line">        <span class="keyword">val</span> maskAccess = access + Opcodes.ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出字段Mask后访问标志</span></span><br><span class="line">        messageCollector.report(</span><br><span class="line">            CompilerMessageSeverity.WARNING,</span><br><span class="line">            <span class="string">&quot;Mask Class = <span class="subst">$&#123;delegate.thisName&#125;</span>, fieldName = <span class="variable">$name</span>, maskAccess = <span class="variable">$maskAccess</span>&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传入Mask后访问标志</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.newField(origin, maskAccess, name, desc, signature, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="newmethod"><a class="markdownIt-Anchor" href="#newmethod"></a> newMethod</h6>
<p>处理 <code>@Hide</code> 注解目标为方法/函数，处理逻辑与字段类似</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    origin: <span class="type">JvmDeclarationOrigin</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    access: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    desc: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    signature: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    exceptions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: MethodVisitor &#123;</span><br><span class="line">    <span class="comment">// 判断是否是方法/函数描述符</span></span><br><span class="line">    <span class="keyword">val</span> function = origin.descriptor <span class="keyword">as</span>? FunctionDescriptor</span><br><span class="line">    	?: <span class="keyword">return</span> <span class="keyword">super</span>.newMethod(origin, access, name, desc, signature, exceptions)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断方法/函数上是否有`@Hide`注解</span></span><br><span class="line">    <span class="keyword">if</span> (annotations.none &#123; function.annotations.hasAnnotation(it) &#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.newMethod(origin, access, name, desc, signature, exceptions)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出方法/函数源访问标志</span></span><br><span class="line">    messageCollector.report(</span><br><span class="line">        CompilerMessageSeverity.WARNING,</span><br><span class="line">        <span class="string">&quot;Mask Class = <span class="subst">$&#123;delegate.thisName&#125;</span>, methodName = <span class="variable">$name</span>, originalAccess = <span class="variable">$access</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加`ACC_SYNTHETIC`标识</span></span><br><span class="line">    <span class="keyword">val</span> maskAccess = access + Opcodes.ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出方法/函数Mask后访问标志</span></span><br><span class="line">    messageCollector.report(</span><br><span class="line">        CompilerMessageSeverity.WARNING,</span><br><span class="line">        <span class="string">&quot;Mask Class = <span class="subst">$&#123;delegate.thisName&#125;</span>, methodName = <span class="variable">$name</span>, maskAccess = <span class="variable">$maskAccess</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入Mask后访问标志</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.newMethod(origin, maskAccess, name, desc, signature, exceptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此 Kotlin 编译器插件完成:happy:</p>
<h2 id="应用kcp"><a class="markdownIt-Anchor" href="#应用kcp"></a> 应用KCP</h2>
<h3 id="buildgradle-project-level-2"><a class="markdownIt-Anchor" href="#buildgradle-project-level-2"></a> build.gradle - project level</h3>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.plugin_version = <span class="string">&#x27;x.x.x&#x27;</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;com.guodong.android:mask-kcp-gradle-plugin:$&#123;plugin_version&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lib-kotlinbuildgradle-module-level"><a class="markdownIt-Anchor" href="#lib-kotlinbuildgradle-module-level"></a> lib-kotlin/build.gradle - module level</h3>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"># lib-kotlin</span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;maven-publish&#x27;</span></span><br><span class="line">    <span class="comment">// id &#x27;com.guodong.android.mask&#x27; // use kcp</span></span><br><span class="line">    id <span class="string">&#x27;com.guodong.android.mask.kcp&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lib-kotlin"><a class="markdownIt-Anchor" href="#lib-kotlin"></a> lib-kotlin</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用api-kt中的注解</span></span><br><span class="line">    <span class="meta">@Hide</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testInterface</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KotlinTest</span>(a: <span class="built_in">Int</span>) : InterfaceTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用api-kt中的注解</span></span><br><span class="line">    <span class="meta">@Hide</span></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newKotlinTest</span><span class="params">()</span></span> = KotlinTest()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding: LayoutKotlinTestBinding? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用api-kt中的注解</span></span><br><span class="line">    <span class="keyword">var</span> a = a</span><br><span class="line">        <span class="meta">@Hide</span> <span class="keyword">get</span></span><br><span class="line">        <span class="meta">@Hide</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getA1</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        a = <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">testInterface</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Interface function test&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="app"><a class="markdownIt-Anchor" href="#app"></a> app</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># MainActivity.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testKotlinLib</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建对象时不能访问无参构造方法，可以访问有参构造方法或访问静态工厂方法</span></span><br><span class="line">    <span class="type">KotlinTest</span> <span class="variable">test</span> <span class="operator">=</span> KotlinTest.newKotlinTest();</span><br><span class="line">    <span class="comment">// 调用时不能访问`test.getA()`方法，仅能访问`getA1()方法</span></span><br><span class="line">    Log.e(TAG, <span class="string">&quot;testKotlinLib: before --&gt; &quot;</span> + test.getA1());</span><br><span class="line">    test.test();</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;testKotlinLib: after --&gt; &quot;</span> + test.getA1());</span><br><span class="line">    </span><br><span class="line">    test.testInterface();</span><br><span class="line">    </span><br><span class="line">    <span class="type">InterfaceTest</span> <span class="variable">interfaceTest</span> <span class="operator">=</span> test;</span><br><span class="line">    <span class="comment">// Error - cannot resolve method &#x27;testInterface&#x27; in &#x27;InterfaceTest&#x27;</span></span><br><span class="line">    interfaceTest.testInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>happy:happy:</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>[Writing Your First Kotlin Compiler Plugin (<a href="http://jetbrains.com">jetbrains.com</a>)](<a href="https://resources.jetbrains.com/storage/products/kotlinconf2018/slides/5_Writing">https://resources.jetbrains.com/storage/products/kotlinconf2018/slides/5_Writing</a> Your First Kotlin Compiler Plugin.pdf) <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>kotlin</tag>
        <tag>kcp</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-协程为线程框架而生？</title>
    <url>/2022/05/29/Kotlin/Kotlin-%E5%8D%8F%E7%A8%8B%E4%B8%BA%E7%BA%BF%E7%A8%8B%E6%A1%86%E6%9E%B6%E8%80%8C%E7%94%9F%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="kotlin-协程为线程框架而生"><a class="markdownIt-Anchor" href="#kotlin-协程为线程框架而生"></a> Kotlin-协程为线程框架而生？</h1>
<p>持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第 1 天，<a href="https://juejin.cn/post/7099702781094674468">点击查看活动详情</a></p>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>笔者在开始学习 Kotlin 协程时，在网上经常看到 “Kotlin 协程是一种线程框架” 这种说法，当时认为这种说法好牛逼，协程比线程更厉害，性能肯定比线程更好，此一时彼一时，现在我对这种说法不敢苟同。</p>
<h2 id="为线程框架而生"><a class="markdownIt-Anchor" href="#为线程框架而生"></a> 为线程框架而生？</h2>
<p>这里不妨再问一下，何为框架？我们一直在说的各种开发框架，甚至自己开发一个框架，比如在 Android 中使用 MVP + Retrofit 搭建开发框架，可能我们更多关注使用框架，而忽略了什么是框架。</p>
<blockquote>
<p>在<a href="https://en.wikipedia.org/wiki/Computer_programming">计算机编程</a>中，<strong>软件框架</strong>是一种<a href="https://en.wikipedia.org/wiki/Abstraction_(computer_science)">抽象</a>，其中提供通用功能<a href="https://en.wikipedia.org/wiki/Software">的软件</a>可以通过其他用户编写的代码有选择地更改，从而提供特定于应用程序的软件。它提供了一种构建和部署应用程序的标准方法，并且是一个通用的、可重用<a href="https://en.wikipedia.org/wiki/Software_environment_(disambiguation)">的软件环境</a>，它提供特定功能作为更大<a href="https://en.wikipedia.org/wiki/Software_platform">软件平台</a>的一部分，以促进<a href="https://en.wikipedia.org/wiki/Software_application">软件应用程序</a>、产品和解决方案的开发。软件框架可能包括支持程序、编译器、代码库、工具集和<a href="https://en.wikipedia.org/wiki/Application_programming_interface">应用程序编程接口 （API</a>），它们将所有不同的<a href="https://en.wikipedia.org/wiki/Software_component">组件</a>组合在一起，以实现<a href="https://en.wikipedia.org/wiki/Software_project">项目</a>或<a href="https://en.wikipedia.org/wiki/Software_system">系统的</a>开发。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
</blockquote>
<p>以上对「软件框架」的描述摘自维基百科，是不是感到比较模糊，这啥？</p>
<p>对每个人来说，对框架的理解、划分都是不一样的，或许我们认为 OkHttp 是一个网络请求框架，Retrofit 基于 OkHttp 也是一个框架，Android 系统也是一个框架。</p>
<p>框架有大有小，但总的来说，框架是一种半成品，为了实现某种功能，提供一些基础通用的组件，比如 Android 为开发者提供 SDK 开发工具包，我们可以利用 SDK 开发自己的 App，实现自己的业务逻辑。</p>
<p>哪什么是线程框架呢？对线程框架的理解，也是仁者见仁，智者见智，或许你认为 <code>Executor</code> 是一种线程框架，在使用时不用关心什么时候启动线程，线程什么时候结束，只要执行 <code>execute</code> 即可，或许你认为 RxJava 也是一种线程框架，在使用时可以使用操作符方便的切换线程。</p>
<p>上述举例的 <code>Executor</code> 和 <code>RxJava</code>  有个共同点：它们都可以切线程，那我们是不是可以理解为：能切线程就是线程框架呢？我如果问你 <code>Handler</code> 也能切线程，你认为 <code>Handler</code> 也是线程框架么？</p>
<p><code>Handler</code> 的作用是什么？ <code>Handler</code> 主要用于消息处理，消息可能来自主线程，也可能来自子线程，来自子线程时，势必涉及线程之间的切换，所以笔者认为 <code>Handler</code> 不是线程框架，而是一个消息处理框架，只是提供了切线程的方法。</p>
<p>回过头来，我们再看 Kotlin 协程的作用是什么，或者说 Kotlin 协程用来解决什么问题。笔者认为 Kotlin 协程可以用来解决回调地狱，把异步调用写成同步调用的形式，一种异步转同步的编程思想，而异步调用可能涉及线程切换，正好 Kotlin 协程提供了切线程的方法。</p>
<p>说到异步调用，你不切线程咋异步调用呢？想想在 Android 中，你在 <code>Activity#onResume</code> 中使用 <code>handlper.post</code> 一个 <code>Runnable</code>， 这个 <code>Runnable</code> 的执行有切换线程么？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    handler.post &#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Kotlin协程是一个回调框架，它可以使异步代码同步化，同时提供结构化并发的特性，使并发代码简洁化，同时也提供了切换线程的能力，方便写出高效的异步和并发代码。</p>
<h2 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h2>
<p>以上为笔者个人见解，仁者见仁，智者见智，大家可以求同存异，同时笔者水平有限，如有错误之处，欢迎交流。</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Software_framework">软件框架</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>kotlin</tag>
        <tag>coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-回调如何转成挂起函数</title>
    <url>/2022/05/31/Kotlin/Kotlin-%E5%9B%9E%E8%B0%83%E5%A6%82%E4%BD%95%E8%BD%AC%E6%88%90%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="kotlin-回调如何转成挂起函数"><a class="markdownIt-Anchor" href="#kotlin-回调如何转成挂起函数"></a> Kotlin-回调如何转成挂起函数</h1>
<p>持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第 9 天，<a href="https://juejin.cn/post/7099702781094674468">点击查看活动详情</a></p>
<hr />
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>笔者在项目中开始使用 Kotlin 时还是 Java 和 Kotlin 混合的项目，所以对于一些 Java 库提供的回调接口，再使用 Java 的方式调用感觉使用了假的 Kotlin。</p>
<p>本文记录下笔者在使用 Kotlin 过程中，把 Java 回调转成挂起函数的过程，不止是 Java 回调，Kotlin 回调也是可以的。</p>
<h2 id="单一回调方法"><a class="markdownIt-Anchor" href="#单一回调方法"></a> 单一回调方法</h2>
<p>单一回调方法是最容易转成挂起函数的，以 Android 中常见的点击事件接口为例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义的View，代表Android中的View</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">View</span>(<span class="keyword">val</span> viewId: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的OnClickListener，代表Android中的OnClickListener</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> OnClickListener &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的setOnClickListener，代表Android View中的setOnClickListener</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(listener: <span class="type">OnClickListener</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 启动一个线程</span></span><br><span class="line">    thread &#123;</span><br><span class="line">        <span class="comment">// 睡眠2秒</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用回调方法</span></span><br><span class="line">        listener.onClick(View(-<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是对 Android 中点击事件的抽象，正常情况下，我们应该是以下面的形式调用 <code>setOnClickListener</code> 方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    setOnClickListener &#123; view -&gt;</span><br><span class="line">        view.viewId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们怎么把 <code>setOnClickListener</code> 方法转成挂起函数呢？就是使用 Kotlin  提供的 <code>suspendCoroutine</code> 方法，<code>suspendCoroutine</code> 方法可以帮我们拿到当前协程的 <code>Continuation</code> 实例，笔者在 <a href="https://juejin.cn/post/7103543028316373005">Kotlin-挂起函数挂起了啥？</a> 中简单介绍了 <code>suspendCoroutine</code> 的实现。</p>
<p>下面让我们把回调转成挂起函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListenerSuspend</span><span class="params">()</span></span>: View &#123;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        setOnClickListener &#123; view -&gt;</span><br><span class="line">            continuation.resume(view)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先声明挂起方法 <code>setOnClickListenerSuspend</code> 返回值为回调方法中的入参类型 View，接着写挂起函数的方法体，直接调用 <code>suspendCoroutine</code> 返回，在 <code>suspendCoroutine</code> 的 block 中调用原来的 <code>setOnClickListener</code> 传入回调，最后在回调中调用 <code>Continuation#resume</code> 函数传入回调方法的View 类型的入参。</p>
<p>这样就完成了单一回调方法转成挂起函数，我们调用下试试，与原来回调的方式对比一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main方法增加suspend关键字</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调的方式</span></span><br><span class="line">    setOnClickListener &#123; view -&gt;</span><br><span class="line">        view.viewId</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起函数的方式</span></span><br><span class="line">    <span class="keyword">val</span> view = setOnClickListenerSuspend()</span><br><span class="line">    view.viewId</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过 <code>suspendCoroutine</code> 把单一回调方法转成了挂起函数，与原来回调的方式相比，代码顺序上是挂起函数是同步调用的形式，看起来更直观一些。</p>
<h2 id="两个回调方法"><a class="markdownIt-Anchor" href="#两个回调方法"></a> 两个回调方法</h2>
<p>两个回调方法我们常见的是 OkHttp 中的网络请求回调：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Response</span>(<span class="keyword">val</span> value: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(e: <span class="type">IOException</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(response: <span class="type">Response</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendRequest</span><span class="params">(callback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">    thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callback.onResponse(Response(<span class="string">&quot;gudongAndroid&quot;</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            callback.onFailure(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常情况下我们调用应该是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    sendRequest(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">            println(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            println(response.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>object</code> 关键字构造回调的匿名类然后传入 <code>sendRequest</code> 方法，现在我们仍然可以使用 <code>suspendCoroutine</code> 方法把 <code>sendRequest</code> 方法转成挂起函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendRequestSuspend</span><span class="params">()</span></span> = suspendCoroutine&lt;Response&gt; &#123; continuation -&gt;</span><br><span class="line">    sendRequest(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">            continuation.resumeWithException(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            continuation.resume(response)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onFailure</code> 方法中调用 <code>Continuation#resumeWithException</code> 函数抛出异常，在 <code>onResponse</code> 方法中还是调用 <code>Continuation#resume</code> 函数传入结果，我们对比下前后使用上的差异：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调的方式</span></span><br><span class="line">    sendRequest(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">            println(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            println(response.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起函数的方式</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> response = sendRequestSuspend()</span><br><span class="line">        println(response.value)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        println(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用挂起函数的方式，<code>Continuation#resumeWithException</code> 函数抛出的异常一般使用 <code>try catch</code> 捕获异常，调用方可以根据异常类型进行不同的处理逻辑。</p>
<h2 id="多个回调方法"><a class="markdownIt-Anchor" href="#多个回调方法"></a> 多个回调方法</h2>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>kotlin</tag>
        <tag>coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-挂起函数挂起了啥？</title>
    <url>/2022/05/30/Kotlin/Kotlin-%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0%E6%8C%82%E8%B5%B7%E4%BA%86%E5%95%A5%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="kotlin-挂起函数挂起了啥"><a class="markdownIt-Anchor" href="#kotlin-挂起函数挂起了啥"></a> Kotlin-挂起函数挂起了啥？</h1>
<p>持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第 2 天，<a href="https://juejin.cn/post/7099702781094674468">点击查看活动详情</a></p>
<hr />
<p>不瞒各位，笔者在刚开始学习 Kotlin 协程的时候看到挂起函数总是想到阻塞线程，为啥呀？因为从表面上看，执行挂起函数的时候，后面的代码就不执行了，并且大部分挂起函数都是耗时的，这与在线程中执行耗时操作会阻塞线程类似，举个栗子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 挂起函数前的代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    println(<span class="string">&quot;1:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>) <span class="comment">// ① 标记1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行挂起函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 挂起函数后的代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    println(<span class="string">&quot;2:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>) <span class="comment">// ② 标记2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 ① 和 ② 的输出结果来看，代码的确间隔 1 秒钟执行，从代码顺序上看，<code>delay(1000)</code> 怎么看都是阻塞了线程 1 秒钟，类似 Java 中的 <code>Thread.sleep(1000)</code> ，这看起来不就是阻塞执行了么？</p>
<p>看到这里，相信不少读者已经迷糊了，Kotlin 协程不是非阻塞的么？上面代码看起来是阻塞的啊。</p>
<h2 id="何为阻塞"><a class="markdownIt-Anchor" href="#何为阻塞"></a> 何为阻塞</h2>
<p>欸，别慌，先搞明白阻塞是什么，阻塞的对象是谁？</p>
<p>阻塞对比现实世界的例子比较好理解，比如去超市购物结账时：</p>
<ul>
<li>你结账的窗口扫码枪坏了，结不了账（发生阻塞）</li>
<li>等到换个新的扫码枪才能结账（阻塞恢复）</li>
</ul>
<p>现在看看阻塞的是谁呢？阻塞的就是这个结账窗口（线程），没错，阻塞的是线程。</p>
<p>阻塞不阻塞是针对当前线程来说的，去别的线程执行，自然不会阻塞当前线程，比如上述结账，你可以去其他窗口进行结账。</p>
<p>回过头看上面的代码例子，无论是从代码执行顺序还是代码执行结果上看，都像是阻塞执行，我们看看下面这个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;1:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>) <span class="comment">// ① 标记1</span></span><br><span class="line">    handler.postDelayed(&#123;</span><br><span class="line">        println(<span class="string">&quot;2:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>) <span class="comment">// ② 标记2          </span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Android 开发同学看见 Handler 应该很熟悉了，对比这两个代码示例，从代码执行顺序还是代码执行结果上是否是一样的呢？或许我们应该看看 <code>delay</code> 的源码了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(timeMillis: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeMillis &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="comment">// don&#x27;t delay</span></span><br><span class="line">    <span class="keyword">return</span> suspendCancellableCoroutine <span class="symbol">sc@</span> &#123; cont: CancellableContinuation&lt;<span class="built_in">Unit</span>&gt; -&gt;</span><br><span class="line">        <span class="comment">// if timeMillis == Long.MAX_VALUE then just wait forever like awaitCancellation, don&#x27;t schedule.</span></span><br><span class="line">        <span class="keyword">if</span> (timeMillis &lt; <span class="built_in">Long</span>.MAX_VALUE) &#123;</span><br><span class="line">            cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)</code> 这个操作，和 <code>handler.postDelay()</code> 类似，本质上是设置一个延时的回调，时间到了就调用 <code>cont</code> 的 resume 等方法让协程恢复。</p>
<h2 id="kotlin-协程的非阻塞体现在哪呢"><a class="markdownIt-Anchor" href="#kotlin-协程的非阻塞体现在哪呢"></a> Kotlin 协程的非阻塞体现在哪呢？</h2>
<p>上面我们已经知道阻塞的对象是线程，线程是在 CPU 里执行的，所以可以说阻塞的对象也是 CPU，而 Kotlin 协程的非阻塞只是语言层面的，不是操作系统层面的阻塞，说明在协程中调用阻塞的方法，比如 <code>Thread.sleep()</code> 的时候，协程仍然是阻塞的。</p>
<p>Kotlin 协程的非阻塞是与线程阻塞相比较的，比如我们调用 <code>Thread.sleep()</code> 休眠线程达到延迟的效果，协程则可以使用 <code>delay()</code> 挂起同样达到延迟效果。</p>
<h2 id="那挂起函数挂起了啥"><a class="markdownIt-Anchor" href="#那挂起函数挂起了啥"></a> 那挂起函数挂起了啥？</h2>
<p>首先我们需要知道，协程在哪里挂起的，针对第一个代码示例，可以看出来，协程在 <code>delay(1000)</code> 处挂起，那它挂起了什么？</p>
<p>我们不妨想一下，在酒店点菜时的挂起，客人点了一份菜单，但是告知现在不能开始做，等半小时后再开始做，这时候我们可以在系统中先录入这份菜单，点击挂起，输入挂起时长保存，等挂起时长到了，系统自动把菜单发给后厨，后厨开始做菜。</p>
<p>上面酒店点菜的示例，和 <code>delay()</code> 的效果类似，都是延迟触发后续的逻辑。在点菜示例中挂起的什么？是菜单还是做菜动作？这里笔者认为是做菜的动作，而菜单认为是挂起点，即从菜单挂起，也从菜单恢复，对应第一个代码示例，既从 <code>delay(1000)</code> 处挂起，也从 <code>delay(1000)</code> 处恢复，挂起的是 <code>delay(1000)</code> 之后要执行的代码，或者说挂起了协程恢复后要执行的代码，即 ② 处代码。</p>
<p>现在还有 <code>suspendCancellableCoroutine</code> 比较神秘，我们看下它的源码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCancellableCoroutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">crossinline</span> block: (<span class="type">CancellableContinuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: T =</span><br><span class="line">    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class="line">        <span class="keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)</span><br><span class="line">        cancellable.initCancellability()</span><br><span class="line">        block(cancellable)</span><br><span class="line">        cancellable.getResult()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>suspendCoroutineUninterceptedOrReturn</code> 这个方法的源码是看不到的，它本身就没有源码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCoroutineUninterceptedOrReturn</span><span class="params">(<span class="keyword">crossinline</span> block: (<span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Any</span>?)</span></span>: T &#123;</span><br><span class="line">    contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125;</span><br><span class="line">    <span class="keyword">throw</span> NotImplementedError(<span class="string">&quot;Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的作用就是帮我们拿到当前协程的 <code>Continuation</code> 实例，不过我通过翻阅 Kotlin 源码（搜索 <code>suspendCoroutineUninterceptedOrReturn</code> 关键字）找到了以下代码，笔者认为下图<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>中代码就是具体的实现，代码中的注释，正好对应源码中的 <code>block</code>、<code>Continuation</code>:</p>
<p><img data-src="https://guodongandroid.coding.net/p/typora/d/typora/git/raw/master/img/202205301732755.png" alt="image-20220530173205836" /></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Kotlin 协程的挂起函数挂起了啥，可以理解为挂起的是挂起函数恢复之后要执行的逻辑。</p>
<h2 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h2>
<p>以上为笔者个人见解，仁者见仁，智者见智，大家可以求同存异，同时笔者水平有限，如有不同见解，欢迎交流。</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://github.com/JetBrains/kotlin/blob/8cb9a5ff67ce2a1ff1343ce211453bb10fc885c2/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/coroutineCodegenUtil.kt">Kotlin-coroutineCodegenUtil.kt</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>kotlin</tag>
        <tag>coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>linphone-sdk-android版本号生成分析</title>
    <url>/2022/09/16/linphone-sdk-android/linphone-sdk-android%E7%89%88%E6%9C%AC%E5%8F%B7%E7%94%9F%E6%88%90%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="linphone-sdk-android版本号生成分析"><a class="markdownIt-Anchor" href="#linphone-sdk-android版本号生成分析"></a> linphone-sdk-android版本号生成分析</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>好久没写 <code>linphone-sdk-android</code> 相关的文章了，本文记录下笔者分析 <code>linphone-sdk</code> 版本号生成的过程。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<blockquote>
<p>注：以下源码基于 linphone-sdk-android 4.5.26。</p>
</blockquote>
<p>修改完 <code>linphone-sdk</code> 的源码后总是要编译的，编译完成后我们就可以得到一个带有版本号的 <code>aar</code> 包，那么这个版本号是从哪里来的呢？</p>
<h3 id="编译产物"><a class="markdownIt-Anchor" href="#编译产物"></a> 编译产物</h3>
<p>首先看下编译完成后 <code>build</code> 目录下的产物，会发现有两个 <code>gradle</code> 脚本文件：<code>build.gradle</code> 和 <code>upload.gradle</code>，打开 <code>upload.gradle</code> 脚本文件，在里面发现如下代码：<code>println(&quot;AAR artefact group is: &quot; + artefactGroupId + &quot;, SDK version 4.5.27&quot;)</code>，其中 <code>4.5.27</code> 就是 <code>linphone-sdk</code> 的版本号。</p>
<p>根据前面文章的分析，编译产物一般是自动生成的，所以笔者在 <code>linphone-sdk</code> 目录下搜索 <code>upload.gradle</code> ：<code>find . -name '*upload.gradle*'</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cmake/Android/gradle/upload.gradle.cmake</span><br><span class="line">./build/upload.gradle</span><br></pre></td></tr></table></figure>
<p>果然找到了，其中第2行是笔者刚才打开的文件，找到并打开第1行的文件 <code>upload.gradle.cmake</code>，与第2行的文件对比，发现前者就是后者的模板文件，在 <code>upload.gradle.cmake</code> 文件中发现：<code>println(&quot;AAR artefact group is: &quot; + artefactGroupId + &quot;, SDK version @LINPHONESDK_VERSION@&quot;)</code>，其中 <code>@LINPHONESDK_VERSION@</code> 就是 <code>linphone-sdk</code> 的版本号了。因为此文件后缀是 <code>.cmake</code>，那么联想 <code>@LINPHONESDK_VERSION@</code> 应该是个 cmake 参数。</p>
<p>接下来在 <code>linphone-sdk</code> 目录下搜索包含 <code>LINPHONESDK_VERSION</code> 字样的文件：<code>find . -type f | xargs grep 'LINPHONESDK_VERSION'</code>，本次查找结果较多，就不贴出来了，经过笔者的对比分析，锁定了最后一行结果：<code>./CMakeLists.txt:bc_compute_full_version(LINPHONESDK_VERSION)</code>。</p>
<h3 id="cmake"><a class="markdownIt-Anchor" href="#cmake"></a> CMake</h3>
<p>打开 <code>./CMakeLists.txt</code>，在前几行就可以找到如下代码：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(bctoolbox/cmake/BcToolboxCMakeUtils.cmake)</span><br><span class="line">bc_compute_full_version(LINPHONESDK_VERSION)</span><br></pre></td></tr></table></figure>
<p>其中第2行代码 <code>bc_compute_full_version</code> 就是计算 <code>linphone-sdk</code> 版本号的函数，其定义在第1行代码中的 <code>BcToolboxCMakeUtils.cmake</code> 中，打开 <code>BcToolboxCMakeUtils.cmake</code> 文件并找到 <code>bc_compute_full_version</code> 函数：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(bc_compute_full_version OUTPUT_VERSION)</span><br><span class="line">	<span class="comment"># 查找 Git 程序</span></span><br><span class="line">	<span class="keyword">find_program</span>(GIT_EXECUTABLE git NAMES Git CMAKE_FIND_ROOT_PATH_BOTH)</span><br><span class="line">	<span class="comment"># 如果找到 Git 程序</span></span><br><span class="line">	<span class="keyword">if</span>(GIT_EXECUTABLE)</span><br><span class="line">		<span class="comment"># 执行 git describe 命令</span></span><br><span class="line">		<span class="keyword">execute_process</span>(</span><br><span class="line">			<span class="keyword">COMMAND</span> <span class="string">&quot;$&#123;GIT_EXECUTABLE&#125;&quot;</span> <span class="string">&quot;describe&quot;</span></span><br><span class="line">			OUTPUT_VARIABLE GIT_DESCRIBE_VERSION</span><br><span class="line">			OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">			ERROR_QUIET</span><br><span class="line">			WORKING_DIRECTORY <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span></span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># parse git describe version</span></span><br><span class="line">		<span class="comment"># 解析 git describe 的返回值作为版本号, 通过正则表达式的分组匹配进行解析：4.5.26-alpha-9-gb342a93</span></span><br><span class="line">		<span class="comment"># 如果没有解析到, 输出错误信息</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">NOT</span> (GIT_DESCRIBE_VERSION <span class="keyword">MATCHES</span> <span class="string">&quot;^([0-9]+)[.]([0-9]+)[.]([0-9]+)(-alpha|-beta)?(-[0-9]+)?(-g[0-9a-f]+)?$&quot;</span>))</span><br><span class="line">			<span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;invalid git describe version: &#x27;$&#123;GIT_DESCRIBE_VERSION&#125;&#x27;&quot;</span>)</span><br><span class="line">		<span class="keyword">endif</span>()</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 设置分组1为主要版本: ([0-9]+) -&gt; 4</span></span><br><span class="line">		<span class="keyword">set</span>(version_major <span class="variable">$&#123;CMAKE_MATCH_1&#125;</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 设置分组2为次要版本: ([0-9]+) -&gt; 5</span></span><br><span class="line">		<span class="keyword">set</span>(version_minor <span class="variable">$&#123;CMAKE_MATCH_2&#125;</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 设置分组3为补丁版本: ([0-9]+) -&gt; 26</span></span><br><span class="line">		<span class="keyword">set</span>(version_patch <span class="variable">$&#123;CMAKE_MATCH_3&#125;</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 如果解析到分组4: (-alpha|-beta)? -&gt; -alpha, 则去掉前面的‘-’, 得到后面的‘alpha|beta’, 赋值给 version_prerelease</span></span><br><span class="line">		<span class="keyword">if</span> (CMAKE_MATCH_4)</span><br><span class="line">			<span class="keyword">string</span>(SUBSTRING <span class="string">&quot;$&#123;CMAKE_MATCH_4&#125;&quot;</span> <span class="number">1</span> -<span class="number">1</span> version_prerelease)</span><br><span class="line">		<span class="keyword">endif</span>()</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 如果解析到分组5：(-[0-9]+)? -&gt; -9, 则去掉前面的‘-’, 得到后面的‘9’, 赋值给 version_commit</span></span><br><span class="line">		<span class="keyword">if</span> (CMAKE_MATCH_5)</span><br><span class="line">			<span class="keyword">string</span>(SUBSTRING <span class="string">&quot;$&#123;CMAKE_MATCH_5&#125;&quot;</span> <span class="number">1</span> -<span class="number">1</span> version_commit)</span><br><span class="line">		<span class="keyword">endif</span>()</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 如果解析到分组6: (-g[0-9a-f]+)? -&gt; -gb342a93, 则去掉前面的‘-g’, 得到后面的‘b342a93’, 赋值给 version_hash</span></span><br><span class="line">		<span class="keyword">if</span> (CMAKE_MATCH_6)</span><br><span class="line">			<span class="keyword">string</span>(SUBSTRING <span class="string">&quot;$&#123;CMAKE_MATCH_6&#125;&quot;</span> <span class="number">2</span> -<span class="number">1</span> version_hash)</span><br><span class="line">		<span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">		<span class="comment"># interpret untagged hotfixes as pre-releases of the next &quot;patch&quot; release</span></span><br><span class="line">		<span class="comment"># 如果没有 version_prerelease, 但是有 version_commit, 认为是此补丁程序是下一个补丁版本的预发版本, 即将补丁版本号+1</span></span><br><span class="line">		<span class="comment"># 并设置 version_prerelease 为 &quot;pre&quot;</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">NOT</span> version_prerelease <span class="keyword">AND</span> version_commit)</span><br><span class="line">			<span class="keyword">math</span>(EXPR version_patch <span class="string">&quot;$&#123;version_patch&#125; + 1&quot;</span>)</span><br><span class="line">			<span class="keyword">set</span>(version_prerelease <span class="string">&quot;pre&quot;</span>)</span><br><span class="line">		<span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">		<span class="comment"># format full version</span></span><br><span class="line">		<span class="comment"># 拼接主、次、补丁版本号</span></span><br><span class="line">		<span class="keyword">set</span>(full_version <span class="string">&quot;$&#123;version_major&#125;.$&#123;version_minor&#125;.$&#123;version_patch&#125;&quot;</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 如果有 version_prerelease</span></span><br><span class="line">		<span class="keyword">if</span> (version_prerelease)</span><br><span class="line">			<span class="comment"># 版本号追加 &quot;-pre&quot;</span></span><br><span class="line">			<span class="keyword">string</span>(APPEND full_version <span class="string">&quot;-$&#123;version_prerelease&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment"># 如果有 version_commit</span></span><br><span class="line">			<span class="keyword">if</span> (version_commit)</span><br><span class="line">				<span class="comment"># 版本号追加 &quot;.9+b342a93&quot;</span></span><br><span class="line">				<span class="keyword">string</span>(APPEND full_version <span class="string">&quot;.$&#123;version_commit&#125;+$&#123;version_hash&#125;&quot;</span>)</span><br><span class="line">			<span class="keyword">endif</span>()</span><br><span class="line">		<span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 省略其他检查逻辑</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># 设置版本号为CMake缓存参数, 完整版本号: 4.5.27-pre.9+b342a93</span></span><br><span class="line">		<span class="keyword">set</span>(<span class="variable">$&#123;OUTPUT_VERSION&#125;</span> <span class="string">&quot;$&#123;full_version&#125;&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">	<span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>
<p>下面就是分析 <code>bc_compute_full_version</code> 函数了。</p>
<p>首先查找 <code>Git</code> 程序，如果找到 <code>Git</code> 程序，函数才会继续，否则无法计算版本号。</p>
<p>找到 <code>Git</code> 程序后会执行 <code>git describe</code> 命令，此命令会基于当前可用的 ref 给一个人类可读的名称。</p>
<ul>
<li>
<p>如果当前最新的 commit 上有 TAG，且 TAG 必须有描述信息或者带有 <code>-- tags</code> 参数，此命令则返回此 TAG 名称：4.5.26，</p>
</li>
<li>
<p>否则返回离当前最近的 TAG 名称 + 此 TAG 之后的提交次数 + 当前的 commit hash 值前 7 位：4.5.26-9-gb342a93，其中 ‘g’ 表示是 <code>Git</code>，</p>
</li>
<li>
<p>具体可查看 <a href="https://git-scm.com/docs/git-describe">git-describe</a>。</p>
</li>
</ul>
<p>假设 <code>git describe</code> 命令返回的是：<code>4.5.26-alpha-9-gb342a93</code>，接下来通过正则表达式的分组匹配解析返回的结果。</p>
<p>正则表达式：<code>^([0-9]+)[.]([0-9]+)[.]([0-9]+)(-alpha|-beta)?(-[0-9]+)?(-g[0-9a-f]+)?$</code>，其分为以下 6 组：</p>
<ol>
<li><code>([0-9]+)</code> 为第一组 <code>CMAKE_MATCH_1</code>，对应 4，</li>
<li><code>([0-9]+)</code> 为第二组 <code>CMAKE_MATCH_2</code>，对应 5，</li>
<li><code>([0-9]+)</code> 为第三组 <code>CMAKE_MATCH_3</code>，对应 26，</li>
<li><code>(-alpha|-beta)?</code> 为第四组 <code>CMAKE_MATCH_4</code>，可为空，对应 -alpha，</li>
<li><code>(-[0-9]+)?</code> 为第五组 <code>CMAKE_MATCH_5</code>，可为空，对应 -9，</li>
<li><code>(-g[0-9a-f]+)?</code> 为第六组 <code>CMAKE_MATCH_6</code>，可为空，对应 gb342a93，</li>
</ol>
<p>分组一、分组二和分组三分别作为主要版本、次要版本和补丁版本：4.5.26。</p>
<p>如果解析到分组四:  <code>-alpha</code>，则去掉前面的 <code>-</code>，得到后面的 <code>alpha</code>，并赋值给 <code>version_prerelease</code> 变量；如果解析到分组五: <code>-9</code>，则去掉前面的 <code>-</code>，得到后面的 <code>9</code>，并赋值给 <code>version_commit</code> 变量；如果解析到分组六: <code>-gb342a93</code>，则去掉前面的 <code>-g</code>，得到后面的 <code>b342a93</code>，并赋值给 <code>version_hash</code> 变量。</p>
<p>如果没有 <code>version_prerelease</code> 变量，但是有 <code>version_commit</code> 变量，则认为此补丁程序是下一个补丁版本的预发布版本，即将补丁版本号增加一个版本并赋值<code>version_prerelease</code> 变量为 <code>pre</code>。</p>
<p>拼接主要版本、次要版本和补丁版本为：<code>4.5.27</code>，并赋值给 <code>full_version</code> 变量。</p>
<p>如果有 <code>version_prerelease</code> 变量，则 <code>full_version</code> 变量追加 <code>-pre</code>，此时版本号为：<code>4.5.27-pre</code>；如果有 <code>version_commit</code> 变量，则版本号再追加 <code>version_commit</code> 和 <code>version_hash</code> 变量的值 <code>.9+b342a93</code>，得到版本号：<code>4.5.27-pre.9+b342a93</code>。</p>
<p>最终得到 <code>linphone-sdk</code> 的版本号：<code>4.5.27-pre.9+b342a93</code>。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本文记录了笔者查找 <code>linphone-sdk</code> 生成版本号的过程，同时分析了版本号的生成逻辑，<code>linphone-sdk</code> 通过获取 <code>Git</code> 提交记录和 TAG 来生成版本号：</p>
<ol>
<li>执行 <code>git describe</code> 命令获取可读 <code>Git</code> 提交信息，</li>
<li>通过正则表达式的分组配置模式解析得到的 <code>Git</code> 提交信息，</li>
<li>最后根据分组信息修正并拼接得到完整的版本号。</li>
</ol>
<p>利用 <code>Git</code> 提交信息来生成版本号这种方式，我们在写 SDK 时或许可以借鉴下。</p>
<p>希望可以帮到您，happy~</p>
]]></content>
      <categories>
        <category>linphone-sdk-android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>linphone-sdk-android</tag>
      </tags>
  </entry>
  <entry>
    <title>linphone-sdk-android网络检测分析</title>
    <url>/2022/06/06/linphone-sdk-android/linphone-sdk-android%E7%BD%91%E7%BB%9C%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="linphone-sdk-android网络检测分析"><a class="markdownIt-Anchor" href="#linphone-sdk-android网络检测分析"></a> linphone-sdk-android网络检测分析</h1>
<p>持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第 8 天，<a href="https://juejin.cn/post/7099702781094674468">点击查看活动详情</a></p>
<hr />
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>好久没写 <code>linphone-sdk-android</code> 相关的文章了，上一篇文章还是一个月之前，经过上次修改 <code>linphone-sdk-android</code> 后最近没有啥问题发生，本文记录下之前遇到的 <code>linphone</code> 网络问题的坑。</p>
<blockquote>
<p>注：笔者的 App 作为 Launcher 启动，目前运行在 Android 7.1.2 API 25 系统上，使用以太网连接。</p>
</blockquote>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<blockquote>
<p>注：以下源码基于 linphone-sdk-android 4.5.26。</p>
</blockquote>
<p>问题描述：在设备重启后，程序偶现发起不了呼叫，提示当前网络不可达，但是当前网络是好的，这就比较奇怪了。</p>
<p>接下来查看设备重启后的日志，发现一些与 linphone 网络相关的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">liblinphone : SIP network reachability state is now DOWN</span><br><span class="line">liblinphone : SIP network reachability state is now UP</span><br><span class="line">liblinphone : SIP network reachability state is now DOWN</span><br></pre></td></tr></table></figure>
<p>刷新账户注册时也提示网络不可达，日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">liblinphone : Refresh register operation not available (network unreachable)</span><br></pre></td></tr></table></figure>
<p>然后执行测试程序调用 <code>Core#isNetworkReachable</code> 方法也返回 <code>false</code> ，发起呼叫时笔者调用了此接口判断网络是否可达，所以出现了呼叫不了，提示当前网络不可达的问题，现在猜测是 <code>linphone</code> 内部维护的网络状态出现了问题，遂去查看下源码中对网络状态的处理。</p>
<h3 id="coresetnetworkreachable"><a class="markdownIt-Anchor" href="#coresetnetworkreachable"></a> Core#setNetworkReachable</h3>
<p>首先想到 <code>Core#setNetworkReachable</code> 接口，从 <code>setNetworkReachable</code> 下手吧，<code>setNetworkReachable</code> 方法最终会调用 native 的 <code>private native void setNetworkReachable(long var1, boolean var3);</code> 。</p>
<p>在之前的文章中，我们分析了 <code>Core</code> 接口调用的 native 方法一般在 <code>linphone_jni.cc</code> 中实现，我们打开 <code>linphone_jni.cc</code>，在其中搜索 <code>setNetworkReachable</code> 关键字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_org_linphone_core_CoreImpl_setNetworkReachable</span><span class="params">(JNIEnv *env, jobject thiz, jlong ptr, jboolean reachable)</span> </span>&#123;</span><br><span class="line">    LinphoneCore *cptr = (LinphoneCore*)ptr;</span><br><span class="line">    <span class="keyword">if</span> (cptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">bctbx_error</span>(<span class="string">&quot;Java_org_linphone_core_CoreImpl_setNetworkReachable&#x27;s LinphoneCore C ptr is null!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">linphone_core_set_network_reachable</span>(cptr, (<span class="type">bool_t</span>)reachable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>linphone_jni.cc</code> 中调用了 <code>linphone_core_set_network_reachable</code>，我们跟进去看看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linphonecore.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">linphone_core_set_network_reachable</span><span class="params">(LinphoneCore *lc, <span class="type">bool_t</span> is_reachable)</span> &#123;</span><br><span class="line">    <span class="type">bool_t</span> reachable = is_reachable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SIP协议层网络状态 - 用户设置的状态</span></span><br><span class="line">    lc-&gt;sip_network_state.user_state = is_reachable;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 媒体传输层网络状态 - 用户设置的状态</span></span><br><span class="line">    lc-&gt;media_network_state.user_state = is_reachable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果开启了网络状态自动检测</span></span><br><span class="line">    <span class="keyword">if</span> (lc-&gt;auto_net_state_mon) reachable = reachable &amp;&amp; getPlatformHelpers(lc)-&gt;isNetworkReachable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SIP协议层网络状态 - 全局状态</span></span><br><span class="line">    set_sip_network_reachable(lc, reachable, ms_time(<span class="literal">NULL</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置媒体传输层网络状态 - 全局状态</span></span><br><span class="line">    set_media_network_reachable(lc, reachable);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知网络可达性变更</span></span><br><span class="line">    notify_network_reachable_change(lc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>linphone_core_set_network_reachable</code> 方法中首先是修改了 「SIP 协议层网络状态 - 用户设置的状态」和「媒体传输层网络状态 - 用户设置的状态」，接下来判断是否开启了「网络状态自动检测」配置，若是开启了，则获取自动检测的网络状态并与传入的状态取且值，这里可能会改变传入的值：<strong>如果传入 True，而 <code>isNetworkReachable</code> 返回 False，最终 <code>reachable</code> 为 False。</strong></p>
<p>接下来，我们看下 <code>set_sip_network_reachable</code> 方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linphonecore.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_sip_network_reachable</span><span class="params">(LinphoneCore* lc,<span class="type">bool_t</span> is_sip_reachable, <span class="type">time_t</span> curtime)</span>&#123;</span><br><span class="line">	<span class="comment">// second get the list of available proxies</span></span><br><span class="line">	<span class="type">const</span> <span class="type">bctbx_list_t</span> *elem = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SIP协议层网络状态 - 全局状态，比较是否有变化</span></span><br><span class="line">	<span class="keyword">if</span> (lc-&gt;sip_network_state.global_state==is_sip_reachable) <span class="keyword">return</span>; <span class="comment">// no change, ignore.</span></span><br><span class="line">	lc-&gt;network_reachable_to_be_notified=TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应上面提到的设备重启后与网络相关的日志</span></span><br><span class="line">	ms_message(<span class="string">&quot;SIP network reachability state is now [%s]&quot;</span>,is_sip_reachable?<span class="string">&quot;UP&quot;</span>:<span class="string">&quot;DOWN&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	lc-&gt;netup_time=curtime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改SIP协议层网络状态 - 全局状态</span></span><br><span class="line">	lc-&gt;sip_network_state.global_state=is_sip_reachable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>set_sip_network_reachable</code> 方法中，首先判断传入的值是否与已有的值相等，相等则认为没有变化，忽略此次调用，然后打印传入 <code>is_sip_reachable</code> 的值，这行日志对应前面提到的设备重启后与网络相关的日志，最后修改「SIP协议层网络状态 - 全局状态」。</p>
<p>前面提到刷新账户注册时也提示网络不可达，赶巧了，<code>set_sip_network_reachable</code> 方法的下面就是调用刷新账户注册的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linphonecore.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">linphone_core_refresh_registers</span><span class="params">(LinphoneCore* lc)</span> &#123;    </span><br><span class="line">    <span class="comment">// 判断SIP协议层网络状态 - 全局状态</span></span><br><span class="line">	<span class="keyword">if</span> (!lc-&gt;sip_network_state.global_state) &#123;</span><br><span class="line">        <span class="comment">// 对应刷新账户注册时的网络不可达日志</span></span><br><span class="line">		ms_warning(<span class="string">&quot;Refresh register operation not available (network unreachable)&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>linphone_core_refresh_registers</code> 方法中，首先就判断了「SIP协议层网络状态 - 全局状态」，如果为 False，则此时网络不可达，输出网络不可达日志。</p>
<p>最后看下 <code>Core#isNetworkReachable</code> 的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linphonecore.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">linphone_core_is_network_reachable</span><span class="params">(LinphoneCore* lc)</span> &#123;</span><br><span class="line">    <span class="comment">// 返回SIP协议层网络状态 - 全局状态</span></span><br><span class="line">	<span class="keyword">return</span> lc-&gt;sip_network_state.global_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 中调用 <code>isNetworkReachable</code> 最终会调用到  <code>linphone_core_is_network_reachable</code> 方法，在 <code>linphone_core_is_network_reachable</code> 方法中，直接返回了「SIP协议层网络状态 - 全局状态」。</p>
<h3 id="androidplatformhelpersetnetworkreachable"><a class="markdownIt-Anchor" href="#androidplatformhelpersetnetworkreachable"></a> AndroidPlatformHelper#setNetworkReachable</h3>
<p>在上一节中我们分析是在 <code>set_sip_network_reachable</code> 方法修改的「SIP协议层网络状态 - 全局状态」，除了我们调用 <code>Core#setNetworkReachable</code> 外，应该还有调用方，在 IDE 中分析发现了 <code>linphone_core_set_network_reachable_internal</code> 方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linphonecore.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">linphone_core_set_network_reachable_internal</span><span class="params">(LinphoneCore *lc, <span class="type">bool_t</span> is_reachable)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果开启了网络状态自动检测</span></span><br><span class="line">	<span class="keyword">if</span> (lc-&gt;auto_net_state_mon) &#123;</span><br><span class="line">        <span class="comment">// 设置SIP协议层网络状态 - 全局状态</span></span><br><span class="line">		set_sip_network_reachable(lc, lc-&gt;sip_network_state.user_state &amp;&amp; is_reachable, ms_time(<span class="literal">NULL</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置媒体传输层网络状态 - 全局状态</span></span><br><span class="line">		set_media_network_reachable(lc, lc-&gt;media_network_state.user_state &amp;&amp; is_reachable);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知网络可达性变更</span></span><br><span class="line">		notify_network_reachable_change(lc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>linphone_core_set_network_reachable_internal</code> 方法中首先判断是否开启了「开启了网络状态自动检测」配置，然后修改全局网络状态。</p>
<p>继续分析哪些调用方调用了 <code>linphone_core_set_network_reachable_internal</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android-platform-helpers.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidPlatformHelpers::setNetworkReachable</span><span class="params">(<span class="type">bool</span> reachable)</span> </span>&#123;</span><br><span class="line">	mNetworkReachable = reachable;</span><br><span class="line">	<span class="built_in">linphone_core_set_network_reachable_internal</span>(<span class="built_in">getCore</span>()-&gt;<span class="built_in">getCCore</span>(), reachable ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续分析哪些调用方调用了 <code>AndroidPlatformHelpers::setNetworkReachable</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android-platform-helpers.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_org_linphone_core_tools_AndroidPlatformHelper_setNetworkReachable</span><span class="params">(JNIEnv* env, jobject thiz, jlong ptr, jboolean reachable)</span> </span>&#123;</span><br><span class="line">	AndroidPlatformHelpers *androidPlatformHelper = <span class="built_in">static_cast</span>&lt;AndroidPlatformHelpers *&gt;((<span class="type">void</span> *)ptr);</span><br><span class="line">	<span class="type">const</span> std::function&lt;<span class="type">void</span> ()&gt; fun = [androidPlatformHelper, reachable]() &#123;</span><br><span class="line">		androidPlatformHelper-&gt;<span class="built_in">setNetworkReachable</span>(reachable);</span><br><span class="line">	&#125;;</span><br><span class="line">	androidPlatformHelper-&gt;<span class="built_in">getCore</span>()-&gt;<span class="built_in">doLater</span>(fun);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里创建了一个 <code>fun</code> 对象，类似 Java 中的 <code>Runnable</code> 接口，抛给 <code>doLater</code> 方法稍后执行。</p>
<p>跟踪到这里，追到了 JNI 层，看到了熟悉的 Java 包名和类名 <code>AndroidPlatformHelper</code> ，在 AS 中打开 <code>AndroidPlatformHelper</code> ，搜索调用 <code>setNetworkReachable</code> 的地方，共有 6 处，均在 <code>updateNetworkReachability</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AndroidPlatformHelper.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">updateNetworkReachability</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.mNativePtr == <span class="number">0L</span>) &#123;</span><br><span class="line">        Log.w(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] Native pointer has been reset, stopping there&quot;</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.mNetworkManager == <span class="literal">null</span>) &#123;</span><br><span class="line">        Log.w(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] Network Manager is null, stopping there&quot;</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">connected</span> <span class="operator">=</span> <span class="built_in">this</span>.mNetworkManager.isCurrentlyConnected(<span class="built_in">this</span>.mContext);</span><br><span class="line">        <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">            Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] No connectivity: setting network unreachable&quot;</span>&#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ①</span></span><br><span class="line">            <span class="built_in">this</span>.setNetworkReachable(<span class="built_in">this</span>.mNativePtr, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.mNetworkManager.hasHttpProxy(<span class="built_in">this</span>.mContext)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.useSystemHttpProxy(<span class="built_in">this</span>.mNativePtr)) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="built_in">this</span>.mNetworkManager.getProxyHost(<span class="built_in">this</span>.mContext);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="built_in">this</span>.mNetworkManager.getProxyPort(<span class="built_in">this</span>.mContext);</span><br><span class="line">                    <span class="built_in">this</span>.setHttpProxy(<span class="built_in">this</span>.mNativePtr, host, port);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">this</span>.mUsingHttpProxy) &#123;</span><br><span class="line">                        Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] Proxy wasn&#x27;t set before, disabling network reachability first&quot;</span>&#125;);</span><br><span class="line">                        <span class="comment">// ②</span></span><br><span class="line">                        <span class="built_in">this</span>.setNetworkReachable(<span class="built_in">this</span>.mNativePtr, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>.mUsingHttpProxy = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.w(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] Proxy available but forbidden by linphone core [sip] use_system_http_proxy setting&quot;</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.setHttpProxy(<span class="built_in">this</span>.mNativePtr, <span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.mUsingHttpProxy) &#123;</span><br><span class="line">                    Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] Proxy was set before, disabling network reachability first&quot;</span>&#125;);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// ③</span></span><br><span class="line">                    <span class="built_in">this</span>.setNetworkReachable(<span class="built_in">this</span>.mNativePtr, <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.mUsingHttpProxy = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">NetworkInfo</span> <span class="variable">networkInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.mNetworkManager.getActiveNetworkInfo();</span><br><span class="line">            <span class="keyword">if</span> (networkInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">                Log.e(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] getActiveNetworkInfo() returned null !&quot;</span>&#125;);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ④</span></span><br><span class="line">                <span class="built_in">this</span>.setNetworkReachable(<span class="built_in">this</span>.mNativePtr, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] Active network type is &quot;</span> + networkInfo.getTypeName() + <span class="string">&quot;, state &quot;</span> + networkInfo.getState() + <span class="string">&quot; / &quot;</span> + networkInfo.getDetailedState()&#125;);</span><br><span class="line">                <span class="keyword">if</span> (networkInfo.getState() == State.DISCONNECTED &amp;&amp; networkInfo.getDetailedState() == DetailedState.BLOCKED) &#123;</span><br><span class="line">                    Log.w(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] Active network is in bad state...&quot;</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Network</span> <span class="variable">network</span> <span class="operator">=</span> <span class="built_in">this</span>.mNetworkManager.getActiveNetwork();</span><br><span class="line">                <span class="built_in">this</span>.mNetworkManager.updateDnsServers();</span><br><span class="line">                <span class="type">int</span> <span class="variable">currentNetworkType</span> <span class="operator">=</span> networkInfo.getType();</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.mLastNetworkType != -<span class="number">1</span> &amp;&amp; <span class="built_in">this</span>.mLastNetworkType != currentNetworkType) &#123;</span><br><span class="line">                    Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] Network type has changed (last one was &quot;</span> + <span class="built_in">this</span>.networkTypeToString(<span class="built_in">this</span>.mLastNetworkType) + <span class="string">&quot;), disabling network reachability first&quot;</span>&#125;);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// ⑤</span></span><br><span class="line">                    <span class="built_in">this</span>.setNetworkReachable(<span class="built_in">this</span>.mNativePtr, <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.mLastNetworkType = currentNetworkType;</span><br><span class="line">                Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] Network reachability enabled&quot;</span>&#125;);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ⑥</span></span><br><span class="line">                <span class="built_in">this</span>.setNetworkReachable(<span class="built_in">this</span>.mNativePtr, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上 6 处调用，只有最后的第 6 处传入了 True，认为网络可达；其余 5 处均传入了 False，认为网络不可达。上面的代码主要是获取当前活跃的网络信息，如果没有活跃的网络信息就认为网络不可达。</p>
<p>继续分析哪些调用方调用了 <code>AndroidPlatformHelpers#updateNetworkReachability</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AndroidPlatformHelper.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">startNetworkMonitoring</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否开启了自动检测网络状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.mMonitoringEnabled) &#123;</span><br><span class="line">        <span class="comment">// 根据 Android 系统版本创建网络管理器</span></span><br><span class="line">        <span class="built_in">this</span>.mNetworkManager = <span class="built_in">this</span>.createNetworkManager();</span><br><span class="line">        Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] Registering network callbacks&quot;</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册网络变化回调</span></span><br><span class="line">        <span class="built_in">this</span>.mNetworkManager.registerNetworkCallbacks(<span class="built_in">this</span>.mContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用了updateNetworkReachability</span></span><br><span class="line">        <span class="built_in">this</span>.updateNetworkReachability();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>startNetworkMonitoring</code> 方法主要是开启网络状态自动检测功能，首先判断是否开启了自动检测网络状态配置，接下来根据 Android 系统版本创建网络管理器，然后注册网络变化回调，最后调用了 <code>updateNetworkReachability</code> 方法，进行一次网络状态通知。</p>
<p>前面提到笔者目前使用的设备是 API 25，在 <code>createNetworkManager</code> 方法中找到对应的网络管理器实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NetworkManagerAbove24.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NetworkManagerAbove24</span><span class="params">(AndroidPlatformHelper helper, ConnectivityManager cm, <span class="type">boolean</span> wifiOnly)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mHelper = helper;</span><br><span class="line">    <span class="built_in">this</span>.mConnectivityManager = cm;</span><br><span class="line">    <span class="built_in">this</span>.mWifiOnly = wifiOnly;</span><br><span class="line">    <span class="built_in">this</span>.mNetworkAvailable = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.mLastNetworkAvailable = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网络变化回调</span></span><br><span class="line">    <span class="built_in">this</span>.mNetworkCallback = <span class="keyword">new</span> <span class="title class_">NetworkCallback</span>() &#123;</span><br><span class="line">        <span class="comment">// 网络可用</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAvailable</span><span class="params">(<span class="keyword">final</span> Network network)</span> &#123;</span><br><span class="line">            <span class="comment">// MainHandler</span></span><br><span class="line">            NetworkManagerAbove24.<span class="built_in">this</span>.mHelper.getHandler().post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">NetworkInfo</span> <span class="variable">info</span> <span class="operator">=</span> NetworkManagerAbove24.<span class="built_in">this</span>.mConnectivityManager.getNetworkInfo(network);</span><br><span class="line">                    <span class="keyword">if</span> (info == <span class="literal">null</span>) &#123;</span><br><span class="line">                        Log.e(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] [Network Manager 24] A network should be available but getNetworkInfo failed.&quot;</span>&#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] [Network Manager 24] A network is available: &quot;</span> + info.getTypeName() + <span class="string">&quot;, wifi only is &quot;</span> + (NetworkManagerAbove24.<span class="built_in">this</span>.mWifiOnly ? <span class="string">&quot;enabled&quot;</span> : <span class="string">&quot;disabled&quot;</span>)&#125;);</span><br><span class="line">                        <span class="keyword">if</span> (NetworkManagerAbove24.<span class="built_in">this</span>.mWifiOnly &amp;&amp; info.getType() != <span class="number">1</span> &amp;&amp; info.getType() != <span class="number">9</span>) &#123;</span><br><span class="line">                            Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] [Network Manager 24] Network isn&#x27;t wifi and wifi only mode is enabled&quot;</span>&#125;);</span><br><span class="line">                            <span class="keyword">if</span> (NetworkManagerAbove24.<span class="built_in">this</span>.mWifiOnly) &#123;</span><br><span class="line">                                NetworkManagerAbove24.<span class="built_in">this</span>.mLastNetworkAvailable = network;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            NetworkManagerAbove24.<span class="built_in">this</span>.mNetworkAvailable = network;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 调用了updateNetworkReachability</span></span><br><span class="line">                            NetworkManagerAbove24.<span class="built_in">this</span>.mHelper.updateNetworkReachability();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 网络丢失</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLost</span><span class="params">(<span class="keyword">final</span> Network network)</span> &#123;</span><br><span class="line">            <span class="comment">// MainHandler</span></span><br><span class="line">            NetworkManagerAbove24.<span class="built_in">this</span>.mHelper.getHandler().post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] [Network Manager 24] A network has been lost&quot;</span>&#125;);</span><br><span class="line">                    <span class="keyword">if</span> (NetworkManagerAbove24.<span class="built_in">this</span>.mNetworkAvailable != <span class="literal">null</span> &amp;&amp; NetworkManagerAbove24.<span class="built_in">this</span>.mNetworkAvailable.equals(network)) &#123;</span><br><span class="line">                        NetworkManagerAbove24.<span class="built_in">this</span>.mNetworkAvailable = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (NetworkManagerAbove24.<span class="built_in">this</span>.mLastNetworkAvailable != <span class="literal">null</span> &amp;&amp; NetworkManagerAbove24.<span class="built_in">this</span>.mLastNetworkAvailable.equals(network)) &#123;</span><br><span class="line">                        NetworkManagerAbove24.<span class="built_in">this</span>.mLastNetworkAvailable = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 调用了updateNetworkReachability</span></span><br><span class="line">                    NetworkManagerAbove24.<span class="built_in">this</span>.mHelper.updateNetworkReachability();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册网络变化回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerNetworkCallbacks</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">permissionGranted</span> <span class="operator">=</span> context.getPackageManager().checkPermission(<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span>, context.getPackageName());</span><br><span class="line">    Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] [Network Manager 24] ACCESS_NETWORK_STATE permission is &quot;</span> + (permissionGranted == <span class="number">0</span> ? <span class="string">&quot;granted&quot;</span> : <span class="string">&quot;denied&quot;</span>)&#125;);</span><br><span class="line">    <span class="keyword">if</span> (permissionGranted == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mConnectivityManager.registerDefaultNetworkCallback(<span class="built_in">this</span>.mNetworkCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure>
<p>在 <code>NetworkManagerAbove24.java</code> 的实现中，网络可用时也会调用 <code>AndroidPlatformHelper#updateNetworkReachability</code>方法。</p>
<p>到这里其实差不多了，因为分析下来，发现网络可用时通知 linphone 网络可达，网络丢失时通知 linphone 网络不可达，以上流程符合正常的思维逻辑，笔者追到这里，只能是怀疑在 <code>startNetworkMonitoring</code> 和 <code>NetworkManagerAbove24#onAvailable</code> 的两处调用有并发顺序问题，<code>onAvailable</code> 一定是在主线程执行的，而 <code>startNetworkMonitoring</code> 就不确定是在哪个线程执行了。</p>
<p>最后笔者想着关闭「自动检测网络状态」配置，由业务程序自身监听网络变化，然后调用 <code>Core#setNetworkReachable</code> 方法通知 linphone 网络是否可达。</p>
<h3 id="auto_net_state_mon"><a class="markdownIt-Anchor" href="#auto_net_state_mon"></a> auto_net_state_mon</h3>
<p>在上一节，我们分析了 <code>startNetworkMonitoring</code> 方法，现在我们继续分析哪些调用方调用了 <code>startNetworkMonitoring</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AndroidPlatformHelper.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">onLinphoneCoreStart</span><span class="params">(<span class="type">boolean</span> monitoringEnabled)</span> &#123;</span><br><span class="line">    Log.i(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;[Platform Helper] onLinphoneCoreStart, network monitoring is &quot;</span> + monitoringEnabled&#125;);</span><br><span class="line">    <span class="built_in">this</span>.mMonitoringEnabled = monitoringEnabled;</span><br><span class="line">    <span class="built_in">this</span>.startNetworkMonitoring();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onLinphoneCoreStart</code> 方法在 <code>AndroidPlatformHelper.java</code> 中没有找到调用方，怀疑此方法是在 native 层调用了，我们去 <code>android-platform-helpers.cpp</code> 中搜索一番：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android-platform-helpers.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidPlatformHelpers::onLinphoneCoreStart</span><span class="params">(<span class="type">bool</span> monitoringEnabled)</span> </span>&#123;</span><br><span class="line">	JNIEnv *env = <span class="built_in">ms_get_jni_env</span>();</span><br><span class="line">	<span class="keyword">if</span> (env) &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用AndroidPlatformHelper#onLinphoneCoreStart</span></span><br><span class="line">		<span class="keyword">if</span> (mJavaHelper) &#123;</span><br><span class="line">			env-&gt;<span class="built_in">CallVoidMethod</span>(mJavaHelper, mOnLinphoneCoreStartId, (jboolean)monitoringEnabled);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>AndroidPlatformHelpers::onLinphoneCoreStart</code> 方法中调用了 <code>AndroidPlatformHelper#onLinphoneCoreStart</code> 方法，好的，我们继续分析 <code>AndroidPlatformHelpers::onLinphoneCoreStart</code> 的调用方，通过在 IDE 中搜索发现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linphonecore.c</span></span><br><span class="line"></span><br><span class="line">LinphoneStatus <span class="title function_">linphone_core_start</span> <span class="params">(LinphoneCore *lc)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取是否开启了网络状态自动检测</span></span><br><span class="line">    <span class="type">bool</span> autoNetworkStateMonitoringEnabled = !!lc-&gt;auto_net_state_mon;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有开启，输出日志</span></span><br><span class="line">    <span class="keyword">if</span> (!autoNetworkStateMonitoringEnabled) &#123;</span><br><span class="line">        bctbx_warning(<span class="string">&quot;Automatic network state monitoring is disabled by configuration (auto_net_state_mon=0). This is not recommended.&quot;</span>);</span><br><span class="line">        bctbx_warning(<span class="string">&quot;In this mode, apps must use linphone_core_set_network_reachable() and linphone_core_set_dns_servers() to notify the LinphoneCore of network availability and provide the DNS server list.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用AndroidPlatformHelpers::onLinphoneCoreStart</span></span><br><span class="line">    getPlatformHelpers(lc)-&gt;onLinphoneCoreStart(autoNetworkStateMonitoringEnabled);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bingo~，发现了 <code>lc-&gt;auto_net_state_mon</code> ，现在我们只要找到 <code>lc-&gt;auto_net_state_mon</code> 是在哪里赋值的就可以了，还是在 IDE 中搜索分析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linphonecore.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _linphone_core_read_config(LinphoneCore * lc) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取各种配置项</span></span><br><span class="line">    sip_setup_register_all(lc-&gt;factory);</span><br><span class="line">    sound_config_read(lc);</span><br><span class="line">    net_config_read(lc);</span><br><span class="line">    rtp_config_read(lc);</span><br><span class="line">    codecs_config_read(lc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取sip_config</span></span><br><span class="line">    sip_config_read(lc);</span><br><span class="line">    video_config_read(lc);</span><br><span class="line">    <span class="comment">//autoreplier_config_init(&amp;lc-&gt;autoreplier_conf);</span></span><br><span class="line">    misc_config_read(lc);</span><br><span class="line">    ui_config_read(lc);</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> TUNNEL_ENABLED</span></span><br><span class="line">    <span class="keyword">if</span> (lc-&gt;tunnel) &#123;</span><br><span class="line">        linphone_tunnel_configure(lc-&gt;tunnel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用sip_conf-&gt;auto_net_state_mon赋值</span></span><br><span class="line">    lc-&gt;auto_net_state_mon=lc-&gt;sip_conf.auto_net_state_mon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_linphone_core_read_config</code> 方法主要是读取各种配置项，与 <code>auto_net_state_mon</code> 相关的主要是 <code>sip_config_read(lc);</code> 和 最后一行代码，最后一行代码使用 <code>sip_conf</code> 中的 <code>auto_net_state_mon</code> 为 <code>lc-&gt;auto_net_state_mon</code> 赋值，<code>sip_conf</code> 在 <code>sip_config_read(lc);</code> 中赋值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linphonecore.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sip_config_read</span><span class="params">(LinphoneCore *lc)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    lc-&gt;sip_conf.auto_net_state_mon = !!linphone_config_get_int(lc-&gt;config,<span class="string">&quot;sip&quot;</span>,<span class="string">&quot;auto_net_state_mon&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>sip_config_read</code> 方法中，通过读取 <code>Config</code> 中的 <code>Section</code> 和 <code>Key</code> 赋值，如果没有相应的 <code>Section</code> 和 <code>Key</code> ，则取默认值 1。</p>
<p>终于找到配置「自动检测网络状态」开关的地方了，<code>Config</code> 是在 Java 层创建 <code>Core</code> 时传入的，所以现在我们只需修改 Java 层代码即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Config</span></span><br><span class="line">    <span class="type">Config</span> <span class="variable">configWithFactory</span> <span class="operator">=</span> mFactory.createConfigWithFactory(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据外部传入的配置判断是否开启linphone的「自动检测网络状态」开关</span></span><br><span class="line">    <span class="keyword">if</span> (mConfig.autoNetStateMonitorEnabled()) &#123;</span><br><span class="line">        configWithFactory.setInt(<span class="string">&quot;sip&quot;</span>, <span class="string">&quot;auto_net_state_mon&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        configWithFactory.setInt(<span class="string">&quot;sip&quot;</span>, <span class="string">&quot;auto_net_state_mon&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据Config创建Core</span></span><br><span class="line">    mCore = mFactory.createCoreWithConfig(configWithFactory, mContext.getApplicationContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过 <code>Factory</code> 创建空的 <code>Config</code> 对象，然后根据外部传入的配置判断是否开启linphone的「自动检测网络状态」开关，随后根据 <code>Config</code> 对象创建 <code>Core</code>，</p>
<p>最后运行程序查看 Logcat 日志，在 <code>AndroidPlatformHelper#onLinphoneCoreStart</code> 方法中有输出是否开启了「自动检测网络状态」：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linphone-android : [Platform Helper] onLinphoneCoreStart, network monitoring is false</span><br></pre></td></tr></table></figure>
<p>happy~</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本文笔者记录了从根据问题现象，分析问题，反向跟踪源码到网络检测逻辑，至网络检测逻辑时，问题分析陷入困境，再到大胆假设是并发引起的问题，随后沿着并发引起问题的假设，想到关闭 linphone「自动检测网络状态」配置的方法，最后分析「自动检测网络状态」配置的开启流程。</p>
<p>笔者在分析排查期间有一步放弃的话，也看不到最后的曙光。</p>
<p>不经历风雨怎能见彩虹，希望可以帮到你~</p>
]]></content>
      <categories>
        <category>linphone-sdk-android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>linphone-sdk-android</tag>
      </tags>
  </entry>
  <entry>
    <title>修改linphone-sdk-android-第一篇</title>
    <url>/2022/04/23/linphone-sdk-android/%E4%BF%AE%E6%94%B9linphone-sdk-android-%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="修改linphone-sdk-android-上篇"><a class="markdownIt-Anchor" href="#修改linphone-sdk-android-上篇"></a> 修改linphone-sdk-android-上篇</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>记录修改linphone-sdk-android过程，计划分为上、中、下三篇</p>
<p>本文是上篇，本篇仅记录下书问题2的初步排查过程，尽量描述排查问题过程中的思路与方向</p>
<p>余下两篇记录问题1、2的修改过程</p>
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<p>接上文<a href="https://juejin.cn/post/7087496636657565727">编译linphone-sdk-android</a></p>
<p>项目中使用的linphone-sdk-android版本为4.5.x，使用过程中发现以下两个问题：</p>
<ol>
<li>打开音频编解码G722、G729时，发起呼叫的INVITE SDP中，没有G722、G729的RTP MAP，当时以为是linphone的bug，后面看源码及查资料发现可能不是bug，这里先按下不表</li>
<li>使用sdk提供的JavaLogger输出日志时，伪代码：<code>mFactory.getLoggingService().addListener(mAndroidLoggingService);</code>，偶现JNI崩溃问题</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    --------- beginning of crash</span><br><span class="line">2022-04-11 14:16:22.350 1142-1430/? A/libc: Fatal signal 6 (SIGABRT), code -6 in tid 1430 (RealLinphonePro)</span><br><span class="line">2022-04-11 14:16:22.441 3756-3756/? A/DEBUG: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</span><br><span class="line">2022-04-11 14:16:22.442 3756-3756/? A/DEBUG: Build fingerprint: &#x27;Android/rk3288/rk3288:7.1.2/NHG47K/builde03162201:userdebug/test-keys&#x27;</span><br><span class="line">2022-04-11 14:16:22.444 3756-3756/? A/DEBUG: Revision: &#x27;0&#x27;</span><br><span class="line">2022-04-11 14:16:22.446 3756-3756/? A/DEBUG: ABI: &#x27;arm&#x27;</span><br><span class="line">2022-04-11 14:16:22.447 3756-3756/? A/DEBUG: pid: 1142, tid: 1430, name: RealLinphonePro  &gt;&gt;&gt; com.guodong.android.linphone &lt;&lt;&lt;</span><br><span class="line">2022-04-11 14:16:22.448 3756-3756/? A/DEBUG: signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------</span><br><span class="line">2022-04-11 14:16:22.454 3756-3756/? A/DEBUG: Abort message: &#x27;art/runtime/indirect_reference_table.cc:80] JNI ERROR (app bug): accessed deleted WeakGlobal 0x21ab&#x27;</span><br><span class="line">2022-04-11 14:16:22.456 3756-3756/? A/DEBUG:     r0 00000000  r1 00000596  r2 00000006  r3 00000008</span><br><span class="line">2022-04-11 14:16:22.457 3756-3756/? A/DEBUG:     r4 89aff978  r5 00000006  r6 89aff920  r7 0000010c</span><br><span class="line">2022-04-11 14:16:22.459 3756-3756/? A/DEBUG:     r8 00000043  r9 aaa7eef0  sl 0000000a  fp 89d04400</span><br><span class="line">2022-04-11 14:16:22.461 3756-3756/? A/DEBUG:     ip 0000000b  sp 89afef88  lr ab175857  pc ab1780c0  cpsr 600b0010</span><br><span class="line">2022-04-11 14:16:22.509 3756-3756/? A/DEBUG: backtrace:</span><br><span class="line">2022-04-11 14:16:22.511 3756-3756/? A/DEBUG:     #00 pc 0004a0c0  /system/lib/libc.so (tgkill+12)</span><br><span class="line">2022-04-11 14:16:22.512 3756-3756/? A/DEBUG:     #01 pc 00047853  /system/lib/libc.so (pthread_kill+34)</span><br><span class="line">2022-04-11 14:16:22.514 3756-3756/? A/DEBUG:     #02 pc 0001d8b5  /system/lib/libc.so (raise+10)</span><br><span class="line">2022-04-11 14:16:22.515 3756-3756/? A/DEBUG:     #03 pc 00019401  /system/lib/libc.so (__libc_android_abort+34)</span><br><span class="line">2022-04-11 14:16:22.517 3756-3756/? A/DEBUG:     #04 pc 00017048  /system/lib/libc.so (abort+4)</span><br><span class="line">2022-04-11 14:16:22.518 3756-3756/? A/DEBUG:     #05 pc 0031d8cd  /system/lib/libart.so (_ZN3art7Runtime5AbortEPKc+328)</span><br><span class="line">2022-04-11 14:16:22.520 3756-3756/? A/DEBUG:     #06 pc 000b5503  /system/lib/libart.so (_ZN3art10LogMessageD2Ev+1134)</span><br><span class="line">2022-04-11 14:16:22.521 3756-3756/? A/DEBUG:     #07 pc 001bd0ff  /system/lib/libart.so (_ZN3art22IndirectReferenceTable17AbortIfNoCheckJNIERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE+134)</span><br><span class="line">2022-04-11 14:16:22.523 3756-3756/? A/DEBUG:     #08 pc 0023ecaf  /system/lib/libart.so (_ZNK3art22IndirectReferenceTable10GetCheckedEPv+250)</span><br><span class="line">2022-04-11 14:16:22.525 3756-3756/? A/DEBUG:     #09 pc 0023c05b  /system/lib/libart.so (_ZN3art9JavaVMExt16DecodeWeakGlobalEPNS_6ThreadEPv+30)</span><br><span class="line">2022-04-11 14:16:22.526 3756-3756/? A/DEBUG:     #10 pc 00337679  /system/lib/libart.so (_ZNK3art6Thread13DecodeJObjectEP8_jobject+164)</span><br><span class="line">2022-04-11 14:16:22.528 3756-3756/? A/DEBUG:     #11 pc 00265843  /system/lib/libart.so (_ZN3art3JNI11NewLocalRefEP7_JNIEnvP8_jobject+406)</span><br><span class="line">2022-04-11 14:16:22.530 3756-3756/? A/DEBUG:     #12 pc 0060eff9  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so (getLoggingService+88)</span><br><span class="line">2022-04-11 14:16:22.531 3756-3756/? A/DEBUG:     #13 pc 0061a977  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so</span><br><span class="line">2022-04-11 14:16:22.533 3756-3756/? A/DEBUG:     #14 pc 005ef911  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so</span><br><span class="line">2022-04-11 14:16:22.535 3756-3756/? A/DEBUG:     #15 pc 00025437  /data/app/com.guodong.android.linphone-1/lib/arm/libbctoolbox.so (bctbx_logv+182)</span><br><span class="line">2022-04-11 14:16:22.536 3756-3756/? A/DEBUG:     #16 pc 006f5061  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so</span><br><span class="line">2022-04-11 14:16:22.538 3756-3756/? A/DEBUG:     #17 pc 006f51d9  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so (wake_lock_acquire+152)</span><br><span class="line">2022-04-11 14:16:22.539 3756-3756/? A/DEBUG:     #18 pc 006601c5  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so</span><br><span class="line">2022-04-11 14:16:22.541 3756-3756/? A/DEBUG:     #19 pc 00660b27  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so (belle_sip_client_transaction_init+138)</span><br><span class="line">2022-04-11 14:16:22.542 3756-3756/? A/DEBUG:     #20 pc 006fb1d3  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so (belle_sip_nict_new+30)</span><br><span class="line">2022-04-11 14:16:22.544 3756-3756/? A/DEBUG:     #21 pc 0065c3a7  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so (belle_sip_provider_create_client_transaction+46)</span><br><span class="line">2022-04-11 14:16:22.546 3756-3756/? A/DEBUG:     #22 pc 0065dec3  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so</span><br><span class="line">2022-04-11 14:16:22.547 3756-3756/? A/DEBUG:     #23 pc 0065daf7  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so (belle_sip_refresher_refresh+28)</span><br><span class="line">2022-04-11 14:16:22.549 3756-3756/? A/DEBUG:     #24 pc 005fac23  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so (linphone_proxy_config_refresh_register+34)</span><br><span class="line">2022-04-11 14:16:22.550 3756-3756/? A/DEBUG:     #25 pc 005e9fc5  /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so (linphone_core_refresh_registers+40)</span><br><span class="line">2022-04-11 14:16:22.552 3756-3756/? A/DEBUG:     #26 pc 019fc3bf  /data/app/com.guodong.android.linphone-1/oat/arm/base.odex (offset 0x18de000)</span><br><span class="line">2022-04-11 14:16:23.096 227-255/? I/AudioFlinger: BUFFER TIMEOUT: remove(4099) from active list on thread 0xabd03e00</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<h3 id="问题2"><a class="markdownIt-Anchor" href="#问题2"></a> 问题2</h3>
<p>通过崩溃日志第27行<code>2022-04-11 14:16:22.530 3756-3756/? A/DEBUG: #12 pc 0060eff9 /data/app/com.guodong.android.linphone-1/lib/arm/liblinphone.so (getLoggingService+88)</code>可以判断崩溃是在<code>getLoggingService()</code>这个方法里</p>
<p>如此需要先找到<code>getLoggingService()</code>方法的源码，先在Source Insight中搜索<code>getLoggingService()</code>，搜索一圈发现没有，猜想此方法应该是编译后自动生成的</p>
<p>在Ubuntu编译环境里找找，通过<code>find</code>命令查找包含<code>getLoggingService</code>文本的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> linphone-sdk/build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -<span class="built_in">type</span> f | xargs grep <span class="string">&quot;getLoggingService&quot;</span></span></span><br><span class="line">./WORK/android-armv7/Build/linphone/wrappers/java/src/linphone_jni.cc:JNIEXPORT jobject JNICALL getLoggingService(JNIEnv *env, LinphoneLoggingService *cptr, bool_t takeref) &#123;</span><br><span class="line">./WORK/android-armv7/Build/linphone/wrappers/java/src/linphone_jni.cc:	jobject j_logService = getLoggingService(env, (LinphoneLoggingService *)logService, TRUE);</span><br><span class="line">./WORK/android-armv7/Build/linphone/wrappers/java/src/linphone_jni.cc:	jobject jni_result = (jobject)getLoggingService(env, (LinphoneLoggingService *)linphone_logging_service_get(), TRUE);</span><br></pre></td></tr></table></figure>
<p>找到了bingo~</p>
<p>打开<code>linphone_jni.cc</code>，<code>getLoggingService()</code>方法体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jobject JNICALL <span class="title">getLoggingService</span><span class="params">(JNIEnv *env, LinphoneLoggingService *cptr, <span class="type">bool_t</span> takeref)</span> </span>&#123;</span><br><span class="line">	jobject jobj = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="type">void</span> *up = <span class="built_in">belle_sip_object_data_get</span>((<span class="type">belle_sip_object_t</span> *)cptr, belle_sip_java_user_data_key);</span><br><span class="line">		LinphoneJavaBindings *ljb = (LinphoneJavaBindings *)<span class="built_in">linphone_factory_get_user_data</span>(<span class="built_in">linphone_factory_get</span>());</span><br><span class="line">		<span class="keyword">if</span> (!ljb) &#123;</span><br><span class="line">			ljb = <span class="keyword">new</span> <span class="built_in">LinphoneJavaBindings</span>(env);</span><br><span class="line">			<span class="built_in">linphone_factory_set_user_data</span>(<span class="built_in">linphone_factory_get</span>(), ljb);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		jclass linphone_logging_service_class = ljb-&gt;linphone_logging_service_class;</span><br><span class="line">		jmethodID linphone_logging_service_constructor = ljb-&gt;linphone_logging_service_class_constructor;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (up == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			jobj = env-&gt;<span class="built_in">NewObject</span>(linphone_logging_service_class, linphone_logging_service_constructor, (jlong)cptr);</span><br><span class="line">			<span class="built_in">belle_sip_object_data_set</span>((<span class="type">belle_sip_object_t</span> *)cptr, belle_sip_java_user_data_key, (<span class="type">void</span>*)env-&gt;<span class="built_in">NewWeakGlobalRef</span>(jobj), <span class="literal">nullptr</span>);</span><br><span class="line">			<span class="keyword">if</span> (takeref)</span><br><span class="line">				<span class="built_in">linphone_logging_service_ref</span>(cptr);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			jobj = env-&gt;<span class="built_in">NewLocalRef</span>((jobject)up);</span><br><span class="line">			<span class="keyword">if</span> (jobj == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="comment">// Delete weak ref ?</span></span><br><span class="line">				env-&gt;<span class="built_in">DeleteWeakGlobalRef</span>((jobject)up);</span><br><span class="line">				<span class="comment">// takes implicit local ref</span></span><br><span class="line">				jobj = env-&gt;<span class="built_in">NewObject</span>(linphone_logging_service_class, linphone_logging_service_constructor, (jlong)cptr);</span><br><span class="line">				<span class="built_in">belle_sip_object_data_set</span>((<span class="type">belle_sip_object_t</span> *)cptr, belle_sip_java_user_data_key, (<span class="type">void</span>*)env-&gt;<span class="built_in">NewWeakGlobalRef</span>(jobj), <span class="literal">nullptr</span>);</span><br><span class="line">				<span class="keyword">if</span> (takeref)</span><br><span class="line">					<span class="built_in">linphone_logging_service_ref</span>(cptr);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> jobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，看起来没啥问题，也有判空处理，一时间摸不着头绪，先在<code>getLoggingService()</code>方法中加点日志输出看看吧</p>
<p>前面说<code>linphone_jni.cc</code>是自动生成的，现在需要找到自动生成<code>linphone_jni.cc</code>的代码，根据崩溃日志可以发现<code>getLoggingService()</code>在<code>linphone.so</code>中，而源码中有<code>liblinphone</code>这个目录，先在这个目录下找找吧，通过<code>find</code>命令查找文件名中包含<code>jni</code>的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> linphone-sdk/liblinphone/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name *jni*</span></span><br><span class="line">./coreapi/linphonecore_jni.cc</span><br><span class="line">./tools/lpc2xml_jni.cc</span><br><span class="line">./tools/xml2lpc_jni.cc</span><br><span class="line">./tools/my_jni.h</span><br><span class="line">./wrappers/java/jni.mustache</span><br></pre></td></tr></table></figure>
<p>查找出来多个文件，既然<code>linphone_jni.cc</code>是自动生成的，所以可以确定<code>.cc</code>、<code>.h</code>后缀的几个文件肯定不是，排除后只剩下这个<code>jni.mustache</code>文件，打开文件<code>vim ./wrappers/java/jni.mustache</code>注释第一行就是<code>linphone_jni.cc</code>，太棒了，找到自动生成的代码了</p>
<p>通过一些查看，并与<code>linphone_jni.cc</code>中的实现对比，锁定了以下代码即为自动生成的模板代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">290 &#123;&#123;#objects&#125;&#125;</span><br><span class="line">291 JNIEXPORT jobject JNICALL get&#123;&#123;className&#125;&#125;(JNIEnv *env, &#123;&#123;classCName&#125;&#125; *cptr, bool_t takeref) &#123;</span><br><span class="line">292         jobject jobj = nullptr;</span><br><span class="line">293 </span><br><span class="line">294         if (cptr != nullptr) &#123;</span><br><span class="line">295                 void *up = belle_sip_object_data_get((belle_sip_object_t *)cptr, belle_sip_java_user_data_key);</span><br><span class="line">296                 LinphoneJavaBindings *ljb = (LinphoneJavaBindings *)linphone_factory_get_user_data(linphone_factory_get());</span><br><span class="line">297                 if (!ljb) &#123;</span><br><span class="line">298                         ljb = new LinphoneJavaBindings(env);</span><br><span class="line">299                         linphone_factory_set_user_data(linphone_factory_get(), ljb);</span><br><span class="line">300                 &#125;</span><br><span class="line">301 </span><br><span class="line">302                 jclass &#123;&#123;cPrefix&#125;&#125;_class = ljb-&gt;&#123;&#123;cPrefix&#125;&#125;_class;</span><br><span class="line">303                 jmethodID &#123;&#123;cPrefix&#125;&#125;_constructor = ljb-&gt;&#123;&#123;cPrefix&#125;&#125;_class_constructor;</span><br><span class="line">304 </span><br><span class="line">305                 if (up == nullptr) &#123;</span><br><span class="line">306                         jobj = env-&gt;NewObject(&#123;&#123;cPrefix&#125;&#125;_class, &#123;&#123;cPrefix&#125;&#125;_constructor, (jlong)cptr);</span><br><span class="line">307                         belle_sip_object_data_set((belle_sip_object_t *)cptr, belle_sip_java_user_data_key, (void*)env-&gt;NewWeakGlobalRef(jobj), nullptr);</span><br><span class="line">308                         if (takeref)</span><br><span class="line">309                                 &#123;&#123;#refCountable&#125;&#125;&#123;&#123;cPrefix&#125;&#125;_ref(cptr);&#123;&#123;/refCountable&#125;&#125;</span><br><span class="line">310                 &#125; else &#123;</span><br><span class="line">311                         jobj = env-&gt;NewLocalRef((jobject)up);</span><br><span class="line">312                         if (jobj == nullptr) &#123;</span><br><span class="line">313                                 // Delete weak ref ?</span><br><span class="line">314                                 env-&gt;DeleteWeakGlobalRef((jobject)up);</span><br><span class="line">315                                 // takes implicit local ref</span><br><span class="line">316                                 jobj = env-&gt;NewObject(&#123;&#123;cPrefix&#125;&#125;_class, &#123;&#123;cPrefix&#125;&#125;_constructor, (jlong)cptr);</span><br><span class="line">317                                 belle_sip_object_data_set((belle_sip_object_t *)cptr, belle_sip_java_user_data_key, (void*)env-&gt;NewWeakGlobalRef(jobj), nullptr);</span><br><span class="line">318                                 if (takeref)</span><br><span class="line">319                                         &#123;&#123;#refCountable&#125;&#125;&#123;&#123;cPrefix&#125;&#125;_ref(cptr);&#123;&#123;/refCountable&#125;&#125;</span><br><span class="line">320                         &#125;</span><br><span class="line">321                 &#125;</span><br><span class="line">322         &#125;</span><br><span class="line">323         return jobj;</span><br><span class="line">324 &#125;</span><br></pre></td></tr></table></figure>
<p>这里linphone-sdk使用了<a href="https://github.com/janl/mustache.js">mustache</a>，还记得在上篇<a href="https://juejin.cn/post/7087496636657565727">编译Linphone-SDK-Android</a>中有安装<code>pip3 install pystache</code>，<code>pystache</code>是<code>mustache</code>的Python实现，<code>mustache</code>的语法比较简单，在<code>github</code>上看一眼文档，再跟着源码比着葫芦画瓢，应该就差不多了</p>
<p>好的，学习完<code>mustache</code>的语法，了解到高级用法可以传一个配置文件进行渲染，正好与<code>jni.mustache</code>同级目录中有个<code>genwrapper.py</code>文件，打开此文件，里面定义了很多类，其中有个<code>Jni</code>的类，里面有些字段与<code>jni.mustache</code>中的标签正好对应，就是它了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Jni</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">add_object</span>(<span class="params">self, javaClass</span>):</span><br><span class="line">        <span class="keyword">if</span> javaClass.className == <span class="string">&#x27;Factory&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        obj = &#123;</span><br><span class="line">            <span class="string">&#x27;jniPrefix&#x27;</span>: self.jni_package,</span><br><span class="line">            <span class="string">&#x27;jniPath&#x27;</span>: self.jni_path,</span><br><span class="line">            <span class="string">&#x27;cPrefix&#x27;</span>: javaClass.cPrefix,</span><br><span class="line">            <span class="string">&#x27;className&#x27;</span>: javaClass.className,</span><br><span class="line">            <span class="string">&#x27;classCName&#x27;</span>: javaClass.cName,</span><br><span class="line">            <span class="string">&#x27;classImplName&#x27;</span>: javaClass.classImplName,</span><br><span class="line">            <span class="string">&#x27;refCountable&#x27;</span>: javaClass.refCountable,</span><br><span class="line">            <span class="string">&#x27;notRefCountable&#x27;</span>: <span class="keyword">not</span> javaClass.refCountable,</span><br><span class="line">        &#125;</span><br><span class="line">        self.objects.append(obj)</span><br></pre></td></tr></table></figure>
<p>happy~万事具备，现在可以修改源码，添加一些日志输出了</p>
<p>因为在<code>jni.mustache</code>中模板方法<code>get&#123;&#123;className&#125;&#125;</code>是可以生成多个以<code>get</code>开头的方法，现在需要判断<code>&#123;&#123;className&#125;&#125;</code>是不是等于<code>LoggingService</code>，而在<a href="https://github.com/janl/mustache.js">mustache</a>中没有发现比较字符串是否相同的语法，所以在<code>genwrapper.py</code>的<code>Jni</code>类中新增一个<code>isLoggingService</code>字段表示是否是<code>getLoggingService()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Jni</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">add_object</span>(<span class="params">self, javaClass</span>):</span><br><span class="line">        <span class="keyword">if</span> javaClass.className == <span class="string">&#x27;Factory&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        obj = &#123;</span><br><span class="line">            <span class="string">&#x27;jniPrefix&#x27;</span>: self.jni_package,</span><br><span class="line">            <span class="string">&#x27;jniPath&#x27;</span>: self.jni_path,</span><br><span class="line">            <span class="string">&#x27;cPrefix&#x27;</span>: javaClass.cPrefix,</span><br><span class="line">            <span class="string">&#x27;className&#x27;</span>: javaClass.className,</span><br><span class="line">            <span class="string">&#x27;classCName&#x27;</span>: javaClass.cName,</span><br><span class="line">            <span class="string">&#x27;classImplName&#x27;</span>: javaClass.classImplName,</span><br><span class="line">            <span class="string">&#x27;refCountable&#x27;</span>: javaClass.refCountable,</span><br><span class="line">            <span class="string">&#x27;notRefCountable&#x27;</span>: <span class="keyword">not</span> javaClass.refCountable,</span><br><span class="line">            <span class="string">&#x27;isLoggingService&#x27;</span>: javaClass.className == <span class="string">&#x27;LoggingService&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        self.objects.append(obj)</span><br></pre></td></tr></table></figure>
<p>然后修改<code>jni.mustache</code>文件，增加日志，输出<code>up</code>指针指向的地址，<code>up</code>指针转成<code>jobject</code>后与<code>NULL</code>、<code>nullptr</code>比较的结果，判断<code>up</code>是否已经被回收了</p>
<p>这里说一下代码的大概意思，<code>up</code>指针从<code>belle_sip_object_data_get</code>方法中通过<code>belle_sip_java_user_data_key</code>这个Key获取，可以简单理解为Java中的Map；如果<code>up</code>为空，则调用Java方法创建一个对象，将创建的Java对象通过<code>NewWeakGlobalRef</code>方法转换为全局弱引用，再通过<code>belle_sip_object_data_set</code>方法保存起来；如果<code>up</code>不为空，则强转为<code>jobject</code>，判断<code>jobject</code>是否为空，为空则删除全局弱引用，再创建保存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;#objects&#125;&#125;</span><br><span class="line">JNIEXPORT jobject JNICALL get&#123;&#123;className&#125;&#125;(JNIEnv *env, &#123;&#123;classCName&#125;&#125; *cptr, bool_t takeref) &#123;</span><br><span class="line">	jobject jobj = nullptr;</span><br><span class="line"></span><br><span class="line">	if (cptr != nullptr) &#123;</span><br><span class="line">		void *up = belle_sip_object_data_get((belle_sip_object_t *)cptr, belle_sip_java_user_data_key);</span><br><span class="line">		LinphoneJavaBindings *ljb = (LinphoneJavaBindings *)linphone_factory_get_user_data(linphone_factory_get());</span><br><span class="line">		if (!ljb) &#123;</span><br><span class="line">			ljb = new LinphoneJavaBindings(env);</span><br><span class="line">			linphone_factory_set_user_data(linphone_factory_get(), ljb);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		jclass &#123;&#123;cPrefix&#125;&#125;_class = ljb-&gt;&#123;&#123;cPrefix&#125;&#125;_class;</span><br><span class="line">		jmethodID &#123;&#123;cPrefix&#125;&#125;_constructor = ljb-&gt;&#123;&#123;cPrefix&#125;&#125;_class_constructor;</span><br><span class="line"></span><br><span class="line">		&#123;&#123;#isLoggingService&#125;&#125;</span><br><span class="line">		#ifdef __ANDROID__</span><br><span class="line">		__android_log_print(ANDROID_LOG_DEBUG, &quot;guodongAndroid&quot;, &quot;up = %p&quot;, up);</span><br><span class="line">		</span><br><span class="line">		jobject temp_jobj1 = (jobject)up;</span><br><span class="line">		jboolean up_available1 = env-&gt;IsSameObject(temp_jobj1, NULL);</span><br><span class="line">		__android_log_print(ANDROID_LOG_DEBUG, &quot;guodongAndroid&quot;, &quot;up_available1 = %d&quot;, up_available1);</span><br><span class="line">		</span><br><span class="line">		jobject temp_jobj2 = (jobject)up;</span><br><span class="line">		jboolean up_available2 = env-&gt;IsSameObject(temp_jobj2, nullptr);</span><br><span class="line">		__android_log_print(ANDROID_LOG_DEBUG, &quot;guodongAndroid&quot;, &quot;up_available2 = %d&quot;, up_available2);</span><br><span class="line">		#endif /* __ANDROID__ */</span><br><span class="line">		&#123;&#123;/isLoggingService&#125;&#125;</span><br><span class="line"></span><br><span class="line">		if (up == nullptr) &#123;</span><br><span class="line">			jobj = env-&gt;NewObject(&#123;&#123;cPrefix&#125;&#125;_class, &#123;&#123;cPrefix&#125;&#125;_constructor, (jlong)cptr);</span><br><span class="line">			belle_sip_object_data_set((belle_sip_object_t *)cptr, belle_sip_java_user_data_key, (void*)env-&gt;NewWeakGlobalRef(jobj), nullptr);</span><br><span class="line">			if (takeref)</span><br><span class="line">				&#123;&#123;#refCountable&#125;&#125;&#123;&#123;cPrefix&#125;&#125;_ref(cptr);&#123;&#123;/refCountable&#125;&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			jobj = env-&gt;NewLocalRef((jobject)up);</span><br><span class="line">			if (jobj == nullptr) &#123;</span><br><span class="line">				// Delete weak ref ?</span><br><span class="line">				env-&gt;DeleteWeakGlobalRef((jobject)up);</span><br><span class="line">				// takes implicit local ref</span><br><span class="line">				jobj = env-&gt;NewObject(&#123;&#123;cPrefix&#125;&#125;_class, &#123;&#123;cPrefix&#125;&#125;_constructor, (jlong)cptr);</span><br><span class="line">				belle_sip_object_data_set((belle_sip_object_t *)cptr, belle_sip_java_user_data_key, (void*)env-&gt;NewWeakGlobalRef(jobj), nullptr);</span><br><span class="line">				if (takeref)</span><br><span class="line">					&#123;&#123;#refCountable&#125;&#125;&#123;&#123;cPrefix&#125;&#125;_ref(cptr);&#123;&#123;/refCountable&#125;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return jobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，修改完源码保存后，就可以编译了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> linphone-sdk/build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --build . --parallel 8</span></span><br></pre></td></tr></table></figure>
<p>等待编译完成，拷贝出来编译好的<code>aar</code>，放到Android Studio中运行，查看Logcat输出</p>
]]></content>
      <categories>
        <category>linphone-sdk-android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>linphone-sdk-android</tag>
      </tags>
  </entry>
  <entry>
    <title>修改linphone-sdk-android-第三篇</title>
    <url>/2022/04/26/linphone-sdk-android/%E4%BF%AE%E6%94%B9linphone-sdk-android-%E7%AC%AC%E4%B8%89%E7%AF%87/</url>
    <content><![CDATA[<h1 id="修改linphone-sdk-android-下篇"><a class="markdownIt-Anchor" href="#修改linphone-sdk-android-下篇"></a> 修改linphone-sdk-android-下篇</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>接上篇<a href="https://juejin.cn/post/7089664949907095559">修改linphone-sdk-android-上篇</a></p>
<p>接中篇<a href="https://juejin.cn/post/7090172691617071118">修改linphone-sdk-android-中篇</a></p>
<p>本文是下篇，本篇记录在上篇中提到的问题1排查过程及修复方案，尽量描述排查问题过程中的思路与方向</p>
<p>上篇中说问题1当初认为是linphone的bug，后面看源码及查资料发现可能不是bug，本篇将记录个人的理解</p>
<h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2>
<p>这里再描述下问题1：打开音频编解码G722、G729等时，发起呼叫的INVITE SDP中，没有G722、G729的<code>rtpmap</code></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">m</span>=audio <span class="number">7078</span> RTP/AVP <span class="number">96</span> <span class="number">0</span> <span class="number">8</span> <span class="number">9</span> <span class="number">18</span> <span class="number">101</span> <span class="number">97</span></span><br><span class="line"><span class="attribute">a</span>=fmtp:<span class="number">18</span> annexb=yes</span><br><span class="line"><span class="attribute">a</span>=rtpmap:<span class="number">101</span> telephone-event/<span class="number">48000</span></span><br><span class="line"><span class="attribute">a</span>=rtpmap:<span class="number">97</span> telephone-event/<span class="number">8000</span></span><br><span class="line"><span class="attribute">a</span>=rtcp-fb:* trr-int <span class="number">1000</span></span><br><span class="line"><span class="attribute">a</span>=rtcp-fb:* ccm tmmbr</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>这里先了解下SDP协议，参考<a href="https://www.3cx.com/blog/voip-howto/sdp-voip2/">The Session Description Protocol (SDP) (3cx.com)</a></p>
<p><code>rtpmap</code>是<code>Session attribute lines</code>，即为会话属性行，是对<code>Payload Type</code>的补充说明，<code>Payload Type</code>既是<code>m=audio 7078 RTP/AVP 96 0 8 9 18 101 97</code>中<code>AVP</code>后面的数字，这些数字是音频编解码对应的代码，对应关系如下：</p>
<p>下表源自<a href="https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#rtp-parameters-1">Real-Time Transport Protocol (RTP) Parameters (iana.org)</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">PT <img data-src="https://www.iana.org/assignments/_support/sort_none.gif" alt="img" /></th>
<th style="text-align:left">Encoding Name <img data-src="https://www.iana.org/assignments/_support/sort_none.gif" alt="img" /></th>
<th style="text-align:left">Audio/Video (A/V) <img data-src="https://www.iana.org/assignments/_support/sort_none.gif" alt="img" /></th>
<th style="text-align:left">Clock Rate (Hz) <img data-src="https://www.iana.org/assignments/_support/sort_none.gif" alt="img" /></th>
<th style="text-align:left">Channels <img data-src="https://www.iana.org/assignments/_support/sort_none.gif" alt="img" /></th>
<th style="text-align:left">Reference <img data-src="https://www.iana.org/assignments/_support/sort_none.gif" alt="img" /></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">PCMU</td>
<td style="text-align:left">A</td>
<td style="text-align:left">8000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Reserved</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">Reserved</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">GSM</td>
<td style="text-align:left">A</td>
<td style="text-align:left">8000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">G723</td>
<td style="text-align:left">A</td>
<td style="text-align:left">8000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#Vineet_Kumar">Vineet_Kumar</a>][<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">DVI4</td>
<td style="text-align:left">A</td>
<td style="text-align:left">8000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">DVI4</td>
<td style="text-align:left">A</td>
<td style="text-align:left">16000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">LPC</td>
<td style="text-align:left">A</td>
<td style="text-align:left">8000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">PCMA</td>
<td style="text-align:left">A</td>
<td style="text-align:left">8000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">G722</td>
<td style="text-align:left">A</td>
<td style="text-align:left">8000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">L16</td>
<td style="text-align:left">A</td>
<td style="text-align:left">44100</td>
<td style="text-align:left">2</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">L16</td>
<td style="text-align:left">A</td>
<td style="text-align:left">44100</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">QCELP</td>
<td style="text-align:left">A</td>
<td style="text-align:left">8000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">CN</td>
<td style="text-align:left">A</td>
<td style="text-align:left">8000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3389">RFC3389</a>]</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left">MPA</td>
<td style="text-align:left">A</td>
<td style="text-align:left">90000</td>
<td style="text-align:left"></td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>][<a href="https://www.iana.org/go/rfc2250">RFC2250</a>]</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left">G728</td>
<td style="text-align:left">A</td>
<td style="text-align:left">8000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left">DVI4</td>
<td style="text-align:left">A</td>
<td style="text-align:left">11025</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#Joseph_Di_Pol">Joseph_Di_Pol</a>]</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left">DVI4</td>
<td style="text-align:left">A</td>
<td style="text-align:left">22050</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#Joseph_Di_Pol">Joseph_Di_Pol</a>]</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left">G729</td>
<td style="text-align:left">A</td>
<td style="text-align:left">8000</td>
<td style="text-align:left">1</td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left">Reserved</td>
<td style="text-align:left">A</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left">Unassigned</td>
<td style="text-align:left">A</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left">Unassigned</td>
<td style="text-align:left">A</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left">Unassigned</td>
<td style="text-align:left">A</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left">Unassigned</td>
<td style="text-align:left">A</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left">Unassigned</td>
<td style="text-align:left">V</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left">CelB</td>
<td style="text-align:left">V</td>
<td style="text-align:left">90000</td>
<td style="text-align:left"></td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc2029">RFC2029</a>]</td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left">JPEG</td>
<td style="text-align:left">V</td>
<td style="text-align:left">90000</td>
<td style="text-align:left"></td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc2435">RFC2435</a>]</td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left">Unassigned</td>
<td style="text-align:left">V</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">28</td>
<td style="text-align:left">nv</td>
<td style="text-align:left">V</td>
<td style="text-align:left">90000</td>
<td style="text-align:left"></td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">29</td>
<td style="text-align:left">Unassigned</td>
<td style="text-align:left">V</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left">Unassigned</td>
<td style="text-align:left">V</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">31</td>
<td style="text-align:left">H261</td>
<td style="text-align:left">V</td>
<td style="text-align:left">90000</td>
<td style="text-align:left"></td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc4587">RFC4587</a>]</td>
</tr>
<tr>
<td style="text-align:left">32</td>
<td style="text-align:left">MPV</td>
<td style="text-align:left">V</td>
<td style="text-align:left">90000</td>
<td style="text-align:left"></td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc2250">RFC2250</a>]</td>
</tr>
<tr>
<td style="text-align:left">33</td>
<td style="text-align:left">MP2T</td>
<td style="text-align:left">AV</td>
<td style="text-align:left">90000</td>
<td style="text-align:left"></td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc2250">RFC2250</a>]</td>
</tr>
<tr>
<td style="text-align:left">34</td>
<td style="text-align:left">H263</td>
<td style="text-align:left">V</td>
<td style="text-align:left">90000</td>
<td style="text-align:left"></td>
<td style="text-align:left">[<a href="https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml#Chunrong_Zhu">Chunrong_Zhu</a>]</td>
</tr>
<tr>
<td style="text-align:left">35-71</td>
<td style="text-align:left">Unassigned</td>
<td style="text-align:left">?</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">72-76</td>
<td style="text-align:left">Reserved for RTCP conflict avoidance</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
<tr>
<td style="text-align:left">77-95</td>
<td style="text-align:left">Unassigned</td>
<td style="text-align:left">?</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">96-127</td>
<td style="text-align:left">dynamic</td>
<td style="text-align:left">?</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">[<a href="https://www.iana.org/go/rfc3551">RFC3551</a>]</td>
</tr>
</tbody>
</table>
<p>从表中了解到，Payload Type(PT) code 0 - 95为静态类型，即code对应固定的codec(编解码器)，96 - 127为动态codec，即需要在SDP协商过程中确定</p>
<p>接下来追踪下源码，看看SDP中为什么没有<code>rtpmap</code></p>
<p>先找到<code>Java</code>层发起呼叫的代码，在<code>Core.java</code>中有4个发起呼叫的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Call <span class="title function_">invite</span><span class="params">(<span class="meta">@NonNull</span> String var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Call <span class="title function_">inviteAddress</span><span class="params">(<span class="meta">@NonNull</span> Address var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Call <span class="title function_">inviteAddressWithParams</span><span class="params">(<span class="meta">@NonNull</span> Address var1, <span class="meta">@NonNull</span> CallParams var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Call <span class="title function_">inviteWithParams</span><span class="params">(<span class="meta">@NonNull</span> String var1, <span class="meta">@NonNull</span> CallParams var2)</span>;</span><br></pre></td></tr></table></figure>
<p>具体实现在<code>CoreImpl.java</code>中，查看这个<code>public Call inviteAddress(@NonNull Address addr);</code>方法吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Call <span class="title function_">inviteAddress</span><span class="params">(<span class="type">long</span> nativePtr, Address addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> Call <span class="title function_">inviteAddress</span><span class="params">(<span class="meta">@NonNull</span> Address addr)</span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> (Call)inviteAddress(nativePtr, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Java</code>层调用了<code>native</code>层代码，打开编译后生成的<code>linphone_jni.cc</code>，找到<code>Java_org_linphone_core_CoreImpl_inviteAddress</code>方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jobject JNICALL <span class="title">Java_org_linphone_core_CoreImpl_inviteAddress</span><span class="params">(JNIEnv *env, jobject thiz, jlong ptr, jobject addr)</span> </span>&#123;</span><br><span class="line">	LinphoneCore *cptr = (LinphoneCore*)ptr;</span><br><span class="line">	<span class="keyword">if</span> (cptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">bctbx_error</span>(<span class="string">&quot;Java_org_linphone_core_CoreImpl_inviteAddress&#x27;s LinphoneCore C ptr is null!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	LinphoneAddress* c_addr = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (addr) c_addr = (LinphoneAddress*)<span class="built_in">GetObjectNativePtr</span>(env, addr);</span><br><span class="line">	</span><br><span class="line">	jobject jni_result = (jobject)<span class="built_in">getCall</span>(env, (LinphoneCall *)<span class="built_in">linphone_core_invite_address</span>(cptr, c_addr), TRUE);</span><br><span class="line">	<span class="keyword">return</span> jni_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>native</code>层调用了<code>linphone_core_invite_address</code>这个方法，在IDE中，可以通过Ctrl+左键点击进行跳转，<code>linphone_core_invite_address</code>位于<code>linphonecore.c</code>中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinphoneCall * <span class="title">linphone_core_invite_address</span><span class="params">(LinphoneCore *lc, <span class="type">const</span> LinphoneAddress *addr)</span></span>&#123;</span><br><span class="line">	LinphoneCall *call;</span><br><span class="line">	LinphoneCallParams *p=<span class="built_in">linphone_core_create_call_params</span>(lc, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">linphone_call_params_enable_video</span>(p, <span class="built_in">linphone_call_params_video_enabled</span>(p) &amp;&amp; !!lc-&gt;video_policy.automatically_initiate);</span><br><span class="line">	call=<span class="built_in">linphone_core_invite_address_with_params</span> (lc,addr,p);</span><br><span class="line">	<span class="built_in">linphone_call_params_unref</span>(p);</span><br><span class="line">	<span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>linphone_core_invite_address</code>方法中调用了<code>linphone_core_invite_address_with_params</code>发起呼叫，这个方法较长，删减一些不关心的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinphoneCall * <span class="title">linphone_core_invite_address_with_params</span><span class="params">(LinphoneCore *lc, <span class="type">const</span> LinphoneAddress *addr, <span class="type">const</span> LinphoneCallParams *params)</span></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *from=<span class="literal">NULL</span>;</span><br><span class="line">	LinphoneCall *call;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (!addr) &#123;</span><br><span class="line">		<span class="built_in">ms_error</span>(<span class="string">&quot;Can&#x27;t invite a NULL address&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parsed_url2=<span class="built_in">linphone_address_new</span>(from);</span><br><span class="line">	call=<span class="built_in">linphone_call_new_outgoing</span>(lc,parsed_url2,addr,cp,proxy);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> defer = Call::<span class="built_in">toCpp</span>(call)-&gt;<span class="built_in">initiateOutgoing</span>();</span><br><span class="line">	<span class="keyword">if</span> (!defer) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Call::<span class="built_in">toCpp</span>(call)-&gt;<span class="built_in">startInvite</span>(<span class="literal">nullptr</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* The call has already gone to error and released state, so do not return it */</span></span><br><span class="line">			call = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>linphone_core_invite_address_with_params</code>方法中调用<code>linphone_call_new_outgoing</code>方法创建<code>Call</code>对象，调用<code>initiateOutgoing</code>方法初始化发起呼叫并设置当前状态为<code>OutgoingInit</code>，接下来调用<code>startInvite</code>方法发起呼叫，<code>startInvite</code>方法位于<code>call.cpp</code>中，在其中又调用<code>getActiveSession</code>方法获取<code>CallSession</code>，调用<code>CallSession::startInvite</code>方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Call::startInvite</span> <span class="params">(<span class="type">const</span> Address *destination)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getActiveSession</span>()-&gt;<span class="built_in">startInvite</span>(destination, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CallSession::startInvite</code>方法位于<code>call-session.cpp</code>中，在这个方法中找了半天，没见有与SDP发送相关的逻辑，先去头文件中看看方法原型吧</p>
<p>找了半天也是有点收获的，分析出调用<code>addAdditionalLocalBody</code>去组装自定义扩展头数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CallSession::startInvite</span> <span class="params">(<span class="type">const</span> Address *destination, <span class="type">const</span> string &amp;subject, <span class="type">const</span> Content *content)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">L_D</span>();</span><br><span class="line">	d-&gt;subject = subject;</span><br><span class="line">	<span class="comment">/* Try to be best-effort in giving real local or routable contact address */</span></span><br><span class="line">	d-&gt;<span class="built_in">setContactOp</span>();</span><br><span class="line">	string destinationStr;</span><br><span class="line">	<span class="type">char</span> *realUrl = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (destination)</span><br><span class="line">		destinationStr = destination-&gt;<span class="built_in">asString</span>();</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		realUrl = <span class="built_in">linphone_address_as_string</span>(d-&gt;log-&gt;to);</span><br><span class="line">		destinationStr = realUrl;</span><br><span class="line">		<span class="built_in">ms_free</span>(realUrl);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> *from = <span class="built_in">linphone_address_as_string</span>(d-&gt;log-&gt;from);</span><br><span class="line">	<span class="comment">/* Take a ref because sal_call() may destroy the CallSession if no SIP transport is available */</span></span><br><span class="line">	shared_ptr&lt;CallSession&gt; ref = <span class="built_in">getSharedFromThis</span>();</span><br><span class="line">	<span class="keyword">if</span> (content)</span><br><span class="line">		d-&gt;op-&gt;<span class="built_in">setLocalBody</span>(*content);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If a custom Content has been set in the call params, create a multipart body for the INVITE</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; content : d-&gt;params-&gt;<span class="built_in">getCustomContents</span>()) &#123;</span><br><span class="line">		d-&gt;op-&gt;<span class="built_in">addAdditionalLocalBody</span>(content);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> result = d-&gt;op-&gt;<span class="built_in">call</span>(from, destinationStr, subject);</span><br><span class="line">	<span class="built_in">ms_free</span>(from);</span><br><span class="line">	<span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((d-&gt;state != CallSession::State::Error) &amp;&amp; (d-&gt;state != CallSession::State::Released)) &#123;</span><br><span class="line">			<span class="comment">// sal_call() may invoke call_failure() and call_released() SAL callbacks synchronously,</span></span><br><span class="line">			<span class="comment">// in which case there is no need to perform a state change here.</span></span><br><span class="line">			d-&gt;<span class="built_in">setState</span>(CallSession::State::Error, <span class="string">&quot;Call failed&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">linphone_call_log_set_call_id</span>(d-&gt;log, d-&gt;op-&gt;<span class="built_in">getCallId</span>().<span class="built_in">c_str</span>()); <span class="comment">/* Must be known at that time */</span></span><br><span class="line">		d-&gt;<span class="built_in">setState</span>(CallSession::State::OutgoingProgress, <span class="string">&quot;Outgoing call in progress&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CallSession::startInvite</code>方法原型为，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">startInvite</span> <span class="params">(<span class="type">const</span> Address *destination, <span class="type">const</span> std::string &amp;subject = <span class="string">&quot;&quot;</span>, <span class="type">const</span> Content *content = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>是个<code>virtual</code>虚函数，说明有函数复写，在IDE中搜索发现<code>MediaSession</code>类继承自<code>CallSession</code>，好的，找到<code>MediaSession</code>复写的<code>startInvite</code>方法，方法较长，删除一些不关心的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MediaSession::startInvite</span> <span class="params">(<span class="type">const</span> Address *destination, <span class="type">const</span> string &amp;subject, <span class="type">const</span> Content *content)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">L_D</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 删除不关心的代码</span></span><br><span class="line"></span><br><span class="line">	d-&gt;op-&gt;<span class="built_in">setLocalMediaDescription</span>(d-&gt;localDesc);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> result = CallSession::<span class="built_in">startInvite</span>(destination, subject, content);</span><br><span class="line">	<span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (d-&gt;state == CallSession::State::Error)</span><br><span class="line">			d-&gt;<span class="built_in">stopStreams</span>();</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>MediaSession::startInvite</code>中调用<code>setLocalMediaDescription</code>方法组装本地媒体描述信息，最后再调用父类的<code>CallSession::startInvite</code>方法继续发起呼叫，好的，现在只关心<code>setLocalMediaDescription</code>方法，其中<code>op</code>是<code>SalCallOp</code>，在IDE中打开<code>call-op.cpp</code>，找到<code>setLocalMediaDescription</code>方法，删减一些不关心的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SalCallOp::setLocalMediaDescription</span> <span class="params">(SalMediaDescription *desc)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (desc) &#123;</span><br><span class="line">		<span class="built_in">sal_media_description_ref</span>(desc);</span><br><span class="line">		belle_sip_error_code error;</span><br><span class="line">		<span class="type">belle_sdp_session_description_t</span> *sdp = <span class="built_in">media_description_to_sdp</span>(desc);</span><br><span class="line">		vector&lt;<span class="type">char</span>&gt; buffer = <span class="built_in">marshalMediaDescription</span>(sdp, error);</span><br><span class="line">		<span class="built_in">belle_sip_object_unref</span>(sdp);</span><br><span class="line">		<span class="keyword">if</span> (error != BELLE_SIP_OK)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		mLocalBody.<span class="built_in">setContentType</span>(ContentType::Sdp);</span><br><span class="line">		mLocalBody.<span class="built_in">setBody</span>(<span class="built_in">move</span>(buffer));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mLocalBody = <span class="built_in">Content</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里终于发现与SDP相关的方法了<code>media_description_to_sdp</code>，继续查看<code>media_description_to_sdp</code>方法，此方法位于<code>sal_sdp.c</code>中，方法较长，主要是组装SDP协议数据，比如设置版本、创建源信息，创建会话等，这里删减一些不关心的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">belle_sdp_session_description_t</span> * <span class="title">media_description_to_sdp</span><span class="params">(<span class="type">const</span> SalMediaDescription *desc)</span> </span>&#123;</span><br><span class="line">	<span class="type">belle_sdp_session_description_t</span>* session_desc=<span class="built_in">belle_sdp_session_description_new</span>();</span><br><span class="line">	<span class="type">bool_t</span> inet6;</span><br><span class="line">	<span class="type">belle_sdp_origin_t</span>* origin;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> *escaped_username = <span class="built_in">belle_sip_uri_to_escaped_username</span>(desc-&gt;username);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( <span class="built_in">strchr</span> ( desc-&gt;addr,<span class="string">&#x27;:&#x27;</span> ) !=<span class="literal">NULL</span> ) &#123;</span><br><span class="line">		inet6=<span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> inet6=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">belle_sdp_session_description_set_version</span> ( session_desc,<span class="built_in">belle_sdp_version_create</span> ( <span class="number">0</span> ) );</span><br><span class="line"></span><br><span class="line">	origin = <span class="built_in">belle_sdp_origin_create</span> ( escaped_username</span><br><span class="line">									  ,desc-&gt;session_id</span><br><span class="line">									  ,desc-&gt;session_ver</span><br><span class="line">									  ,<span class="string">&quot;IN&quot;</span></span><br><span class="line">									  , inet6 ? <span class="string">&quot;IP6&quot;</span> :<span class="string">&quot;IP4&quot;</span></span><br><span class="line">									  ,desc-&gt;addr );</span><br><span class="line">	<span class="built_in">bctbx_free</span>(escaped_username);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">belle_sdp_session_description_set_origin</span> ( session_desc,origin );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">belle_sdp_session_description_set_session_name</span> ( session_desc,</span><br><span class="line">		<span class="built_in">belle_sdp_session_name_create</span> ( desc-&gt;name[<span class="number">0</span>]!=<span class="string">&#x27;\0&#x27;</span> ? desc-&gt;name : <span class="string">&quot;Talk&quot;</span> ) );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删减不关心的代码</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;desc-&gt;nb_streams; i++ ) &#123;</span><br><span class="line">		<span class="built_in">stream_description_to_sdp</span>(session_desc, desc, &amp;desc-&gt;streams[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> session_desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析<code>media_description_to_sdp</code>方法找到在<code>stream_description_to_sdp</code>方法中组装数据流信息到SDP协议中，<code>stream_description_to_sdp</code>方法非常长，此方法主要是组装SDP协议中编解码相关的信息，这里删除大部分不关心的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">stream_description_to_sdp</span> <span class="params">( <span class="type">belle_sdp_session_description_t</span> *session_desc, <span class="type">const</span> SalMediaDescription *md, <span class="type">const</span> SalStreamDescription *stream )</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删减不关心的代码</span></span><br><span class="line"></span><br><span class="line">	media_desc = <span class="built_in">belle_sdp_media_description_create</span> ( <span class="built_in">sal_stream_description_get_type_as_string</span>(stream)</span><br><span class="line">				 ,stream-&gt;rtp_port</span><br><span class="line">				 ,<span class="number">1</span></span><br><span class="line">				 ,<span class="built_in">sal_media_proto_to_string</span> ( stream-&gt;proto )</span><br><span class="line">				 ,<span class="literal">NULL</span> );</span><br><span class="line">    <span class="comment">// 看到payloads字段</span></span><br><span class="line">	<span class="keyword">if</span> (stream-&gt;payloads) &#123;</span><br><span class="line">		<span class="keyword">for</span> ( pt_it=stream-&gt;payloads; pt_it!=<span class="literal">NULL</span>; pt_it=pt_it-&gt;next ) &#123;</span><br><span class="line">			pt= ( PayloadType* ) pt_it-&gt;data;</span><br><span class="line">			mime_param= <span class="built_in">belle_sdp_mime_parameter_create</span> ( pt-&gt;mime_type</span><br><span class="line">					, <span class="built_in">payload_type_get_number</span> ( pt )</span><br><span class="line">					, pt-&gt;clock_rate</span><br><span class="line">					, pt-&gt;channels&gt;<span class="number">0</span> ? pt-&gt;channels : <span class="number">-1</span> );</span><br><span class="line">			<span class="built_in">belle_sdp_mime_parameter_set_parameters</span> ( mime_param,pt-&gt;recv_fmtp );</span><br><span class="line">			<span class="keyword">if</span> ( stream-&gt;ptime&gt;<span class="number">0</span> ) &#123;</span><br><span class="line">				<span class="built_in">belle_sdp_mime_parameter_set_ptime</span> ( mime_param,stream-&gt;ptime );</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 锁定此方法</span></span><br><span class="line">			<span class="built_in">belle_sdp_media_description_append_values_from_mime_parameter</span> ( media_desc,mime_param );</span><br><span class="line">			<span class="built_in">belle_sip_object_unref</span> ( mime_param );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* to comply with SDP we cannot have an empty payload type number list */</span></span><br><span class="line">		<span class="comment">/* as it happens only when mline is declined with a zero port, it does not matter to put whatever codec*/</span></span><br><span class="line">		<span class="type">belle_sip_list_t</span>* format = <span class="built_in">belle_sip_list_append</span>(<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">belle_sdp_media_set_media_formats</span>(<span class="built_in">belle_sdp_media_description_get_media</span>(media_desc),format);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组装自定义sdp属性</span></span><br><span class="line">	<span class="keyword">if</span> (stream-&gt;custom_sdp_attributes) &#123;</span><br><span class="line">		<span class="type">belle_sdp_session_description_t</span> *custom_desc = (<span class="type">belle_sdp_session_description_t</span> *)stream-&gt;custom_sdp_attributes;</span><br><span class="line">		<span class="type">belle_sip_list_t</span> *l = <span class="built_in">belle_sdp_session_description_get_attributes</span>(custom_desc);</span><br><span class="line">		<span class="type">belle_sip_list_t</span> *elem;</span><br><span class="line">		<span class="keyword">for</span> (elem = l; elem != <span class="literal">NULL</span>; elem = elem-&gt;next) &#123;</span><br><span class="line">			<span class="built_in">belle_sdp_media_description_add_attribute</span>(media_desc, (<span class="type">belle_sdp_attribute_t</span> *)elem-&gt;data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删减不关心的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>stream_description_to_sdp</code>方法中看到<code>payload</code>字段，马上就要找到了happy~</p>
<p>经过分析，锁定<code>belle_sdp_media_description_append_values_from_mime_parameter</code>方法，分析此方法，在其中找到组装<code>rtpmap</code>的源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">belle_sdp_media_description_append_values_from_mime_parameter</span><span class="params">(<span class="type">belle_sdp_media_description_t</span>* media_description, <span class="type">const</span> <span class="type">belle_sdp_mime_parameter_t</span>* mime_parameter)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BELLE_SDP_FORCE_RTP_MAP <span class="comment">/* defined to for RTP map even for static codec*/</span></span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">mime_parameter_is_static</span>(mime_parameter)) &#123;</span><br><span class="line">		<span class="comment">/*dynamic payload*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">belle_sdp_mime_parameter_get_channel_count</span>(mime_parameter)&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">snprintf</span>(atribute_value,MAX_FMTP_LENGTH,<span class="string">&quot;%i %s/%i/%i&quot;</span></span><br><span class="line">					,<span class="built_in">belle_sdp_mime_parameter_get_media_format</span>(mime_parameter)</span><br><span class="line">					,<span class="built_in">belle_sdp_mime_parameter_get_type</span>(mime_parameter)</span><br><span class="line">					,<span class="built_in">belle_sdp_mime_parameter_get_rate</span>(mime_parameter)</span><br><span class="line">					,<span class="built_in">belle_sdp_mime_parameter_get_channel_count</span>(mime_parameter));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">snprintf</span>(atribute_value,MAX_FMTP_LENGTH,<span class="string">&quot;%i %s/%i&quot;</span></span><br><span class="line">					,<span class="built_in">belle_sdp_mime_parameter_get_media_format</span>(mime_parameter)</span><br><span class="line">					,<span class="built_in">belle_sdp_mime_parameter_get_type</span>(mime_parameter)</span><br><span class="line">					,<span class="built_in">belle_sdp_mime_parameter_get_rate</span>(mime_parameter));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">belle_sdp_media_description_set_attribute_value</span>(media_description,<span class="string">&quot;rtpmap&quot;</span>,atribute_value);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BELLE_SDP_FORCE_RTP_MAP</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// always include fmtp parameters if available</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">belle_sdp_mime_parameter_get_parameters</span>(mime_parameter)) &#123;</span><br><span class="line">		<span class="built_in">snprintf</span>(atribute_value,MAX_FMTP_LENGTH,<span class="string">&quot;%i %s&quot;</span></span><br><span class="line">				,<span class="built_in">belle_sdp_mime_parameter_get_media_format</span>(mime_parameter)</span><br><span class="line">				,<span class="built_in">belle_sdp_mime_parameter_get_parameters</span>(mime_parameter));</span><br><span class="line">		<span class="built_in">belle_sdp_media_description_set_attribute_value</span>(media_description,<span class="string">&quot;fmtp&quot;</span>,atribute_value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先分析下<code>mime_parameter_is_static</code>方法是干什么的？查看以下源码发现，噢~~，原来是用于判断编解码是否是静态类型(前面提到的Payload Type)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">static_payload</span> static_payload_list [] =&#123;</span><br><span class="line">	<span class="comment">/*audio*/</span></span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;PCMU&quot;</span>,<span class="number">8000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="string">&quot;GSM&quot;</span>,<span class="number">8000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="string">&quot;G723&quot;</span>,<span class="number">8000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">5</span>,<span class="number">1</span>,<span class="string">&quot;DVI4&quot;</span>,<span class="number">8000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">6</span>,<span class="number">1</span>,<span class="string">&quot;DVI4&quot;</span>,<span class="number">16000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">7</span>,<span class="number">1</span>,<span class="string">&quot;LPC&quot;</span>,<span class="number">8000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">8</span>,<span class="number">1</span>,<span class="string">&quot;PCMA&quot;</span>,<span class="number">8000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="string">&quot;G722&quot;</span>,<span class="number">8000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">10</span>,<span class="number">2</span>,<span class="string">&quot;L16&quot;</span>,<span class="number">44100</span>&#125;,</span><br><span class="line">	&#123;<span class="number">11</span>,<span class="number">1</span>,<span class="string">&quot;L16&quot;</span>,<span class="number">44100</span>&#125;,</span><br><span class="line">	&#123;<span class="number">12</span>,<span class="number">1</span>,<span class="string">&quot;QCELP&quot;</span>,<span class="number">8000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">13</span>,<span class="number">1</span>,<span class="string">&quot;CN&quot;</span>,<span class="number">8000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">14</span>,<span class="number">1</span>,<span class="string">&quot;MPA&quot;</span>,<span class="number">90000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">15</span>,<span class="number">1</span>,<span class="string">&quot;G728&quot;</span>,<span class="number">8000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">16</span>,<span class="number">1</span>,<span class="string">&quot;DVI4&quot;</span>,<span class="number">11025</span>&#125;,</span><br><span class="line">	&#123;<span class="number">17</span>,<span class="number">1</span>,<span class="string">&quot;DVI4&quot;</span>,<span class="number">22050</span>&#125;,</span><br><span class="line">	&#123;<span class="number">18</span>,<span class="number">1</span>,<span class="string">&quot;G729&quot;</span>,<span class="number">8000</span>&#125;,</span><br><span class="line">	<span class="comment">/*video*/</span></span><br><span class="line">	&#123;<span class="number">25</span>,<span class="number">0</span>,<span class="string">&quot;CelB&quot;</span>,<span class="number">90000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">26</span>,<span class="number">0</span>,<span class="string">&quot;JPEG&quot;</span>,<span class="number">90000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">28</span>,<span class="number">0</span>,<span class="string">&quot;nv&quot;</span>,<span class="number">90000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">31</span>,<span class="number">0</span>,<span class="string">&quot;H261&quot;</span>,<span class="number">90000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">32</span>,<span class="number">0</span>,<span class="string">&quot;MPV&quot;</span>,<span class="number">90000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">33</span>,<span class="number">0</span>,<span class="string">&quot;MP2T&quot;</span>,<span class="number">90000</span>&#125;,</span><br><span class="line">	&#123;<span class="number">34</span>,<span class="number">0</span>,<span class="string">&quot;H263&quot;</span>,<span class="number">90000</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mime_parameter_is_static</span><span class="params">(<span class="type">const</span> <span class="type">belle_sdp_mime_parameter_t</span> *param)</span></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">static_payload</span>* iterator;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (iterator = static_payload_list,i=<span class="number">0</span>;i&lt;payload_list_elements;i++,iterator++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (iterator-&gt;number == param-&gt;media_format &amp;&amp;</span><br><span class="line">			<span class="built_in">strcasecmp</span>(iterator-&gt;type,param-&gt;type)==<span class="number">0</span> &amp;&amp;</span><br><span class="line">			iterator-&gt;channel_count==param-&gt;channel_count &amp;&amp;</span><br><span class="line">			iterator-&gt;rate==param-&gt;rate ) &#123;</span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再来分析下<code>belle_sdp_media_description_append_values_from_mime_parameter</code>方法的意思，大意如下：如果没有定义<code>BELLE_SDP_FORCE_RTP_MAP</code>这个宏就执行<code>if (!mime_parameter_is_static(mime_parameter))</code>判断编解码是否是静态类型，如果定义了就不判断是否是静态类型</p>
<p>总结一下就是如果没有定义<code>BELLE_SDP_FORCE_RTP_MAP</code>这个宏，就不组装静态类型编解码的<code>rtpmap</code>信息，只组装动态类型编解码的<code>rtpmap</code>信息，终于找到源头了，真是拨云见日呀</p>
<p>到这里还没完，既然是根据宏定义做的判断，肯定在编译的时候可以配置，先看看能不能找到定义宏的地方，在IDE中全局搜索，在<code>belle-sip</code>下的<code>CMakeList.txt</code>中发现</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(ENABLE_RTP_MAP_ALWAYS_IN_SDP <span class="string">&quot;Always include rtpmap in SDP.&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ENABLE_RTP_MAP_ALWAYS_IN_SDP) </span><br><span class="line">	<span class="keyword">set</span>(BELLE_SDP_FORCE_RTP_MAP <span class="number">1</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>bingo~，真的是到最后了</p>
<p>最后在编译时增加编译配置项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> linphone-sdk/build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -DENABLE_RTP_MAP_ALWAYS_IN_SDP=ON ..</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --build . --parallel 8</span></span><br></pre></td></tr></table></figure>
<p>重新编译后拷贝到AS中运行，发起呼叫查看Logcat输出</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>在源码中看到通过<code>BELLE_SDP_FORCE_RTP_MAP</code>这个宏控制是否在SDP中包含静态类型编解码的<code>rtpmap</code>信息，个人猜测是静态类型的编解码信息，是协议中固定的，任何遵循协议的实现方，都可以根据静态类型编解码对应的<code>code</code>解析出相应的<code>rtpmap</code>信息，所以在SDP中去掉静态类型编解码器的<code>rtpmap</code>信息，同时也可以减少发送数据包的大小，减轻网络压力</p>
]]></content>
      <categories>
        <category>linphone-sdk-android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>linphone-sdk-android</tag>
      </tags>
  </entry>
  <entry>
    <title>修改linphone-sdk-android-第二篇</title>
    <url>/2022/04/24/linphone-sdk-android/%E4%BF%AE%E6%94%B9linphone-sdk-android-%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
    <content><![CDATA[<h1 id="修改linphone-sdk-android-中篇"><a class="markdownIt-Anchor" href="#修改linphone-sdk-android-中篇"></a> 修改linphone-sdk-android-中篇</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>接上篇<a href="https://juejin.cn/post/7089664949907095559">修改linphone-sdk-android-上篇</a></p>
<p>本文是中篇，本篇记录问题2的后续排查过程及修复方案，尽量描述排查问题过程中的思路与方向</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>上篇说到增加日志，编译后放到AS中运行，查看Logcat输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// up不为NULL</span><br><span class="line">2022-04-24 18:10:36.969 4002-4018/com.guodong.android.linphone D/guodongAndroid: up = 0x100433</span><br><span class="line">2022-04-24 18:10:36.969 4002-4018/com.guodong.android.linphone D/guodongAndroid: up_available1 = 0</span><br><span class="line">2022-04-24 18:10:36.969 4002-4018/com.guodong.android.linphone D/guodongAndroid: up_available2 = 0</span><br><span class="line"></span><br><span class="line">// up为NULL</span><br><span class="line">2022-04-24 18:10:39.669 4002-4018/com.guodong.android.linphone D/guodongAndroid: up = 0x0</span><br><span class="line">2022-04-24 18:10:39.669 4002-4018/com.guodong.android.linphone D/guodongAndroid: up_available1 = 1</span><br><span class="line">2022-04-24 18:10:39.669 4002-4018/com.guodong.android.linphone D/guodongAndroid: up_available2 = 1</span><br></pre></td></tr></table></figure>
<p>从日志中可以看出，有时<code>up</code>是<code>NULL</code>的，猜想有销毁的方法，再次查看<code>linphone_jni.cc</code>，发现有一个<code>unref</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jboolean JNICALL <span class="title">Java_org_linphone_core_LoggingServiceImpl_unref</span><span class="params">(JNIEnv* env, jobject thiz, jlong ptr)</span> </span>&#123;</span><br><span class="line">	LinphoneLoggingService *cptr = (LinphoneLoggingService*)ptr;</span><br><span class="line">	<span class="keyword">if</span> (cptr == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">bctbx_error</span>(<span class="string">&quot;Java_org_linphone_core_LoggingServiceImpl_unref&#x27;s LinphoneLoggingService C ptr is null!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jobject wref = (jobject)<span class="built_in">belle_sip_object_data_get</span>((<span class="type">belle_sip_object_t</span> *)cptr, belle_sip_java_user_data_key);</span><br><span class="line">	<span class="built_in">belle_sip_object_data_set</span>((<span class="type">belle_sip_object_t</span> *)cptr, belle_sip_java_user_data_key, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (wref) &#123;</span><br><span class="line">		env-&gt;<span class="built_in">DeleteWeakGlobalRef</span>(wref);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">belle_sip_object_unref_2</span>(cptr) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，看来这个就是销毁方法了，通过<code>belle_sip_object_data_get</code>方法取出值，再通过<code>belle_sip_object_data_set</code>方法设置为<code>nullptr</code>，然后删除全局弱引用</p>
<p>这个方法也加点日志输出吧，打开<code>jni.mustache</code>，找到模板方法，添加日志输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jboolean JNICALL Java_&#123;&#123;jniPrefix&#125;&#125;&#123;&#123;classImplName&#125;&#125;_unref(JNIEnv* env, jobject thiz, jlong ptr) &#123;</span><br><span class="line">	&#123;&#123;classCName&#125;&#125; *cptr = (&#123;&#123;classCName&#125;&#125;*)ptr;</span><br><span class="line">	if (cptr == 0) &#123;</span><br><span class="line">		bctbx_error(&quot;Java_&#123;&#123;jniPrefix&#125;&#125;&#123;&#123;classImplName&#125;&#125;_unref&#x27;s &#123;&#123;classCName&#125;&#125; C ptr is null!&quot;);</span><br><span class="line">		return TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jobject wref = (jobject)belle_sip_object_data_get((belle_sip_object_t *)cptr, belle_sip_java_user_data_key);</span><br><span class="line"></span><br><span class="line">	// begin - added</span><br><span class="line">	&#123;&#123;#isLoggingService&#125;&#125;</span><br><span class="line">    #ifdef __ANDROID__</span><br><span class="line">    __android_log_print(ANDROID_LOG_DEBUG, &quot;guodongAndroid&quot;, &quot;unref wref = %p&quot;, wref);</span><br><span class="line">    #endif /* __ANDROID__ */</span><br><span class="line">    &#123;&#123;/isLoggingService&#125;&#125;</span><br><span class="line">  	// end - added</span><br><span class="line"></span><br><span class="line">	belle_sip_object_data_set((belle_sip_object_t *)cptr, belle_sip_java_user_data_key, nullptr, nullptr);</span><br><span class="line">	if (wref) &#123;</span><br><span class="line">		env-&gt;DeleteWeakGlobalRef(wref);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;&#123;#refCountable&#125;&#125;return belle_sip_object_unref_2(cptr) == 1;&#123;&#123;/refCountable&#125;&#125;</span><br><span class="line">	&#123;&#123;#notRefCountable&#125;&#125;return FALSE;&#123;&#123;/notRefCountable&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译后放到AS中运行，查看Logcat输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-04-24 18:18:52.359 4240-4249/com.guodong.android.linphone D/guodongAndroid: unref wref = 0x1002e3</span><br><span class="line">2022-04-24 18:19:02.296 4240-4257/com.guodong.android.linphone D/guodongAndroid: up = 0x0</span><br><span class="line">2022-04-24 18:19:02.296 4240-4257/com.guodong.android.linphone D/guodongAndroid: up_available1 = 1</span><br><span class="line">2022-04-24 18:19:02.296 4240-4257/com.guodong.android.linphone D/guodongAndroid: up_available2 = 1</span><br></pre></td></tr></table></figure>
<p>从日志中可以分析出两点：</p>
<ol>
<li>的确有销毁的方法被调用</li>
<li>调用<code>unref</code>方法的线程与调用<code>getLoggingService</code>方法的线程不同</li>
</ol>
<p>结合以上两点，大胆的猜测问题出在多线程上，在多线程上此问题是偶现的就不奇怪了</p>
<p>出问题时，日志输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-04-24 18:25:02.296 4240-4257/com.guodong.android.linphone D/guodongAndroid: up = 0x20004f</span><br><span class="line">2022-04-24 18:25:02.296 4240-4257/com.guodong.android.linphone D/guodongAndroid: up_available1 = 1</span><br><span class="line">2022-04-24 18:25:02.296 4240-4249/com.guodong.android.linphone D/guodongAndroid: unref wref = 0x1002e3</span><br><span class="line">App Crash</span><br></pre></td></tr></table></figure>
<p>多线程问题，第一想法是通过加锁，保证代码间调用的互斥性</p>
<p>再次打开<code>jni.mustache</code>，添加互斥锁相关代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Added by guodongAndroid on 2022/04/22</span><br><span class="line">#ifdef __ANDROID__</span><br><span class="line">static pthread_mutex_t mutex;</span><br><span class="line">#endif /* __ANDROID__ */</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *ajvm, void *reserved) &#123;</span><br><span class="line">#ifdef __ANDROID__</span><br><span class="line">	ms_set_jvm(ajvm);</span><br><span class="line">	int result = pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">	__android_log_print(ANDROID_LOG_DEBUG, &quot;guodongAndroid&quot;, &quot;JNI_OnLoad, mutex init result = %d&quot;, result);</span><br><span class="line">#endif /* __ANDROID__ */</span><br><span class="line">	jvm = ajvm;</span><br><span class="line">	return JNI_VERSION_1_2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Added by guodongAndroid on 2022/04/22</span><br><span class="line">JNIEXPORT void JNI_OnUnload(JavaVM *ajvm, void *reserved) &#123;</span><br><span class="line">#ifdef __ANDROID__</span><br><span class="line">	int result = pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">	__android_log_print(ANDROID_LOG_DEBUG, &quot;guodongAndroid&quot;, &quot;JNI_OnUnload, mutex destroy result = %d&quot;, result);</span><br><span class="line">#endif /* __ANDROID__ */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;#objects&#125;&#125;</span><br><span class="line">JNIEXPORT jobject JNICALL get&#123;&#123;className&#125;&#125;(JNIEnv *env, &#123;&#123;classCName&#125;&#125; *cptr, bool_t takeref) &#123;</span><br><span class="line">	jobject jobj = nullptr;</span><br><span class="line"></span><br><span class="line">	if (cptr != nullptr) &#123;</span><br><span class="line">		// begin add</span><br><span class="line">		&#123;&#123;#isLoggingService&#125;&#125;</span><br><span class="line">		#ifdef __ANDROID__</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		#endif /* __ANDROID__ */</span><br><span class="line">		&#123;&#123;/isLoggingService&#125;&#125;</span><br><span class="line">		// end add</span><br><span class="line">		</span><br><span class="line">		void *up = belle_sip_object_data_get((belle_sip_object_t *)cptr, belle_sip_java_user_data_key);</span><br><span class="line">		LinphoneJavaBindings *ljb = (LinphoneJavaBindings *)linphone_factory_get_user_data(linphone_factory_get());</span><br><span class="line">		if (!ljb) &#123;</span><br><span class="line">			ljb = new LinphoneJavaBindings(env);</span><br><span class="line">			linphone_factory_set_user_data(linphone_factory_get(), ljb);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		jclass &#123;&#123;cPrefix&#125;&#125;_class = ljb-&gt;&#123;&#123;cPrefix&#125;&#125;_class;</span><br><span class="line">		jmethodID &#123;&#123;cPrefix&#125;&#125;_constructor = ljb-&gt;&#123;&#123;cPrefix&#125;&#125;_class_constructor;</span><br><span class="line"></span><br><span class="line">		&#123;&#123;#isLoggingService&#125;&#125;</span><br><span class="line">		#ifdef __ANDROID__</span><br><span class="line">		__android_log_print(ANDROID_LOG_DEBUG, &quot;guodongAndroid&quot;, &quot;up = %p&quot;, up);</span><br><span class="line">		</span><br><span class="line">		jobject temp_jobj1 = (jobject)up;</span><br><span class="line">		jboolean up_available1 = env-&gt;IsSameObject(temp_jobj1, NULL);</span><br><span class="line">		__android_log_print(ANDROID_LOG_DEBUG, &quot;guodongAndroid&quot;, &quot;up_available1 = %d&quot;, up_available1);</span><br><span class="line">		</span><br><span class="line">		jobject temp_jobj2 = (jobject)up;</span><br><span class="line">		jboolean up_available2 = env-&gt;IsSameObject(temp_jobj2, nullptr);</span><br><span class="line">		__android_log_print(ANDROID_LOG_DEBUG, &quot;guodongAndroid&quot;, &quot;up_available2 = %d&quot;, up_available2);</span><br><span class="line">		#endif /* __ANDROID__ */</span><br><span class="line">		&#123;&#123;/isLoggingService&#125;&#125;</span><br><span class="line"></span><br><span class="line">		if (up == nullptr) &#123;</span><br><span class="line">			jobj = env-&gt;NewObject(&#123;&#123;cPrefix&#125;&#125;_class, &#123;&#123;cPrefix&#125;&#125;_constructor, (jlong)cptr);</span><br><span class="line">			belle_sip_object_data_set((belle_sip_object_t *)cptr, belle_sip_java_user_data_key, (void*)env-&gt;NewWeakGlobalRef(jobj), nullptr);</span><br><span class="line">			if (takeref)</span><br><span class="line">				&#123;&#123;#refCountable&#125;&#125;&#123;&#123;cPrefix&#125;&#125;_ref(cptr);&#123;&#123;/refCountable&#125;&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			jobj = env-&gt;NewLocalRef((jobject)up);</span><br><span class="line">			if (jobj == nullptr) &#123;</span><br><span class="line">				// Delete weak ref ?</span><br><span class="line">				env-&gt;DeleteWeakGlobalRef((jobject)up);</span><br><span class="line">				// takes implicit local ref</span><br><span class="line">				jobj = env-&gt;NewObject(&#123;&#123;cPrefix&#125;&#125;_class, &#123;&#123;cPrefix&#125;&#125;_constructor, (jlong)cptr);</span><br><span class="line">				belle_sip_object_data_set((belle_sip_object_t *)cptr, belle_sip_java_user_data_key, (void*)env-&gt;NewWeakGlobalRef(jobj), nullptr);</span><br><span class="line">				if (takeref)</span><br><span class="line">					&#123;&#123;#refCountable&#125;&#125;&#123;&#123;cPrefix&#125;&#125;_ref(cptr);&#123;&#123;/refCountable&#125;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// begin add</span><br><span class="line">		&#123;&#123;#isLoggingService&#125;&#125;</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		&#123;&#123;/isLoggingService&#125;&#125;</span><br><span class="line">		// end add</span><br><span class="line">	&#125;</span><br><span class="line">	return jobj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jboolean JNICALL Java_&#123;&#123;jniPrefix&#125;&#125;&#123;&#123;classImplName&#125;&#125;_unref(JNIEnv* env, jobject thiz, jlong ptr) &#123;</span><br><span class="line">	&#123;&#123;classCName&#125;&#125; *cptr = (&#123;&#123;classCName&#125;&#125;*)ptr;</span><br><span class="line">	if (cptr == 0) &#123;</span><br><span class="line">		bctbx_error(&quot;Java_&#123;&#123;jniPrefix&#125;&#125;&#123;&#123;classImplName&#125;&#125;_unref&#x27;s &#123;&#123;classCName&#125;&#125; C ptr is null!&quot;);</span><br><span class="line">		return TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// begin add</span><br><span class="line">	&#123;&#123;#isLoggingService&#125;&#125;</span><br><span class="line">	#ifdef __ANDROID__</span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line">	#endif /* __ANDROID__ */</span><br><span class="line">	&#123;&#123;/isLoggingService&#125;&#125;</span><br><span class="line">	// end add</span><br><span class="line">	</span><br><span class="line">	jobject wref = (jobject)belle_sip_object_data_get((belle_sip_object_t *)cptr, belle_sip_java_user_data_key);</span><br><span class="line"></span><br><span class="line">	&#123;&#123;#isLoggingService&#125;&#125;</span><br><span class="line">    #ifdef __ANDROID__</span><br><span class="line">    __android_log_print(ANDROID_LOG_DEBUG, &quot;guodongAndroid&quot;, &quot;unref wref = %p&quot;, wref);</span><br><span class="line">    #endif /* __ANDROID__ */</span><br><span class="line">    &#123;&#123;/isLoggingService&#125;&#125;</span><br><span class="line"></span><br><span class="line">	belle_sip_object_data_set((belle_sip_object_t *)cptr, belle_sip_java_user_data_key, nullptr, nullptr);</span><br><span class="line">	if (wref) &#123;</span><br><span class="line">		env-&gt;DeleteWeakGlobalRef(wref);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// begin add</span><br><span class="line">	&#123;&#123;#isLoggingService&#125;&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">	&#123;&#123;/isLoggingService&#125;&#125;</span><br><span class="line">	// end add</span><br><span class="line">	</span><br><span class="line">	&#123;&#123;#refCountable&#125;&#125;return belle_sip_object_unref_2(cptr) == 1;&#123;&#123;/refCountable&#125;&#125;</span><br><span class="line">	&#123;&#123;#notRefCountable&#125;&#125;return FALSE;&#123;&#123;/notRefCountable&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译后拷贝到AS中运行，持续观察Logcat及运行情况</p>
]]></content>
      <categories>
        <category>linphone-sdk-android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>linphone-sdk-android</tag>
      </tags>
  </entry>
  <entry>
    <title>修改linphone-sdk-android-第四篇</title>
    <url>/2022/04/27/linphone-sdk-android/%E4%BF%AE%E6%94%B9linphone-sdk-android-%E7%AC%AC%E5%9B%9B%E7%AF%87/</url>
    <content><![CDATA[<h1 id="修改linphone-sdk-android-第四篇"><a class="markdownIt-Anchor" href="#修改linphone-sdk-android-第四篇"></a> 修改linphone-sdk-android-第四篇</h1>
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<p>在使用linphone-sdk-android过程中，发现当有一起呼叫在通话中时，又收到一起呼叫，会莫名其妙的播报振铃声音，问题是已经调用linphone-sdk-android提供的接口关闭了振铃声音</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭Ring</span></span><br><span class="line">mCore.setRing(<span class="literal">null</span>);</span><br><span class="line">mCore.setRingback(<span class="literal">null</span>);</span><br><span class="line">mCore.setRemoteRingbackTone(<span class="literal">null</span>);</span><br><span class="line">mCore.setNativeRingingEnabled(<span class="literal">false</span>);</span><br><span class="line">mCore.setRingDuringIncomingEarlyMedia(<span class="literal">false</span>);</span><br><span class="line">mCore.setVibrationOnIncomingCallEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭CallErrorTone</span></span><br><span class="line">Reason[] reasons = Reason.values();</span><br><span class="line"><span class="keyword">for</span> (Reason reason : reasons) &#123;</span><br><span class="line">    mCore.setCallErrorTone(reason, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭ToneId</span></span><br><span class="line">ToneID[] toneIds = ToneID.values();</span><br><span class="line"><span class="keyword">for</span> (ToneID toneId : toneIds) &#123;</span><br><span class="line">    mCore.setTone(toneId, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>查看Logcat输出的日志，分析发现有<code>ToneManager</code>、<code>doStartRingtone</code>等关键词</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13056-13056/com.guodong.android.linphone I/liblinphone: [ToneManager] [0x934e70ac] state changed : [None, LinphoneCallIncomingReceived]</span><br><span class="line">13056-13056/com.guodong.android.linphone I/liblinphone: [ToneManager] add new session [0x934e70ac]</span><br><span class="line">13056-13056/com.guodong.android.linphone I/liblinphone: [ToneManager] doStopToneToPlaySomethingElse</span><br><span class="line">13056-13056/com.guodong.android.linphone I/liblinphone: [ToneManager] doStartRingtone</span><br><span class="line">13056-13056/com.guodong.android.linphone I/liblinphone: [ToneManager] doStartNamedTone [2]</span><br></pre></td></tr></table></figure>
<p>打开IDE去源码中搜索一番，发现<code>tone-manager.cpp</code>，在其中找到<code>doStopToneToPlaySomethingElse</code>、<code>doStartRingtone</code>、<code>doStartNamedTone</code>方法，与Logcat日志输出吻合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToneManager::doStopToneToPlaySomethingElse</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;CallSession&gt; &amp;session)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">lInfo</span>() &lt;&lt; <span class="string">&quot;[ToneManager] &quot;</span> &lt;&lt; __func__;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isAnotherSessionInState</span>(session, State::Tone)) &#123;</span><br><span class="line">		<span class="built_in">doStopTone</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToneManager::doStartRingtone</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;CallSession&gt; &amp;session)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">lInfo</span>() &lt;&lt; <span class="string">&quot;[ToneManager] &quot;</span> &lt;&lt; __func__;</span><br><span class="line">	LinphoneCore *lc = <span class="built_in">getCore</span>()-&gt;<span class="built_in">getCCore</span>();</span><br><span class="line">    <span class="comment">// 如果有一个正在通话的呼叫就调用`doStartNamedTone`</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isAnotherSessionInState</span>(session, State::Call)) &#123;</span><br><span class="line">		<span class="comment">/* play a tone within the context of the current call */</span></span><br><span class="line">		<span class="built_in">doStartNamedTone</span>(session, LinphoneToneCallWaiting);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		MSSndCard *ringcard = lc-&gt;sound_conf.lsd_card ? lc-&gt;sound_conf.lsd_card : lc-&gt;sound_conf.ring_sndcard;</span><br><span class="line">		<span class="keyword">if</span> (ringcard &amp;&amp; !<span class="built_in">linphone_core_is_native_ringing_enabled</span>(lc)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">linphone_core_callkit_enabled</span>(lc))&#123;</span><br><span class="line">				<span class="built_in">ms_snd_card_set_stream_type</span>(ringcard, MS_SND_CARD_STREAM_RING);</span><br><span class="line">				<span class="built_in">linphone_ringtoneplayer_start</span>(lc-&gt;factory, lc-&gt;ringtoneplayer, ringcard, lc-&gt;sound_conf.local_ring, <span class="number">2000</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">ms_message</span>(<span class="string">&quot;Callkit is enabled, not playing ringtone.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToneManager::doStartNamedTone</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;CallSession&gt; &amp;session, LinphoneToneID toneId)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">lInfo</span>() &lt;&lt; <span class="string">&quot;[ToneManager] &quot;</span> &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; Utils::<span class="built_in">toString</span>(toneId) &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	LinphoneToneDescription *tone = <span class="built_in">getToneFromId</span>(toneId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Java中已将audiofile置为&quot;&quot;，所以会走else分支</span></span><br><span class="line">	<span class="keyword">if</span> (tone &amp;&amp; tone-&gt;audiofile) &#123;</span><br><span class="line">		<span class="built_in">playFile</span>(tone-&gt;audiofile);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 此处生成振铃声音</span></span><br><span class="line">		MSDtmfGenCustomTone dtmfTone = <span class="built_in">generateToneFromId</span>(toneId);</span><br><span class="line">		<span class="built_in">playTone</span>(session, dtmfTone);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，现在先找到调用<code>doStopToneToPlaySomethingElse</code>的方法，在IDE中查找，发现<code>startRingtone</code>方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToneManager::printDebugInfo</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;CallSession&gt; &amp;session)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> callState = session-&gt;<span class="built_in">getState</span>();</span><br><span class="line">    <span class="keyword">auto</span> toneState = <span class="built_in">getState</span>(session);</span><br><span class="line">	<span class="built_in">lInfo</span>() &lt;&lt; <span class="string">&quot;[ToneManager] [&quot;</span> &lt;&lt; session &lt;&lt; <span class="string">&quot;] state changed : [&quot;</span> &lt;&lt; <span class="built_in">stateToString</span>(toneState)  &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; Utils::<span class="built_in">toString</span>(callState) &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToneManager::startRingtone</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;CallSession&gt; &amp;session)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printDebugInfo</span>(session); <span class="comment">// 对应Logcat第一行输出日志</span></span><br><span class="line">	<span class="built_in">setState</span>(session, State::Ringtone); <span class="comment">// 对应Logcat第二行输出日志</span></span><br><span class="line">    <span class="comment">// 如果另外一个呼叫不在Ringtone且不在Ringback状态</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">isAnotherSessionInState</span>(session, State::Ringtone) &amp;&amp; !<span class="built_in">isAnotherSessionInState</span>(session, State::Ringback)) &#123;</span><br><span class="line">		<span class="built_in">doStopToneToPlaySomethingElse</span>(session);</span><br><span class="line">		<span class="built_in">doStartRingtone</span>(session);</span><br><span class="line">		mStats-&gt;number_of_startRingtone++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看<code>ToneManager::startRingtone</code>下面的<code>startErrorTone</code>方法，发现此方法是调用<code>linphone_core_tone_indications_enabled</code>判断是否可以播报Tone，猜想可以在<code>startRingtone</code>方法中也增加此判断逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToneManager::startErrorTone</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;CallSession&gt; &amp;session, LinphoneReason reason)</span> </span>&#123;</span><br><span class="line">	LinphoneCore *lc = <span class="built_in">getCore</span>()-&gt;<span class="built_in">getCCore</span>();</span><br><span class="line">    <span class="comment">// 此处判断是否可以播报Tone</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">linphone_core_tone_indications_enabled</span>(lc)) &#123;</span><br><span class="line">		<span class="built_in">printDebugInfo</span>(session);</span><br><span class="line">		<span class="built_in">doStopToneToPlaySomethingElse</span>(session);</span><br><span class="line">		<span class="built_in">doStartErrorTone</span>(session, reason);</span><br><span class="line">		mStats-&gt;number_of_startErrorTone++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过需要先了解下<code>linphone_core_tone_indications_enabled</code>方法的实现，此方法位于<code>msic.c</code>中，方法内部从<code>linphone_config</code>中读取<code>sound</code>section下<code>tone_indications</code>key的值转换为<code>bool_t</code>类型，大于0为Ture，小于等于0为Flase，其中<code>linphone_config</code>可以从Java层配置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool_t</span> <span class="title">linphone_core_tone_indications_enabled</span><span class="params">(LinphoneCore*lc)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !!<span class="built_in">linphone_config_get_int</span>(lc-&gt;config,<span class="string">&quot;sound&quot;</span>,<span class="string">&quot;tone_indications&quot;</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，问题分析完毕，可以在<code>startRingtone</code>方法中也增加此判断逻辑了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToneManager::startRingtone</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;CallSession&gt; &amp;session)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printDebugInfo</span>(session);</span><br><span class="line">	<span class="built_in">setState</span>(session, State::Ringtone);</span><br><span class="line">	<span class="comment">// modified by guodongAndroid on 2022/04/24 修改有正在通话的呼叫时，又收到一起呼叫播报Ringtone问题</span></span><br><span class="line">	<span class="comment">// 增加tone_indications是否开启判断</span></span><br><span class="line">	LinphoneCore *lc = <span class="built_in">getCore</span>()-&gt;<span class="built_in">getCCore</span>();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">linphone_core_tone_indications_enabled</span>(lc)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">isAnotherSessionInState</span>(session, State::Ringtone) &amp;&amp; !<span class="built_in">isAnotherSessionInState</span>(session, State::Ringback)) &#123;</span><br><span class="line">		<span class="built_in">doStopToneToPlaySomethingElse</span>(session);</span><br><span class="line">		<span class="built_in">doStartRingtone</span>(session);</span><br><span class="line">		mStats-&gt;number_of_startRingtone++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存重新编译，等待编译完成拷贝至AS中，现在只需在Java层初始化时配置Config，修改<code>tone_indications</code>的值即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modified by guodongAndroid on 2022/04/24 修改有正在通话的呼叫时，又收到一起呼叫播报Ringtone问题</span></span><br><span class="line"><span class="comment">// 关闭ToneIndications</span></span><br><span class="line">mCore.getConfig().setInt(<span class="string">&quot;sound&quot;</span>, <span class="string">&quot;tone_indications&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>happy~</p>
]]></content>
      <categories>
        <category>linphone-sdk-android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>linphone-sdk-android</tag>
      </tags>
  </entry>
  <entry>
    <title>编译linphone-sdk-android</title>
    <url>/2022/04/17/linphone-sdk-android/%E7%BC%96%E8%AF%91linphone-sdk-android/</url>
    <content><![CDATA[<h1 id="编译linphone-sdk-android"><a class="markdownIt-Anchor" href="#编译linphone-sdk-android"></a> 编译linphone-sdk-android</h1>
<h2 id="编译环境"><a class="markdownIt-Anchor" href="#编译环境"></a> 编译环境</h2>
<p>系统 Ubuntu 20.04.4 LTS  2核4G 50G存储 i5-8250U 1.60Ghz</p>
<p>Android SDK r24.4.1</p>
<p>Android NDK r18b</p>
<p>Linphone SDK  Release 4.5</p>
<p>CMake 3.16.3</p>
<p>Python 3.8.10</p>
<p>Git 2.15.1</p>
<p>Java 1.8.0_312</p>
<h2 id="android环境准备"><a class="markdownIt-Anchor" href="#android环境准备"></a> Android环境准备</h2>
<p>安装 Android SDK NDK cmdline-tools</p>
<p>NDK：<a href="https://developer.android.google.cn/ndk/downloads?hl=en">https://developer.android.google.cn/ndk/downloads?hl=en</a></p>
<p>SDK：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fdl.google.com%2Fandroid%2Fandroid-sdk_r24.4.1-linux.tgz">https://links.jianshu.com/go?to=http%3A%2F%2Fdl.google.com%2Fandroid%2Fandroid-sdk_r24.4.1-linux.tgz</a></p>
<p>Cmdline：<a href="https://dl.google.com/android/repository/commandlinetools-linux-6200805_latest.zip">https://dl.google.com/android/repository/commandlinetools-linux-6200805_latest.zip</a></p>
<p>三个压缩包下载之后，将NDK和SDK解压，commandlinetools-linux-6200805_latest.zip 解压后将解压出来的tools文件夹放在sdk根目录的cmdline-tools文件夹里边，如果没有cmdline-tools文件夹，就手动创建一个。放好文件之后需要配置环境变量,在~/ .profile文件下末尾添加一下内容，路径换成你自己的文件路径</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">JAVA_HOME</span>=你自己的路径</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$JAVA_HOME</span>:$PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">ANDROID_HOME</span>=你自己的路径/android-sdk-linux</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$ANDROID_HOME</span>/tools:$ANDROID_HOME/platform-tools:$ANDROID_HOME/cmdline-tools/tools/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">NDK_HOME</span>=你自己的路径/android-ndk-r18b</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$NDK_HOME</span>:$PATH</span><br></pre></td></tr></table></figure>
<h2 id="ubuntu环境准备"><a class="markdownIt-Anchor" href="#ubuntu环境准备"></a> Ubuntu环境准备</h2>
<h3 id="安装cmake"><a class="markdownIt-Anchor" href="#安装cmake"></a> 安装cmake</h3>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install cmake</span><br></pre></td></tr></table></figure>
<h3 id="安装git"><a class="markdownIt-Anchor" href="#安装git"></a> 安装git</h3>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install git</span><br></pre></td></tr></table></figure>
<h3 id="安装java"><a class="markdownIt-Anchor" href="#安装java"></a> 安装java</h3>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
<h3 id="安装yasm"><a class="markdownIt-Anchor" href="#安装yasm"></a> 安装yasm</h3>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install yasm</span><br></pre></td></tr></table></figure>
<h3 id="安装nasm"><a class="markdownIt-Anchor" href="#安装nasm"></a> 安装nasm</h3>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install nasm</span><br></pre></td></tr></table></figure>
<h3 id="安装doxygen"><a class="markdownIt-Anchor" href="#安装doxygen"></a> 安装doxygen</h3>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install doxygen</span><br></pre></td></tr></table></figure>
<h3 id="安装clang"><a class="markdownIt-Anchor" href="#安装clang"></a> 安装clang</h3>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install clang</span><br></pre></td></tr></table></figure>
<h3 id="安装gmultilib"><a class="markdownIt-Anchor" href="#安装gmultilib"></a> 安装g+±multilib</h3>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install g++-multilib</span><br></pre></td></tr></table></figure>
<h3 id="安装pip"><a class="markdownIt-Anchor" href="#安装pip"></a> 安装pip</h3>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install python3-pip</span><br></pre></td></tr></table></figure>
<h3 id="配置pip源"><a class="markdownIt-Anchor" href="#配置pip源"></a> 配置pip源</h3>
<p>编辑<code>~/.pip/pip.conf</code>，若没有此文件自行创建，填写以下内容：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line"><span class="keyword">index</span>-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line"><span class="keyword">trusted</span>-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>
<h3 id="安装pystache"><a class="markdownIt-Anchor" href="#安装pystache"></a> 安装pystache</h3>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> pystache</span><br></pre></td></tr></table></figure>
<h3 id="安装six"><a class="markdownIt-Anchor" href="#安装six"></a> 安装six</h3>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> six</span><br></pre></td></tr></table></figure>
<h3 id="android-sdk-协议授予"><a class="markdownIt-Anchor" href="#android-sdk-协议授予"></a> Android SDK 协议授予</h3>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">yes | sdkmanager</span> <span class="literal">--</span><span class="comment">licenses &amp;&amp; sdkmanager</span> <span class="literal">--</span><span class="comment">update</span></span><br></pre></td></tr></table></figure>
<p>编译前环境基本准备完毕。</p>
<h2 id="编译linphone-sdk"><a class="markdownIt-Anchor" href="#编译linphone-sdk"></a> 编译Linphone SDK</h2>
<h3 id="下载源码"><a class="markdownIt-Anchor" href="#下载源码"></a> 下载源码</h3>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ git clone -b release<span class="regexp">/4.5 https:/</span><span class="regexp">/gitlab.linphone.org/</span>BC<span class="regexp">/public/</span>linphone-sdk.git --recursive</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ol>
<li>根据个人网络情况，可能需要挂VPN</li>
<li>clone需要加<code>--recursive</code>，因为linphone-sdk使用git submodule功能搭建，引用了十几个module，<code>--recursive</code>会在clone的时候把引用的module也下载下来</li>
</ol>
<p>处理下文件可执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+x linphone-sdk/cmake/Android/gradlew</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+x linphone-sdk/external/libvpx/configure</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+x linphone-sdk/cmake/dummy.sh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u+x linphone-sdk/external/libvpx/build/make/*</span></span><br></pre></td></tr></table></figure>
<h3 id="开始编译"><a class="markdownIt-Anchor" href="#开始编译"></a> 开始编译</h3>
<p>到这里一切准备就绪，可以开始编译了，创建build文件夹，编译过程产物都在build文件夹里</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ cd linphone-sdk</span><br><span class="line">$ mkdir build &amp;&amp; cd build</span><br><span class="line">$ cmake <span class="attribute">-DCMAKE_VERBOSE_MAKEFILE</span>=ON <span class="attribute">-DLINPHONESDK_PLATFORM</span>=Android <span class="attribute">-DLINPHONESDK_ANDROID_ARCHS</span>=arm64,armv7,x86,x86_64 <span class="attribute">-DENABLE_G729</span>=<span class="literal">YES</span> <span class="built_in">..</span></span><br><span class="line">$ cmake --build . --parallel 8</span><br></pre></td></tr></table></figure>
<p>目前是指定编译目标平台是Android，编译目标CPU架构是arm64/armv7,x86,x86_64，并开启G729音频编解码，开启8个线程编译，在目前编译环境下，整编一次耗时大约一个半小时，后续增量编译会快不少</p>
<p>不需要x86,x86_64架构的，可以删除。</p>
<p>目前编译过程中没有报错，happy~~~</p>
<p>编译完成后的产物在以下目录：</p>
<ul>
<li>.so：build/libs/</li>
<li>aar：build/linphone-sdk/bin/outputs/aar/</li>
<li>maven：build/maven_repository</li>
</ul>
<p>最后创建一个编译脚本<code>build.sh</code>，把上面的编译命令复制到文件里保存，每次编译时执行编译脚本即可<code>./build.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">cmake -DCMAKE_VERBOSE_MAKEFILE=ON -DLINPHONESDK_PLATFORM=Android -DLINPHONESDK_ANDROID_ARCHS=arm64,armv7,x86,x86_64 -DENABLE_G729=YES ..</span><br><span class="line">cmake --build . --parallel 8</span><br></pre></td></tr></table></figure>
<h2 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h2>
<p><a href="https://gitlab.linphone.org/BC/public/linphone-sdk">官方文档</a></p>
<p><a href="https://www.jianshu.com/p/942f989eaac7">LinPhone Android SDK 编译过程</a></p>
<p><a href="https://www.codenong.com/cs106423576/">编译linphone Android</a></p>
]]></content>
      <categories>
        <category>linphone-sdk-android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>linphone-sdk-android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-自定义View-仿某米的触摸屏测试</title>
    <url>/2022/07/28/Android/TouchView/touch-view/</url>
    <content><![CDATA[<h1 id="android-自定义view-仿某米的触摸屏测试"><a class="markdownIt-Anchor" href="#android-自定义view-仿某米的触摸屏测试"></a> Android-自定义View-仿某米的触摸屏测试</h1>
<p>携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第 1 天，<a href="https://juejin.cn/post/7123120819437322247">点击查看活动详情</a></p>
<hr />
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<p>因项目需求变更，公司内的工厂测试程序重写，之前的触摸屏测试已不符合项目需求，遂对比了某米和某为的触摸屏测试效果，个人觉得某米的效果不错，虽然最后没有被采纳，但是这不妨碍我们实现一下某米的触摸屏测试。可能因机型不同，打开某米的触摸屏测试的方式也不尽相同，读者请自行百度相应机型的方式。</p>
<img data-src="/imgs/android/touch-view/mi.jpg" alt="mi" style="zoom:30%;" />
<p>某米的触摸屏测试如上图所示，我们简单分析一下：</p>
<ul>
<li>屏幕四周、垂直居中和水平居中有绘制单元格，触摸后会重绘颜色。</li>
<li>屏幕两个对角线有类似于管道的图案，此图案重绘只能从绘制 X 号的地方开始，一直到管道对端的 X 号地方为止，如果期间手指触摸超出管道的范围即失败。</li>
<li>手指触摸在单元格与管道内的区域滑动时，屏幕会显示滑动轨迹，如果超出区域，则轨迹消失。</li>
<li>所有单元格与两条管道重绘完毕则测试完成。</li>
</ul>
<h2 id="绘制单元格"><a class="markdownIt-Anchor" href="#绘制单元格"></a> 绘制单元格</h2>
<p>思路如下：以左上角的单元格为起点，计算出所有单元格的坐标保存起来，最后在 <code>onDraw</code> 方法中遍历单元格组，根据坐标进行绘制。</p>
<p>首先定义单元格的基准宽高与最终宽高变量：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> itemWidthBasic = <span class="number">90</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> itemHeightBasic = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> itemWidth = -<span class="number">1F</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> itemHeight = -<span class="number">1F</span></span><br></pre></td></tr></table></figure>
<p>其次定义自定义 View 的宽高变量：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> viewWidth: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> viewHeight: <span class="built_in">Int</span> = -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>最后定义单元格在宽高方向上的数量变量：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> widthCount = -<span class="number">1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> heightCount = -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>定义绘制单元格的画笔：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> boxPaint <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    Paint(Paint.ANTI_ALIAS_FLAG).apply &#123;</span><br><span class="line">        color = Color.GRAY</span><br><span class="line">        style = Paint.Style.STROKE</span><br><span class="line">        strokeWidth = <span class="number">2F</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 TouchRectF 实体，对 RectF 包装一层，增加 <code>isReDrawable</code> 变量，单元格被触摸重绘后标记为 True：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">TouchRectF</span>(<span class="keyword">val</span> rectF: RectF, <span class="keyword">var</span> isReDrawable: <span class="built_in">Boolean</span> = <span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        isReDrawable = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义保存单元格坐标的容器，其中包含屏幕上下左右以及垂直与水平居中的坐标容器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 屏幕左侧单元格的坐标容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> leftRectFList = mutableListOf&lt;TouchRectF&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕顶部单元格的坐标容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> topRectFList = mutableListOf&lt;TouchRectF&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕右侧单元格的坐标容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> rightRectFList = mutableListOf&lt;TouchRectF&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕底部单元格的坐标容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> bottomRectFList = mutableListOf&lt;TouchRectF&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕水平居中单元格的坐标容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> centerHorizontalRectFList = mutableListOf&lt;TouchRectF&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕垂直居中单元格的坐标容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> centerVerticalRectFList = mutableListOf&lt;TouchRectF&gt;()</span><br></pre></td></tr></table></figure>
<p>选择在 <code>onLayout</code> 方法中计算所有单元格的坐标并获取 View 的宽高：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayout</span><span class="params">(changed: <span class="type">Boolean</span>, left: <span class="type">Int</span>, top: <span class="type">Int</span>, right: <span class="type">Int</span>, bottom: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom)</span><br><span class="line">    <span class="comment">// 保存 View 的宽高</span></span><br><span class="line">    viewWidth = width</span><br><span class="line">    viewHeight = height</span><br><span class="line"></span><br><span class="line">    computeRectF()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图显示了所有单元格所在的范围：</p>
<p><img data-src="/imgs/android/touch-view/touch-view-scope.png" alt="scope" /></p>
<p>在 <code>computeRectF</code> 方法中计算单元格的宽高、数量及坐标：</p>
<ol>
<li>首先以单元格的基准宽高计算单元格宽高方向上的数量</li>
<li>其次以单元格宽高方向上的数量计算单元格的最终宽高</li>
<li>清除之前计算的结果</li>
</ol>
<p>根据上面单元格范围示意图：</p>
<ul>
<li>计算并保存左侧单元格的坐标，不包含头和尾，去掉与顶部和底部重叠的单元格</li>
<li>计算并保存顶部单元格的坐标</li>
<li>计算并保存右侧单元格的坐标，不包含头和尾，去掉与顶部和底部重叠的单元格</li>
<li>计算并保存底部单元格的坐标</li>
<li>计算并保存水平居中单元格的坐标，不包含头和尾，去掉与左侧和右侧重叠的单元格</li>
<li>计算并保存垂直居中单元格的坐标，不包含头和尾，去掉与顶部和底部重叠的单元格，且去掉与水平居中重叠的单元格</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeRectF</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 以单元格的基准宽高计算单元格宽高方向上的数量</span></span><br><span class="line">    widthCount = viewWidth / itemWidthBasic</span><br><span class="line">    heightCount = viewHeight / itemHeightBasic</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以单元格宽高方向上的数量再计算单元格的最终宽高</span></span><br><span class="line">    itemWidth = viewWidth.toFloat() / widthCount</span><br><span class="line">    itemHeight = viewHeight.toFloat() / heightCount</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空之前计算的结果</span></span><br><span class="line">    leftRectFList.clear()</span><br><span class="line">    topRectFList.clear()</span><br><span class="line">    rightRectFList.clear()</span><br><span class="line">    bottomRectFList.clear()</span><br><span class="line">    centerHorizontalRectFList.clear()</span><br><span class="line">    centerVerticalRectFList.clear()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并保存屏幕左侧单元格的坐标, 不包含头和尾, 去掉与顶部和底部重叠的单元格</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until heightCount - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> rectF = RectF(<span class="number">0F</span>, itemHeight * i, itemWidth, itemHeight * (i + <span class="number">1</span>))</span><br><span class="line">        leftRectFList.add(TouchRectF(rectF))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并保存屏幕顶部单元格的坐标</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until widthCount) &#123;</span><br><span class="line">        <span class="keyword">val</span> rectF = RectF(itemWidth * i, <span class="number">0F</span>, itemWidth * (i + <span class="number">1</span>), itemHeight)</span><br><span class="line">        topRectFList.add(TouchRectF(rectF))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并保存屏幕右侧单元格的坐标, 不包含头和尾, 去掉与顶部和底部重叠的单元格</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until heightCount - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> rectF = RectF(</span><br><span class="line">            viewWidth - itemWidth,</span><br><span class="line">            itemHeight * i,</span><br><span class="line">            viewWidth.toFloat(),</span><br><span class="line">            itemHeight * (i + <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        rightRectFList.add(TouchRectF(rectF))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并保存屏幕底部单元格的坐标</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until widthCount) &#123;</span><br><span class="line">        <span class="keyword">val</span> rectF = RectF(</span><br><span class="line">            itemWidth * i,</span><br><span class="line">            viewHeight - itemHeight,</span><br><span class="line">            itemWidth * (i + <span class="number">1</span>),</span><br><span class="line">            viewHeight.toFloat()</span><br><span class="line">        )</span><br><span class="line">        bottomRectFList.add(TouchRectF(rectF))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并保存屏幕水平居中单元格的坐标, 不包含头和尾, 去掉与左侧和右侧重叠的单元格</span></span><br><span class="line">    <span class="keyword">val</span> centerHIndex = heightCount / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until widthCount - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> rectF = RectF(</span><br><span class="line">            itemWidth * i,</span><br><span class="line">            itemHeight * centerHIndex,</span><br><span class="line">            itemWidth * (i + <span class="number">1</span>),</span><br><span class="line">            itemHeight * (centerHIndex + <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        centerHorizontalRectFList.add(TouchRectF(rectF))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并保存屏幕垂直居中单元格的坐标, 不包含头和尾, 去掉与顶部和底部重叠的单元格, 且去掉与水平居中重叠的单元格</span></span><br><span class="line">    <span class="keyword">val</span> centerVIndex = widthCount / <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> skipIndex: <span class="built_in">Int</span> = centerHIndex</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until heightCount - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 跳过与横轴交叉的部分</span></span><br><span class="line">        <span class="keyword">if</span> (i == skipIndex) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> rectF = RectF(</span><br><span class="line">            itemWidth * centerVIndex,</span><br><span class="line">            itemHeight * i,</span><br><span class="line">            itemWidth * (centerVIndex + <span class="number">1</span>),</span><br><span class="line">            itemHeight * (i + <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        centerVerticalRectFList.add(TouchRectF(rectF))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在 <code>onDraw</code> 中绘制单元格：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 单元格数量为 -1 时返回</span></span><br><span class="line">    <span class="keyword">if</span> (widthCount == -<span class="number">1</span> || heightCount == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空画布</span></span><br><span class="line">    canvas.drawColor(Color.BLACK, PorterDuff.Mode.CLEAR)</span><br><span class="line">    canvas.drawColor(Color.WHITE)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制水平方向的单元格</span></span><br><span class="line">    drawHorizontalBox(canvas)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制垂直方向的单元格</span></span><br><span class="line">    drawVerticalBox(canvas)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawHorizontalBox</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (rectF <span class="keyword">in</span> topRectFList) &#123;</span><br><span class="line">        drawBox(rectF, canvas)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (rectF <span class="keyword">in</span> centerHorizontalRectFList) &#123;</span><br><span class="line">        drawBox(rectF, canvas)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (rectF <span class="keyword">in</span> bottomRectFList) &#123;</span><br><span class="line">        drawBox(rectF, canvas)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawVerticalBox</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (rectF <span class="keyword">in</span> leftRectFList) &#123;</span><br><span class="line">        drawBox(rectF, canvas)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (rectF <span class="keyword">in</span> centerVerticalRectFList) &#123;</span><br><span class="line">        drawBox(rectF, canvas)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (rectF <span class="keyword">in</span> rightRectFList) &#123;</span><br><span class="line">        drawBox(rectF, canvas)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawBox</span><span class="params">(rectF: <span class="type">TouchRectF</span>, canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    canvas.drawRect(rectF.rectF, boxPaint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先做参数校验与画布清空</li>
<li>然后绘制水平方向的单元格，在 <code>drawHorizontalBox</code> 方法中遍历水平方向的单元格坐标容器，再调用 <code>drawBox</code> 方法传入坐标绘制单元格</li>
<li>最后绘制垂直方向的单元格，在 <code>drawVerticalBox</code> 方法中遍历垂直方向的单元格坐标容器，再调用 <code>drawBox</code> 方法传入坐标绘制单元格</li>
<li>在 <code>drawBox</code> 方法中绘制单元格</li>
</ol>
<p>效果如下：</p>
<p><img data-src="/imgs/android/touch-view/touch-view-rectf.png" alt="box" /></p>
<h2 id="绘制交叉管道"><a class="markdownIt-Anchor" href="#绘制交叉管道"></a> 绘制交叉管道</h2>
<p>上面绘制单元格比较简单一些，现在要绘制的两个管道相对复杂一些，本文为了简单，没有完全仿照某米触摸屏测试中管道的 UI 效果。</p>
<p>思路：通过 Path 连接对角两个单元格的顶点组成管道，由于 Path 闭合后，单元格的两个顶点会连接成直线，这里两个顶点的连接使用二阶贝赛尔曲线绘制一个 View 显示范围之外的弧线，这样看起来管道没有起止点，且 Path 也可以闭合，同时也方便判断触摸点是否在管道内。</p>
<p>定义管道 Path 和 Region：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> positiveCrossPath = TouchPath()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> positiveCrossRegion = Region()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> reverseCrossPath = TouchPath()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> reverseCrossRegion = Region()</span><br></pre></td></tr></table></figure>
<p>在 <code>computeRectF</code> 方法中计算管道 Path 路径：</p>
<ul>
<li>重置 Path 路径</li>
<li>计算正向管道 Path，以左下角单元格为起点，右上角单元格为终点绘制 Path。</li>
<li>计算反向管道 Path，以左上角单元格为起点，右下角单元格为终点绘制 Path。</li>
<li>下面代码中的注释说明的更多一些。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeRectF</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略计算单元格的代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重置 Path</span></span><br><span class="line">    positiveCrossPath.path.reset()</span><br><span class="line">    reverseCrossPath.path.reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PositiveCross</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取左下角单元格坐标</span></span><br><span class="line">    <span class="keyword">val</span> lbRectF = bottomRectFList.first().rectF</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取右上角单元格坐标</span></span><br><span class="line">    <span class="keyword">val</span> rtRectF = topRectFList.last().rectF</span><br><span class="line">    </span><br><span class="line">    with(positiveCrossPath.path) &#123;</span><br><span class="line">        <span class="comment">// 移动 Path 至左下角单元格的左上角顶点</span></span><br><span class="line">        moveTo(lbRectF.left, lbRectF.top)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 连接直线至右上角单元格的左上角顶点</span></span><br><span class="line">        lineTo(rtRectF.left, rtRectF.top)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以右上角单元格的右上角顶点坐标为基准计算屏幕外一点为控制点, 右上角单元格的右下角顶点为结束点绘制二阶贝赛尔曲线</span></span><br><span class="line">        quadTo(</span><br><span class="line">            rtRectF.right + itemWidth,</span><br><span class="line">            rtRectF.top - itemHeight,</span><br><span class="line">            rtRectF.right,</span><br><span class="line">            rtRectF.bottom</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 连接直线至左下角单元格的右下角顶点</span></span><br><span class="line">        lineTo(lbRectF.right, lbRectF.bottom)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以左下角单元格的左下角顶点坐标为基准计算屏幕外一点为控制点, 左下角单元格的左上角顶点为结束点绘制二阶贝赛尔曲线</span></span><br><span class="line">        quadTo(</span><br><span class="line">            lbRectF.left - itemWidth,</span><br><span class="line">            lbRectF.bottom + itemHeight,</span><br><span class="line">            lbRectF.left,</span><br><span class="line">            lbRectF.top</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 闭合 Path</span></span><br><span class="line">        close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算正向管道 Path 区域</span></span><br><span class="line">    <span class="keyword">val</span> positiveCrossRectF = RectF()</span><br><span class="line">    positiveCrossPath.path.computeBounds(positiveCrossRectF, <span class="literal">true</span>)</span><br><span class="line">    positiveCrossRegion.setPath(positiveCrossPath.path, positiveCrossRectF.toRegion())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReverseCross</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取左上角单元格坐标</span></span><br><span class="line">    <span class="keyword">val</span> ltRectF = topRectFList.first().rectF</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取右下角单元格坐标</span></span><br><span class="line">    <span class="keyword">val</span> rbRectF = bottomRectFList.last().rectF</span><br><span class="line">    </span><br><span class="line">    with(reverseCrossPath.path) &#123;</span><br><span class="line">        <span class="comment">// 移动 Path 至左上角单元格的右上角顶点</span></span><br><span class="line">        moveTo(ltRectF.right, ltRectF.top)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 连接直线只右下角单元格的右上角顶点</span></span><br><span class="line">        lineTo(rbRectF.right, rbRectF.top)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以右下角单元格的右下角顶点坐标为基准计算屏幕外一点为控制点, 右下角单元格的左下角顶点为结束点绘制二阶贝赛尔曲线</span></span><br><span class="line">        quadTo(</span><br><span class="line">            rbRectF.right + itemWidth,</span><br><span class="line">            rbRectF.bottom + itemHeight,</span><br><span class="line">            rbRectF.left,</span><br><span class="line">            rbRectF.bottom</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 连接直线至左上角单元格的左下角顶点</span></span><br><span class="line">        lineTo(ltRectF.left, ltRectF.bottom)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以左上角单元格的左下角顶点坐标为基准计算屏幕外一点为控制点, 左上角单元格的右上角顶点为结束点绘制二阶贝赛尔曲线</span></span><br><span class="line">        quadTo(</span><br><span class="line">            ltRectF.left - itemWidth,</span><br><span class="line">            ltRectF.top - itemHeight,</span><br><span class="line">            ltRectF.right,</span><br><span class="line">            ltRectF.top</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 闭合 Path</span></span><br><span class="line">        close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算反向管道 Path 区域</span></span><br><span class="line">    <span class="keyword">val</span> reverseCrossRectF = RectF()</span><br><span class="line">    reverseCrossPath.path.computeBounds(reverseCrossRectF, <span class="literal">true</span>)</span><br><span class="line">    reverseCrossRegion.setPath(reverseCrossPath.path, reverseCrossRectF.toRegion())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在 <code>onDraw</code> 方法中绘制管道：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略绘制单元格代码</span></span><br><span class="line"></span><br><span class="line">    drawPositiveCross(canvas)</span><br><span class="line">    drawReverseCross(canvas)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawReverseCross</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    canvas.drawPath(reverseCrossPath.path, boxPaint)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawPositiveCross</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    canvas.drawPath(positiveCrossPath.path, boxPaint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img data-src="/imgs/android/touch-view/touch-view.png" alt="pipe" /></p>
<h2 id="重绘单元格"><a class="markdownIt-Anchor" href="#重绘单元格"></a> 重绘单元格</h2>
<p>单元格与管道已经绘制好了，下面我们先开始重绘单元格。</p>
<p>大体思路：在手指触摸屏幕的时候判断当前触摸的屏幕坐标是否在单元格内，是的话则重绘，否则不重绘。</p>
<p>首先定义重绘单元格的画笔：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> fillPaint <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    Paint(Paint.ANTI_ALIAS_FLAG).apply &#123;</span><br><span class="line">        color = Color.GREEN</span><br><span class="line">        style = Paint.Style.FILL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为单元格与单元格、单元格与管道之间有重叠的部分，突出显示重叠部分哪块单元格没有被重绘，重绘单元格时改变单元格边框的颜色，所以需要定义重绘单元格的画笔：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> redrawBoxPaint <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    Paint(Paint.ANTI_ALIAS_FLAG).apply &#123;</span><br><span class="line">        color = Color.YELLOW</span><br><span class="line">        style = Paint.Style.STROKE</span><br><span class="line">        strokeWidth = <span class="number">3F</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重写 <code>onTouchEvent</code> 方法，在此方法中处理触摸事件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = event.x</span><br><span class="line">    <span class="keyword">val</span> y = event.y</span><br><span class="line">    <span class="keyword">when</span> (event.actionMasked) &#123;</span><br><span class="line">        MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">            <span class="comment">// 根据当前坐标查找可重绘的单元格</span></span><br><span class="line">            findReDrawableBox(x, y)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 重绘 View</span></span><br><span class="line">            invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找可重绘的单元格</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findReDrawableBox</span><span class="params">(x: <span class="type">Float</span>, y: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> touchRectF = (leftRectFList.find &#123; it.rectF.contains(x, y) &#125;</span><br><span class="line">        ?: topRectFList.find &#123; it.rectF.contains(x, y) &#125;</span><br><span class="line">        ?: rightRectFList.find &#123; it.rectF.contains(x, y) &#125;</span><br><span class="line">        ?: bottomRectFList.find &#123; it.rectF.contains(x, y) &#125;</span><br><span class="line">        ?: centerHorizontalRectFList.find &#123; it.rectF.contains(x, y) &#125;</span><br><span class="line">        ?: centerVerticalRectFList.find &#123; it.rectF.contains(x, y) &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (touchRectF != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 标记可重绘的单元格</span></span><br><span class="line">        markBoxReDrawable(touchRectF)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记可重绘的单元格</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">markBoxReDrawable</span><span class="params">(rectF: <span class="type">TouchRectF</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rectF.isReDrawable) &#123;</span><br><span class="line">        rectF.isReDrawable = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onTouchEvent</code> 方法中，我们监听 <code>ACTION_DOWN</code> 事件，根据当前触摸屏幕的坐标查找可重绘的单元格，如果查找到匹配的单元格且此单元格目前还没有被重绘，则标记此单元格为可重绘的。</p>
<p>接下来，我们重构绘制单元格的 <code>drawBox</code> 方法来重绘单元格：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重构 drawBox 方法，增加重绘代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawBox</span><span class="params">(rectF: <span class="type">TouchRectF</span>, canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前单元格是否已经标记为可重绘</span></span><br><span class="line">    <span class="keyword">if</span> (rectF.isReDrawable) &#123;</span><br><span class="line">        <span class="comment">// 重绘单元格</span></span><br><span class="line">        canvas.drawRect(rectF.rectF, redrawBoxPaint)</span><br><span class="line">        canvas.drawRect(rectF.rectF, fillPaint)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        canvas.drawRect(rectF.rectF, boxPaint)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绘制轨迹线"><a class="markdownIt-Anchor" href="#绘制轨迹线"></a> 绘制轨迹线</h2>
<p>一个个方格点击不太现实，因此增加手指滑动重绘单元格，同时增加手指滑动轨迹线绘制。</p>
<p>定义轨迹线 Path：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> linePath = Path()</span><br></pre></td></tr></table></figure>
<p>定义轨迹线画笔：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> linePaint <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    Paint(Paint.ANTI_ALIAS_FLAG).apply &#123;</span><br><span class="line">        color = Color.BLUE</span><br><span class="line">        style = Paint.Style.STROKE</span><br><span class="line">        strokeWidth = <span class="number">8F</span></span><br><span class="line">        strokeJoin = Paint.Join.ROUND</span><br><span class="line">        strokeCap = Paint.Cap.ROUND</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，需要修改 <code>onTouchEvent</code> 方法增加对滑动重绘单元格和绘制轨迹线的支持：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = event.x</span><br><span class="line">    <span class="keyword">val</span> y = event.y</span><br><span class="line">    <span class="keyword">when</span> (event.actionMasked) &#123;</span><br><span class="line">        MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">            <span class="comment">// 清空轨迹线 Path</span></span><br><span class="line">            linePath.reset()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移动轨迹线起点至点击坐标</span></span><br><span class="line">            linePath.moveTo(x, y)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据当前坐标查找可重绘的单元格</span></span><br><span class="line">            findReDrawableBox(x, y)</span><br><span class="line">        &#125;</span><br><span class="line">        MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断当前坐标是否在单元格和管道区域内</span></span><br><span class="line">            <span class="keyword">if</span> (isInTouchableRegion(x, y)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (linePath.isEmpty) &#123;</span><br><span class="line">                    <span class="comment">// 如果被重置了，先移动起点至当前坐标</span></span><br><span class="line">                    linePath.moveTo(x, y)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有被重置，连接直线至当前坐标</span></span><br><span class="line">                    linePath.lineTo(x, y)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据当前坐标查找可重绘的单元格</span></span><br><span class="line">                findReDrawableBox(x, y)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 清空轨迹线 Path</span></span><br><span class="line">                linePath.reset()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 重绘View</span></span><br><span class="line">            invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">        MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class="line">            <span class="comment">// 清空轨迹线 Path</span></span><br><span class="line">            linePath.reset()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 重绘View</span></span><br><span class="line">            invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前坐标是否在单元格和管道区域内</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInTouchableRegion</span><span class="params">(x: <span class="type">Float</span>, y: <span class="type">Float</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftRectFList.any &#123; it.rectF.contains(x, y) &#125; ||</span><br><span class="line">    		topRectFList.any &#123; it.rectF.contains(x, y) &#125; ||</span><br><span class="line">    		rightRectFList.any &#123; it.rectF.contains(x, y) &#125; ||</span><br><span class="line">    		bottomRectFList.any &#123; it.rectF.contains(x, y) &#125; ||</span><br><span class="line">    		centerHorizontalRectFList.any &#123; it.rectF.contains(x, y) &#125; ||</span><br><span class="line">    		centerVerticalRectFList.any &#123; it.rectF.contains(x, y) &#125; ||</span><br><span class="line">    		positiveCrossRegion.contains(x.toInt(), y.toInt()) ||</span><br><span class="line">    		reverseCrossRegion.contains(x.toInt(), y.toInt())</span><br></pre></td></tr></table></figure>
<p>首先在 <code>ACTION_DOWN</code> 中清空轨迹线 Path，并移动轨迹线起点至当前坐标。</p>
<p>然后在 <code>ACTION_MOVE</code> 中先判断当前坐标是否在单元格和管道区域内，如果不在区域内，不绘制轨迹线，则重置轨迹线 Path；否则再判断轨迹线 Path 是否为空，为空认为已经被重置，先移动轨迹线起点至当前坐标，否则认为没有被重置，连接直线至当前坐标；最后重绘 View。</p>
<p>接下来修改 <code>onDraw</code> 方格，增加轨迹线的绘制：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略绘制单元格和管道代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制轨迹线</span></span><br><span class="line">    drawTrackLine(canvas)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawTrackLine</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断轨迹线 Path 是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (linePath.isEmpty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制轨迹线</span></span><br><span class="line">    canvas.drawPath(linePath, linePaint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img data-src="/imgs/android/touch-view/touch-view-line.png" alt="line" /></p>
<h2 id="重绘交叉管道"><a class="markdownIt-Anchor" href="#重绘交叉管道"></a> 重绘交叉管道</h2>
<p>在某米的触摸屏测试中，笔者发现有以下几个条件需要注意：</p>
<ol>
<li>如果滑动期间超出管道的范围认为无效。</li>
<li>只能从管道一端开始触摸，即从管道中间触摸视为无效。</li>
<li>如果从管道一端开始，不是通过管道到达另一端认为无效，即开始时是从管道一端开始，期间通过沿单元格滑动到达另一端。</li>
</ol>
<p>以上几个问题中，第一个问题上面绘制轨迹线时已经解决，下面我们解决其他几个问题。</p>
<p>解决思路：</p>
<ul>
<li>问题2：判断轨迹线的起点坐标是否在四个顶点单元格区域内。</li>
<li>问题3：判断轨迹线上所有点的坐标是否在管道区域内。</li>
</ul>
<p>首先定义 PathMeasure 变量，用于获取轨迹线 Path 上各点的坐标：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> linePathMeasure = PathMeasure()</span><br></pre></td></tr></table></figure>
<p>在 <code>onTouchEvent</code> 方法中的 <code>ACTION_MOVE</code> 分支中增加 <code>findReDrawableCross</code> 重绘管道逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (event.actionMasked) &#123;</span><br><span class="line">        <span class="comment">// 省略 ACTION_DOWN</span></span><br><span class="line">        MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断当前坐标是否在单元格和管道区域内</span></span><br><span class="line">            <span class="keyword">if</span> (isInTouchableRegion(x, y)) &#123;</span><br><span class="line">                <span class="comment">// 省略之前代码</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据当前坐标查找可重绘的单元格</span></span><br><span class="line">                findReDrawableBox(x, y)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 新增重绘管道逻辑</span></span><br><span class="line">                findReDrawableCross()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略 ACTION_UP、ACTION_CANCEL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findReDrawableCross</code> 方法代码较多且稍微复杂一些，下面我把代码拆开逐步分析。</p>
<h3 id="轨迹线路径测量及校验"><a class="markdownIt-Anchor" href="#轨迹线路径测量及校验"></a> 轨迹线路径测量及校验</h3>
<ol>
<li>首先校验轨迹线 Path 是否为空，为空则返回。</li>
<li>把轨迹线 Path 设置给路径测量器。</li>
<li>获取轨迹线 Path 的起点与终点的坐标并校验坐标合法性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findReDrawableCross</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 轨迹线 Path 为空返回</span></span><br><span class="line">    <span class="keyword">if</span> (linePath.isEmpty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把轨迹线 Path 设置给路径测量器</span></span><br><span class="line">    linePathMeasure.setPath(linePath, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义起点与终点坐标数组</span></span><br><span class="line">    <span class="keyword">val</span> startPoint = FloatArray(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> endPoint = FloatArray(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 Path 长度</span></span><br><span class="line">    <span class="keyword">val</span> linePathLength = linePathMeasure.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算起点与终点坐标</span></span><br><span class="line">    linePathMeasure.getPosTan(<span class="number">0F</span>, startPoint, <span class="literal">null</span>)</span><br><span class="line">    linePathMeasure.getPosTan(linePathLength, endPoint, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验起点坐标</span></span><br><span class="line">    <span class="keyword">val</span> startX = startPoint[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">val</span> startY = startPoint[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (startX == <span class="number">0F</span> || startY == <span class="number">0F</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验终点坐标</span></span><br><span class="line">    <span class="keyword">val</span> endX = endPoint[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">val</span> endY = endPoint[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (endX == <span class="number">0F</span> || endY == <span class="number">0F</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重绘正向管道"><a class="markdownIt-Anchor" href="#重绘正向管道"></a> 重绘正向管道</h3>
<ol>
<li>获取正向管道两端的单元格。</li>
<li>判断轨迹线的起点与终点坐标是否都在管道两端的单元格区域内。</li>
<li>遍历轨迹线，判断轨迹线上点的坐标是否在管道区域内。</li>
<li>标记正向管道可重绘。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findReDrawableCross</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略校验</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取正向管道两端的单元格</span></span><br><span class="line">    <span class="keyword">val</span> lbRectF = bottomRectFList.first().rectF</span><br><span class="line">    <span class="keyword">val</span> rtRectF = topRectFList.last().rectF</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断轨迹线的起点与终点坐标是否都在管道两端的单元格区域内</span></span><br><span class="line">    <span class="keyword">if</span> (((lbRectF.contains(startX, startY) &amp;&amp; rtRectF.contains(endX, endY)) ||</span><br><span class="line">         (lbRectF.contains(endX, endY) &amp;&amp; rtRectF.contains(startX, startY)))</span><br><span class="line">       ) &#123;</span><br><span class="line">        <span class="comment">// 定义 mark 变量为 true</span></span><br><span class="line">        <span class="keyword">var</span> mark = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历轨迹线</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until linePathLength.toInt()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取轨迹线上点的坐标</span></span><br><span class="line">            <span class="keyword">val</span> point = FloatArray(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">val</span> posTan = linePathMeasure.getPosTan(i.toFloat(), point, <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">if</span> (!posTan) &#123;</span><br><span class="line">                mark = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 坐标校验</span></span><br><span class="line">            <span class="keyword">val</span> x = point[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">val</span> y = point[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0F</span> || y == <span class="number">0F</span>) &#123;</span><br><span class="line">                mark = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断轨迹线上点的坐标是否在管道区域内</span></span><br><span class="line">            <span class="keyword">if</span> (!positiveCrossRegion.contains(x.toInt(), y.toInt())) &#123;</span><br><span class="line">                mark = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mark) &#123;</span><br><span class="line">            <span class="comment">// 标记正向管道可重绘</span></span><br><span class="line">            markPositiveCrossReDrawable()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记正向管道可重绘</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">markPositiveCrossReDrawable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!positiveCrossPath.isReDrawable) &#123;</span><br><span class="line">        positiveCrossPath.isReDrawable = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重绘反向管道"><a class="markdownIt-Anchor" href="#重绘反向管道"></a> 重绘反向管道</h3>
<p>反向管道的重绘逻辑与正向管道相同：</p>
<ol>
<li>获取反向管道两端的单元格。</li>
<li>判断轨迹线的起点与终点坐标是否都在管道两端的单元格区域内。</li>
<li>遍历轨迹线，判断轨迹线上点的坐标是否在管道区域内。</li>
<li>标记反向管道可重绘。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findReDrawableCross</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略校验</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取反向管道两端的单元格</span></span><br><span class="line">    <span class="keyword">val</span> ltRectF = topRectFList.first().rectF</span><br><span class="line">    <span class="keyword">val</span> rbRectF = bottomRectFList.last().rectF</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断轨迹线的起点与终点坐标是否都在管道两端的单元格区域内</span></span><br><span class="line">    <span class="keyword">if</span> (((ltRectF.contains(startX, startY) &amp;&amp; rbRectF.contains(endX, endY)) ||</span><br><span class="line">         (ltRectF.contains(endX, endY) &amp;&amp; rbRectF.contains(startX, startY)))</span><br><span class="line">       ) &#123;</span><br><span class="line">        <span class="comment">// 定义 mark 变量为 true</span></span><br><span class="line">        <span class="keyword">var</span> mark = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历轨迹线</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until linePathLength.toInt()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取轨迹线上点的坐标</span></span><br><span class="line">            <span class="keyword">val</span> point = FloatArray(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">val</span> posTan = linePathMeasure.getPosTan(i.toFloat(), point, <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">if</span> (!posTan) &#123;</span><br><span class="line">                mark = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 坐标校验</span></span><br><span class="line">            <span class="keyword">val</span> x = point[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">val</span> y = point[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0F</span> || y == <span class="number">0F</span>) &#123;</span><br><span class="line">                mark = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断轨迹线上点的坐标是否在管道区域内</span></span><br><span class="line">            <span class="keyword">if</span> (!reverseCrossRegion.contains(x.toInt(), y.toInt())) &#123;</span><br><span class="line">                mark = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mark) &#123;</span><br><span class="line">            <span class="comment">// 标记反向管道可重绘</span></span><br><span class="line">            markReverseCrossReDrawable()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记反向管道可重绘</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">markReverseCrossReDrawable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!reverseCrossPath.isReDrawable) &#123;</span><br><span class="line">        reverseCrossPath.isReDrawable = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重绘交叉管道的效果如下：</p>
<p><img data-src="/imgs/android/touch-view/touch-view-cross.png" alt="cross" /></p>
<h2 id="测试完成"><a class="markdownIt-Anchor" href="#测试完成"></a> 测试完成</h2>
<p>最后我们还剩下触摸屏测试完成的判断以及对外提供测试完成的回调，并且测试完成后不再绘制轨迹线。</p>
<p>定义测试完成的回调：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">TouchPassListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTouchPass</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义是否测试完成变量与测试完成回调变量：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> isPassed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> mTouchPassListener: TouchPassListener? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>新增 <code>isTouchPass</code> 方法，在此方法中判断所有单元格和管道是否都被标记为可重绘的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isTouchPass</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftRectFList.all &#123; it.isReDrawable &#125; &amp;&amp;</span><br><span class="line">    		topRectFList.all &#123; it.isReDrawable &#125; &amp;&amp;</span><br><span class="line">    		rightRectFList.all &#123; it.isReDrawable &#125; &amp;&amp;</span><br><span class="line">    		bottomRectFList.all &#123; it.isReDrawable &#125; &amp;&amp;</span><br><span class="line">    		centerHorizontalRectFList.all &#123; it.isReDrawable &#125; &amp;&amp;</span><br><span class="line">    		centerVerticalRectFList.all &#123; it.isReDrawable &#125; &amp;&amp;</span><br><span class="line">    		positiveCrossPath.isReDrawable &amp;&amp;</span><br><span class="line">    		reverseCrossPath.isReDrawable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在标记单元格和管道为可重绘的方法中调用 <code>isTouchPass</code> 方法即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">markBoxReDrawable</span><span class="params">(rectF: <span class="type">TouchRectF</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rectF.isReDrawable) &#123;</span><br><span class="line">        rectF.isReDrawable = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isTouchPass()) &#123;</span><br><span class="line">            touchPass()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">markPositiveCrossReDrawable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!positiveCrossPath.isReDrawable) &#123;</span><br><span class="line">        positiveCrossPath.isReDrawable = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isTouchPass()) &#123;</span><br><span class="line">            touchPass()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">markReverseCrossReDrawable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!reverseCrossPath.isReDrawable) &#123;</span><br><span class="line">        reverseCrossPath.isReDrawable = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isTouchPass()) &#123;</span><br><span class="line">            touchPass()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">touchPass</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isPassed = <span class="literal">true</span></span><br><span class="line">    mTouchPassListener?.onTouchPass()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后效果如下：</p>
<p><img data-src="/imgs/android/touch-view/touch-view-complete.png" alt="touch-view-complete" /></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title>Sword - 为 Kotlin 函数增加代理功能(一)</title>
    <url>/2022/09/20/gosp/sword/00-sword/</url>
    <content><![CDATA[<h1 id="sword-为-kotlin-函数增加代理功能一"><a class="markdownIt-Anchor" href="#sword-为-kotlin-函数增加代理功能一"></a> Sword - 为 Kotlin 函数增加代理功能(一)</h1>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>Sword：一个可以给 Kotlin 函数增加代理的第三方库，基于 KCP 实现。</p>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>为什么写这个库呢？笔者在学习 Retrofit 时，写过一篇文章 <a href="https://sunxiaodou.com/book/SourceCodeAnalysis/Retrofit/2.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html">Retrofit学习日记-动态代理</a>，在这时候笔者就萌生了为函数/方法也增加代理功能的想法。</p>
<p>正好笔者之前就有把某个函数/方法标记为开发调试方法的需求：在开发调试阶段可以执行，正式发布之后就不可执行。要实现这种需求，笔者可以列举下自己想到的方案：</p>
<ol>
<li>在函数/方法中通过 <code>BuildConfig#DEBUG</code> 判断是否可以执行：此方案最简单，在编码期依赖开发人员手动实现，但是编码过程比较繁琐且索然无味，</li>
<li>为函数/方法增加某个注解，通过修改函数/方法的字节码增加判断是否可以执行逻辑：此方案实现起来较为复杂，需要了解一些字节码信息，但是实现后使用起来比较方便且一劳永逸。</li>
</ol>
<p>仔细思考一下，其实可以发现：<strong>为函数/方法增加代理功能</strong> 可以实现 <strong>把某个函数/方法标记为开发调试方法的需求</strong>。</p>
<p>经过一番思想斗争，笔者选择了第二种方案，然后结合 <strong>为函数/方法也增加代理功能的想法</strong> ，所以最终选型为：注解 + KCP + ASM。</p>
<p>又正好笔者之前写过几篇关于 KCP 的文章：</p>
<ol>
<li><a href="https://sunxiaodou.com/2022/05/08/Kotlin/Kotlin-KCP%E7%9A%84%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%B8%80%E7%AF%87/">Kotlin-KCP的应用-第一篇</a></li>
<li><a href="https://sunxiaodou.com/2022/05/12/Kotlin/Kotlin-KCP%E7%9A%84%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AF%87/">Kotlin-KCP的应用-第二篇</a></li>
<li><a href="https://sunxiaodou.com/2022/05/23/Kotlin/Kotlin-KCP%E7%9A%84%E5%BA%94%E7%94%A8-%E4%BF%AE%E6%94%B9SDK%E7%89%88%E6%9C%AC%E5%8F%B7/">Kotlin-KCP的应用-修改SDK版本号</a></li>
</ol>
<p>在上面的 KCP 文章中，笔者记录了搭建 KCP 开发环境的过程，通过阅读上面的文章可以快速搭建一个 KCP 开发环境。</p>
<p>本文记录下 Sword 的项目结构及前期的开发环境搭建，后续文章再分析 Sword 的核心代码部分，下面让我们先看看项目结构吧。</p>
<h2 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h2>
<p><img data-src="/imgs/gosp/sword/00-00-project.png" alt="project" /></p>
<ul>
<li><strong>api-kotlin</strong>：API 模块，定义相关的注解 API 类，</li>
<li><strong>compiler</strong>：ksp 模块，辅助 Sword 生成常量类，后续文章再讲，</li>
<li><strong>kcp</strong>：kcp 模块，实现 Gradle Plugin 和 Kotlin Compiler Plugin。</li>
</ul>
<h2 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h2>
<h3 id="proxy"><a class="markdownIt-Anchor" href="#proxy"></a> Proxy</h3>
<p>首先创建 API 模块并定义 <code>Proxy</code> 注解：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.BINARY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启用, 默认True</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> enable: <span class="built_in">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [InvocationHandler]实现类的全限定名, 实现类必须有无参构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * e.g. com.example.ProxyTestInvocationHandler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> handler: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>Proxy</code> 注解中有两个参数：</p>
<ol>
<li><strong>enable</strong>：表示是否为函数启用代理，默认 <code>True</code>，</li>
<li><strong>handler</strong>：表示代理函数处理类的<strong>全限定名</strong>，<strong>此处理类必须实现 <code>InvocationHandler</code> 接口，且必须有无参构造方法</strong>。</li>
</ol>
<h3 id="invocationhandler"><a class="markdownIt-Anchor" href="#invocationhandler"></a> InvocationHandler</h3>
<p>先看下 Java 动态代理接口 <code>java.lang.reflect.InvocationHandler</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们仿照 Java 的动态代理接口定义我们的接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kt</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(className: <span class="type">String</span>, methodName: <span class="type">String</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者是不是比较相似呢？但是后者的接口方法参数有所不同：</p>
<ol>
<li><strong>className</strong>：表示当前代理方法所在的类名，</li>
<li><strong>methodName</strong>：表示当前代理方法的名称，</li>
<li><strong>args</strong>：表示当前代理方法的参数数组。</li>
</ol>
<p>在实现方式上也有所不同：</p>
<ol>
<li>Java 动态代理是在运行时动态创建并加载 Class，然后通过反射调用，有一定的性能开销，</li>
<li>Sword 勉强属于静态代理吧，在编译期修改字节码，没有经过反射调用，基本没有性能开销。</li>
</ol>
<p>API 相关定义完成，接下来开始编写 KCP 吧。</p>
<h2 id="kcp"><a class="markdownIt-Anchor" href="#kcp"></a> KCP</h2>
<p>对 KCP 不太了解的读者可以先看下上面列举的几篇文章。这里再贴下 KCP 的架构图吧：</p>
<p><img data-src="/imgs/gosp/sword/00-01-kcp-architecture.png" alt="kcp-architecture" /></p>
<h3 id="gradle-plugin"><a class="markdownIt-Anchor" href="#gradle-plugin"></a> Gradle Plugin</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SwordGradlePlugin</span> : <span class="type">KotlinCompilerPluginSupportPlugin</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(target: <span class="type">Project</span>)</span></span> = with(target) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Welcome to guodongAndroid sword kcp gradle plugin.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isApplicable</span><span class="params">(kotlinCompilation: <span class="type">KotlinCompilation</span>&lt;*&gt;)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCompilerPluginId</span><span class="params">()</span></span>: String = BuildConfig.KOTLIN_PLUGIN_ID</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPluginArtifact</span><span class="params">()</span></span>: SubpluginArtifact = SubpluginArtifact(</span><br><span class="line">        groupId = BuildConfig.KOTLIN_PLUGIN_GROUP,</span><br><span class="line">        artifactId = BuildConfig.KOTLIN_PLUGIN_NAME,</span><br><span class="line">        version = BuildConfig.KOTLIN_PLUGIN_VERSION,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyToCompilation</span><span class="params">(kotlinCompilation: <span class="type">KotlinCompilation</span>&lt;*&gt;)</span></span>: Provider&lt;List&lt;SubpluginOption&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> project = kotlinCompilation.target.project</span><br><span class="line">        <span class="keyword">return</span> project.provider &#123; emptyList() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对目前的 Sword 来说，它不需要任何参数和配置项。所以 <strong>Gradle Plugin</strong> 就一个 <code>SwordGradlePlugin</code> 类，比较简单，在其中配置下 <em>PluginId</em> 和 KCP 的 <em>SubpluginArtifact</em> 即可。</p>
<h3 id="kotlin-compiler-plugin"><a class="markdownIt-Anchor" href="#kotlin-compiler-plugin"></a> Kotlin Compiler Plugin</h3>
<h4 id="commandlineprocessor"><a class="markdownIt-Anchor" href="#commandlineprocessor"></a> CommandLineProcessor</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService(CommandLineProcessor::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwordCommandLineProcessor</span> : <span class="type">CommandLineProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> pluginId: String = BuildConfig.KOTLIN_PLUGIN_ID</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> pluginOptions: Collection&lt;AbstractCliOption&gt; = emptyList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CommandLineProcessor</code> 也非常简单，只需配置 <code>PluginId</code>，没有任何参数和配置项。</p>
<h4 id="componentregistrar"><a class="markdownIt-Anchor" href="#componentregistrar"></a> ComponentRegistrar</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService(ComponentRegistrar::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwordComponentRegistrar</span> : <span class="type">ComponentRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerProjectComponents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        project: <span class="type">MockProject</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        configuration: <span class="type">CompilerConfiguration</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> messageCollector =</span><br><span class="line">            configuration.<span class="keyword">get</span>(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY, MessageCollector.NONE)</span><br><span class="line"></span><br><span class="line">        messageCollector.report(</span><br><span class="line">            CompilerMessageSeverity.WARNING,</span><br><span class="line">            <span class="string">&quot;Welcome to guodongAndroid sword kcp kotlin plugin&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        ClassBuilderInterceptorExtension.registerExtension(</span><br><span class="line">            project,</span><br><span class="line">            SwordClassGenerationInterceptor(messageCollector)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ComponentRegistrar</code> 的逻辑也很简单：首先获取 <code>MessageCollector</code> 用于日志输出，然后注册一个 <code>ClassBuilder</code> 拦截器用于拦截类的生成。</p>
<h4 id="classbuilderinterceptorextension"><a class="markdownIt-Anchor" href="#classbuilderinterceptorextension"></a> ClassBuilderInterceptorExtension</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SwordClassGenerationInterceptor</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messageCollector: MessageCollector,</span><br><span class="line">) : ClassBuilderInterceptorExtension &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">interceptClassBuilderFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        interceptedFactory: <span class="type">ClassBuilderFactory</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        bindingContext: <span class="type">BindingContext</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        diagnostics: <span class="type">DiagnosticSink</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: ClassBuilderFactory = <span class="keyword">object</span> : ClassBuilderFactory <span class="keyword">by</span> interceptedFactory &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newClassBuilder</span><span class="params">(origin: <span class="type">JvmDeclarationOrigin</span>)</span></span>: ClassBuilder &#123;</span><br><span class="line">            <span class="keyword">return</span> SwordClassBuilder(messageCollector, interceptedFactory.newClassBuilder(origin))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 <code>ClassBuilderInterceptorExtension</code> 接口方法 <code>interceptClassBuilderFactory</code>，返回一个 <code>ClassBuilderFactory</code>，在 <code>newClassBuilder</code> 中做拦截，加入自己的处理逻辑，所以接下来的 <code>ClassBuilder</code> 算是 Sword 的核心代码了。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本文只是记录了 Sword 的项目结构及前期的开发环境搭建过程，可以看出 KCP 的开发环境搭建是有迹可循，有模板可依，此次的搭建过程与之前的 Mask 和 修改 SDK 版本号大同小异，笔者后续会提供一个 KCP 开发环境的模板工程供大家参考。</p>
<p>在学习或工作中有好的想法一定要及时记录下来，不要着急去实现你的想法，认真思考几种实现方案，仔细衡量方案中的利弊，选择一个你认为好的方案后再开始做实现。</p>
<p><strong>哦，对了，有想法一定要去实践，不要只是记录下来！</strong></p>
<p>下篇再见，happy~</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Sword - 为 Kotlin 函数增加代理功能(二)</title>
    <url>/2022/10/11/gosp/sword/01-sword/</url>
    <content><![CDATA[<h1 id="sword-为-kotlin-函数增加代理功能二"><a class="markdownIt-Anchor" href="#sword-为-kotlin-函数增加代理功能二"></a> Sword - 为 Kotlin 函数增加代理功能(二)</h1>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>Sword：一个可以给 Kotlin 函数增加代理的第三方库，基于 KCP 实现。</p>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>续接 <a href="https://sunxiaodou.com/2022/09/20/gosp/sword/00-sword/">上篇</a>，在上篇文章中笔者记录了搭建 Sword 的基础开发环境以及技术选型为：注解 + KCP + ASM。本文主要记录使用 ASM 的实现过程。</p>
<p>首先看下上篇文章最后没有记录的 <code>ClassBuilder</code>。</p>
<h2 id="classbuilder"><a class="markdownIt-Anchor" href="#classbuilder"></a> ClassBuilder</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> annotations: List&lt;FqName&gt; = listOf(</span><br><span class="line">    FqName(<span class="string">&quot;com.guodong.android.sword.api.kt.Proxy&quot;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    origin: <span class="type">JvmDeclarationOrigin</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    access: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    desc: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    signature: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    exceptions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: MethodVisitor &#123;</span><br><span class="line">    <span class="keyword">val</span> newMethod = <span class="keyword">super</span>.newMethod(origin, access, name, desc, signature, exceptions)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> function = origin.descriptor <span class="keyword">as</span>? FunctionDescriptor ?: <span class="keyword">return</span> newMethod</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (function.isOperator ||</span><br><span class="line">        function.isInfix ||</span><br><span class="line">        function.isInline ||</span><br><span class="line">        function.isSuspend ||</span><br><span class="line">        function.isTailrec</span><br><span class="line">       ) &#123;</span><br><span class="line">        <span class="keyword">return</span> newMethod</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (annotations.none &#123; function.annotations.hasAnnotation(it) &#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> newMethod</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> className = delegate.thisName</span><br><span class="line"></span><br><span class="line">    messageCollector.report(</span><br><span class="line">        CompilerMessageSeverity.WARNING,</span><br><span class="line">        <span class="string">&quot;Sword className = <span class="variable">$className</span>, methodName = <span class="variable">$name</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> realClassName = className.substring(className.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SwordAdapter(</span><br><span class="line">        Opcodes.ASM9,</span><br><span class="line">        newMethod,</span><br><span class="line">        realClassName,</span><br><span class="line">        access,</span><br><span class="line">        name,</span><br><span class="line">        desc</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>ClassBuilder</code> 中主要覆写 <code>newMethod</code> 函数拦截 Java 方法的生成：</p>
<ol>
<li>首先判断是否是函数描述符，否则直接返回，</li>
<li>若是操作符重载、中缀、内联、挂起以及尾递归函数，不予处理，直接返回，</li>
<li>函数若是不存在 <code>Proxy</code> 注解，不予处理，直接返回，</li>
<li>获取真实的类名，交予 <code>SwordAdapter</code> 处理。</li>
</ol>
<p>可以看出在 <code>ClassBuilder</code> 中主要是实现了一些校验逻辑，第 2 步中的过滤逻辑可增加配置参数提供给集成方在外部灵活配置。</p>
<p>接下来我们看下 <code>SwordAdapter</code> 是如何处理的吧。</p>
<h2 id="swordadapter"><a class="markdownIt-Anchor" href="#swordadapter"></a> SwordAdapter</h2>
<p><code>SwordAdapter</code> 的逻辑较为复杂，笔者先描述下自己的实现思路，然后再按照思路一点点分析。</p>
<ol>
<li>
<p>首先通过 ASM 判断当前函数是否存在 <code>Proxy</code> 注解，若存在则解析出注解中的数据暂存起来，否则不予转换，</p>
</li>
<li>
<p>若存在<code>Proxy</code> 注解并解析出注解中的数据，则根据注解中的 <code>enable</code> 字段判断是否启用代理，若启用则进行转换，否则不予转换，</p>
</li>
<li>
<p>若进行转换，再判断注解中的 <code>handler</code> 字段是否为空字符串，若是空字符串则进行简单的转换，否则进行代理转换，</p>
</li>
<li>
<p>简单转换：根据函数返回类型判断</p>
<ol>
<li>无返回值类型返回 <code>void</code>，</li>
<li>基本数据类型返回：<code>-1</code>，<code>char</code> 类型返回 <code>48</code>，</li>
<li>引用类型返回 <code>null</code>。</li>
</ol>
</li>
<li>
<p>代理转换：替换<code>handler</code>字段中的全限定名，调用<code>InvocationHandler#invoke</code>函数。</p>
</li>
</ol>
<p>下面的流程图看起来可能更清楚一些：</p>
<p><img data-src="/imgs/gosp/sword/01-00-codeflow.png" alt="code flow" /></p>
<h3 id="解析注解"><a class="markdownIt-Anchor" href="#解析注解"></a> 解析注解</h3>
<p>首先定义一个 <code>Proxy</code> 注解数据实体类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">SwordParam</span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有[Proxy]注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> hasProxyAnnotation: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启用, 默认True</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> enable: <span class="built_in">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [InvocationHandler]实现类的全限定名, 实现类必须有无参构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * e.g. com.example.ProxyTestInvocationHandler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> handler: String = <span class="string">&quot;&quot;</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">// 与[Proxy]注解的参数名一一对应</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">const</span> <span class="keyword">val</span> PARAM_ENABLE = <span class="string">&quot;enable&quot;</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">const</span> <span class="keyword">val</span> PARAM_HANDLER = <span class="string">&quot;handler&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此实体类存储 <code>Proxy</code> 注解中解析出来的数据，下面就是解析 <code>Proxy</code> 注解了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一些常量</span></span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> PROXY_KT_DESC = <span class="string">&quot;Lcom/guodong/android/sword/api/kt/Proxy;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> KT_INVOCATION_HANDLER_OWNER =</span><br><span class="line">    <span class="string">&quot;com/guodong/android/sword/api/kt/InvocationHandler&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> INVOKE_METHOD = <span class="string">&quot;invoke&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> INVOCATION_HANDLER_INVOKE_DESC =</span><br><span class="line">    <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> proxyDesc = listOf(PROXY_KT_DESC)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明注解数据实体变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> param = SwordParam()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写`visitAnnotation`</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitAnnotation</span><span class="params">(descriptor: <span class="type">String</span>, visible: <span class="type">Boolean</span>)</span></span>: AnnotationVisitor &#123;</span><br><span class="line">    <span class="keyword">var</span> av = <span class="keyword">super</span>.visitAnnotation(descriptor, visible)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在`Proxy`注解</span></span><br><span class="line">    <span class="keyword">if</span> (proxyDesc.contains(descriptor)) &#123;</span><br><span class="line">        param.hasProxyAnnotation = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (av != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析`Proxy`注解</span></span><br><span class="line">            av = AnnotationAdapter(api, av, param)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> av</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析注解数据主要覆写 <code>visitAnnotation</code> 函数，在此函数中首先判断是否存在 <code>Proxy</code> 注解，若存在则进行解析，否则不予处理。</p>
<p>解析逻辑就在下面代码的 <code>AnnotationAdapter</code> 中了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">AnnotationAdapter</span>(</span><br><span class="line">    api: <span class="built_in">Int</span>,</span><br><span class="line">    annotationVisitor: AnnotationVisitor?,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> param: SwordParam</span><br><span class="line">) : AnnotationVisitor(api, annotationVisitor) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visit</span><span class="params">(name: <span class="type">String</span>, value: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (name) &#123;</span><br><span class="line">            SwordParam.PARAM_ENABLE -&gt; param.enable = (value <span class="keyword">as</span> <span class="built_in">Boolean</span>)</span><br><span class="line">            SwordParam.PARAM_HANDLER -&gt; param.handler = (value <span class="keyword">as</span> String)</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，解析逻辑也比较简单，在 <code>visit</code> 函数中：</p>
<ol>
<li>第一个参数 <code>name</code> 表示注解中参数的名称，第二参数 <code>value</code>表示注解中参数的值，</li>
<li>通过比对 <code>name</code> 参数的名称来解析注解中的数据并存储在实体中。</li>
</ol>
<p>至此解析 <code>Proxy</code> 注解完成，我们已经拿到注解中的数据，下面我们就可以开始转换了。</p>
<h3 id="转换分支"><a class="markdownIt-Anchor" href="#转换分支"></a> 转换分支</h3>
<p>对函数代理功能的转换，笔者实现了两种转换分支：</p>
<ol>
<li><strong>简单转换</strong>：或者称为默认转换，就像 <code>switch</code> 有 <code>default</code> 分支一样，</li>
<li><strong>代理转换</strong>：真正的代理功能实现。</li>
</ol>
<p>转换逻辑在 <code>visitCode</code> 函数中处理，我们先看看转换分支的选择：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitCode</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否有`Proxy`注解且是否启用代理</span></span><br><span class="line">    <span class="keyword">if</span> (param.hasProxyAnnotation &amp;&amp; param.enable) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 织入一个`booelan`值：True</span></span><br><span class="line">        <span class="keyword">super</span>.visitInsn(Opcodes.ICONST_1)</span><br><span class="line">        <span class="keyword">val</span> label = Label()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 织入`if`判断语句</span></span><br><span class="line">        <span class="keyword">super</span>.visitJumpInsn(Opcodes.IFEQ, label)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取`methodType`</span></span><br><span class="line">        <span class="keyword">val</span> methodType = Type.getMethodType(</span><br><span class="line">            methodDescriptor</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取`returnType`，函数的返回值类型</span></span><br><span class="line">        <span class="keyword">val</span> returnType = methodType.returnType</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> handler = param.handler</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断`handler`是否是空字符串</span></span><br><span class="line">        <span class="keyword">if</span> (handler.isNotEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 代理转换</span></span><br><span class="line">            weaveHandler(methodType, returnType, handler)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 简单转换</span></span><br><span class="line">            weaveDefaultValue(returnType)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.visitLabel(label)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.visitCode()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>visitCode</code> 函数的前部分是一些判断处理：</p>
<ol>
<li>如果有<code>Proxy</code>注解且启用了代理，则通过 <code>ASM</code> 先织入 <code>if (true)</code> 条件判断语句，</li>
<li>接下来获取函数的 <code>methodType</code> 和 <code>returnType</code>，分别表示在 <code>ASM</code> 眼中的函数类型和返回值类型，</li>
<li>最后判断 <code>handler</code> 是否是空字符串来决定执行哪种转换分支。</li>
</ol>
<h3 id="简单转换"><a class="markdownIt-Anchor" href="#简单转换"></a> 简单转换</h3>
<p>简单转换的实现是根据函数返回类型判断：</p>
<ol>
<li>无返回值类型返回 <code>void</code>，</li>
<li>基本数据类型返回：<code>-1</code>，<code>char</code> 类型返回 <code>48</code>，</li>
<li>引用类型返回 <code>null</code>。</li>
</ol>
<p>下面是简单转换的实现代码片段：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">weaveDefaultValue</span><span class="params">(returnType: <span class="type">Type</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sort = returnType.sort</span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">        sort == Type.VOID -&gt; &#123;</span><br><span class="line">            <span class="keyword">super</span>.visitInsn(Opcodes.RETURN)</span><br><span class="line">        &#125;</span><br><span class="line">        sort == Type.CHAR -&gt; &#123;</span><br><span class="line">            <span class="keyword">super</span>.visitIntInsn(Opcodes.BIPUSH, <span class="number">48</span>)</span><br><span class="line">            <span class="keyword">super</span>.visitInsn(returnType.getOpcode(Opcodes.IRETURN))</span><br><span class="line">        &#125;</span><br><span class="line">        sort &gt;= Type.BOOLEAN &amp;&amp; sort &lt;= Type.INT -&gt; &#123;</span><br><span class="line">            <span class="keyword">super</span>.visitInsn(Opcodes.ICONST_M1)</span><br><span class="line">            <span class="keyword">super</span>.visitInsn(returnType.getOpcode(Opcodes.IRETURN))</span><br><span class="line">        &#125;</span><br><span class="line">        sort == Type.LONG -&gt; &#123;</span><br><span class="line">            <span class="keyword">super</span>.visitLdcInsn(-<span class="number">1L</span>)</span><br><span class="line">            <span class="keyword">super</span>.visitInsn(Opcodes.LRETURN)</span><br><span class="line">        &#125;</span><br><span class="line">        sort == Type.FLOAT -&gt; &#123;</span><br><span class="line">            <span class="keyword">super</span>.visitLdcInsn(-<span class="number">1f</span>)</span><br><span class="line">            <span class="keyword">super</span>.visitInsn(Opcodes.FRETURN)</span><br><span class="line">        &#125;</span><br><span class="line">        sort == Type.DOUBLE -&gt; &#123;</span><br><span class="line">            <span class="keyword">super</span>.visitLdcInsn(-<span class="number">1.0</span>)</span><br><span class="line">            <span class="keyword">super</span>.visitInsn(Opcodes.DRETURN)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">super</span>.visitInsn(Opcodes.ACONST_NULL)</span><br><span class="line">            <span class="keyword">super</span>.visitInsn(Opcodes.ARETURN)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单转换的实现逻辑比较简单，笔者就不再分析了，接下来我们看看今天的主角：代理转换。</p>
<h3 id="代理转换"><a class="markdownIt-Anchor" href="#代理转换"></a> 代理转换</h3>
<p>代理转换的实现逻辑较为复杂，以下几点是我们需要考虑的：</p>
<ol>
<li>原始函数是否是静态函数：非静态函数(不包括构造函数)的第零位参数始终是 <code>this</code>，</li>
<li>如何构建 <code>InvocationHandler</code> 实现类的实例，</li>
<li>如何获取 <code>InvocationHandler#invoke</code> 函数所需的参数，</li>
<li>如何调用 <code>InvocationHandler#invoke</code> 函数，</li>
<li>调用 <code>InvocationHandler#invoke</code> 函数后的结果如何返回给原始函数。</li>
</ol>
<p>脑图如下：</p>
<p><img data-src="/imgs/gosp/sword/01-01-proxy-mind.png" alt="proxy mind" /></p>
<p>下面我们就根据上述几点依次分析下：</p>
<h4 id="1是否是静态函数"><a class="markdownIt-Anchor" href="#1是否是静态函数"></a> 1.是否是静态函数</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> argumentTypes = t.argumentTypes</span><br><span class="line"><span class="keyword">val</span> argumentSize = argumentTypes.size</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> isStaticMethod = methodAccess and Opcodes.ACC_STATIC != <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> localSize = <span class="keyword">if</span> (isStaticMethod) <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> firstSlot = localSize</span><br><span class="line"><span class="keyword">for</span> (argType <span class="keyword">in</span> argumentTypes) &#123;</span><br><span class="line">    localSize += argType.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断是否是静态函数，其中一个目的是为了找到函数第一个参数的起始位置，以及计算整个方法的 <code>locals</code> 大小，为后续存储 <code>InvocationHandler</code> 实现类实例做准备：</p>
<ul>
<li><code>firstSlot</code> 即为第一个参数的起始位置，后面会使用到，</li>
<li><code>localSize</code> 即为整个方法的 <code>lcoals</code> 大小，通过遍历函数参数得到。</li>
</ul>
<h4 id="2构建实现类实例"><a class="markdownIt-Anchor" href="#2构建实现类实例"></a> 2.构建实现类实例</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> realHandler = covertToClassDescriptor(handler)</span><br><span class="line"><span class="keyword">super</span>.visitTypeInsn(Opcodes.NEW, realHandler)</span><br><span class="line"><span class="keyword">super</span>.visitInsn(Opcodes.DUP)</span><br><span class="line"><span class="keyword">super</span>.visitMethodInsn(Opcodes.INVOKESPECIAL, realHandler, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">super</span>.visitVarInsn(Opcodes.ASTORE, localSize)</span><br><span class="line"><span class="keyword">super</span>.visitVarInsn(Opcodes.ALOAD, localSize)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">covertToClassDescriptor</span><span class="params">(className: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> className.replace(<span class="string">&quot;\\.&quot;</span>.toRegex(), <span class="string">&quot;/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先需要把 <code>handler</code> 字段中的实现类全限定名（<code>Full-Qualified Name</code>）转换成 <code>ASM</code> 里的 <code>InternalName</code>，比如：<code>com.guodong.android.TestInvocationHandler</code> 转换为 <code>com/guodong/android/TestInvocationHandler</code>，即把 <code>.</code> 替换成 <code>/</code>。</li>
<li>上述片段中的第 4 行代码通过调用实现类的无参构造方法来构建实例，这就是为什么实现类必须有无参构造方法的原因，</li>
<li>后面两行代码是把创建出来的实例存储在方法的 <code>locals</code> 上并再次加载出来以备后用。</li>
</ol>
<h4 id="3获取所需参数"><a class="markdownIt-Anchor" href="#3获取所需参数"></a> 3.获取所需参数</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>.visitLdcInsn(className)</span><br><span class="line"><span class="keyword">super</span>.visitLdcInsn(methodName)</span><br><span class="line">weaveInt(argumentSize)</span><br><span class="line"><span class="keyword">super</span>.visitTypeInsn(Opcodes.ANEWARRAY, <span class="string">&quot;java/lang/Object&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (argumentTypes.isNotEmpty()) &#123;</span><br><span class="line">    weaveArgs(argumentTypes, argumentSize, firstSlot)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// InvocationHandler</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(className: <span class="type">String</span>, methodName: <span class="type">String</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码片段的最后是 <code>InvocationHandler</code> 接口的声明，如上所示，<code>invoke</code> 函数需要 3 个参数，分别为：</p>
<ol>
<li>当前的类名，</li>
<li>当前的函数名，</li>
<li>当前函数声明参数的数组。</li>
</ol>
<p>下面分析下获取参数的逻辑：</p>
<ol>
<li>代码片段的前两行代码我们织入了前两个参数，</li>
<li>第 3 行代码我们织入参数数组的大小，</li>
<li>第 4 行代码构建参数数组实例，</li>
<li>最后面的 <code>if</code> 条件判断逻辑是把原始函数的参数放进数组内。</li>
</ol>
<h4 id="4调用-invoke-函数"><a class="markdownIt-Anchor" href="#4调用-invoke-函数"></a> 4.调用 <code>invoke</code> 函数</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>.visitMethodInsn(</span><br><span class="line">    Opcodes.INVOKEINTERFACE,</span><br><span class="line">    KT_INVOCATION_HANDLER_OWNER,</span><br><span class="line">    INVOKE_METHOD,</span><br><span class="line">    INVOCATION_HANDLER_INVOKE_DESC,</span><br><span class="line">    <span class="literal">true</span> <span class="comment">/* isInterface */</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>调用 <code>invoke</code> 函数比较简单，通过调用 <code>ASM</code> 的 <code>visitMethodInsn</code> 方法传入正确的参数即可。注意最后一个参数要为 <code>true</code>，因为我们调用的是一个接口方法。</p>
<h4 id="5invoke函数的结果返回给原始函数"><a class="markdownIt-Anchor" href="#5invoke函数的结果返回给原始函数"></a> 5.<code>invoke</code>函数的结果返回给原始函数</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> returnTypeSort = returnType.sort</span><br><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    returnTypeSort == Type.VOID -&gt; &#123;</span><br><span class="line">        <span class="keyword">super</span>.visitInsn(Opcodes.RETURN)</span><br><span class="line">    &#125;</span><br><span class="line">    isPrimitiveType(returnTypeSort) -&gt; &#123;</span><br><span class="line">        weavePrimitiveReturn(returnTypeSort)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> internalName = returnType.internalName</span><br><span class="line">        <span class="keyword">super</span>.visitTypeInsn(Opcodes.CHECKCAST, internalName)</span><br><span class="line">        <span class="keyword">super</span>.visitInsn(Opcodes.ARETURN)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如前所示，<code>invoke</code> 函数的返回值是 <code>Any?</code> ，那么如何返回给原始函数呢？我们还是需要根据原始函数的返回值类型做判断：</p>
<ol>
<li>如果是 <code>voidd</code> 类型，则直接 <code>return</code>，</li>
<li>如果是基本数据类型，需要先强制类型转换为包装类型，再调用包装类型对应的 <code>xxxValue</code> 方法获取基本数据类型，最后再返回，</li>
<li>如果是引用类型，通过 <code>returnType</code> 获取返回值的 <code>InternalName</code>，然后进行强制类型转换，最后返回。</li>
</ol>
<p>至此，代理转换分析完毕，happy~</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>在想实现某个功能的时候，我们可能会有好几种思路，如何在这好几种思路中选择一个进行实现，这其中考量与取舍的过程笔者觉得比较有趣。</p>
<p>本文记录了 <code>Sword</code> 的实现原理与源码分析，同时记录了笔者实现代码时的一些思路与思考，笔者个人认为这些思路与思考远比实现这个功能更有意义。</p>
<p>下篇再见，happy~</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Sword - 为 Kotlin 函数增加代理功能(三)</title>
    <url>/2022/10/13/gosp/sword/02-sword/</url>
    <content><![CDATA[<h1 id="sword-为-kotlin-函数增加代理功能三"><a class="markdownIt-Anchor" href="#sword-为-kotlin-函数增加代理功能三"></a> Sword - 为 Kotlin 函数增加代理功能(三)</h1>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>Sword：一个可以给 Kotlin 函数增加代理的第三方库，基于 KCP 实现。</p>
<ol>
<li><a href="https://sunxiaodou.com/2022/09/20/gosp/sword/00-sword/">Sword - 为 Kotlin 函数增加代理功能(一)</a></li>
<li><a href="https://sunxiaodou.com/2022/10/11/gosp/sword/01-sword/">Sword - 为 Kotlin 函数增加代理功能(二)</a></li>
</ol>
<p>前面两篇文章笔者记录了 <code>Sword</code> 的实现过程，本篇文章简单记录下如何使用 <code>Sword</code> 以及如何通过 <code>KSP</code> 为 <code>InvocationHandler</code> 生成 <code>FqName</code> 索引类 <code>HandlerFqName</code>。</p>
<p>下面我们先看下如何使用 <code>Sword</code> 吧。</p>
<h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `InvocationHandler` 实现类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetTextNoArgInvocationHandler</span> : <span class="type">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = GetTextNoArgInvocationHandler::<span class="keyword">class</span>.java.simpleName</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(className: <span class="type">String</span>, methodName: <span class="type">String</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;invoke: className = <span class="variable">$className</span>, methodName = <span class="variable">$methodName</span>, args(<span class="subst">$&#123;args.size&#125;</span>) = <span class="subst">$&#123;args.joinToString()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;guodongAndroid-Debug&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `InvocationHandler` 实现类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetTextArgInvocationHandler</span> : <span class="type">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = GetTextArgInvocationHandler::<span class="keyword">class</span>.java.simpleName</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(className: <span class="type">String</span>, methodName: <span class="type">String</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;invoke: className = <span class="variable">$className</span>, methodName = <span class="variable">$methodName</span>, args(<span class="subst">$&#123;args.size&#125;</span>) = <span class="subst">$&#123;args.joinToString()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> User(<span class="string">&quot;guodongAndroid-Debug&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码片段中，笔者创建了两个 <code>InvocationHandler</code> 实现类，对原始函数的返回值进行了替换，接下来创建测试类：</p>
<p><strong>向 <code>Proxy</code> 注解中的 <code>handler</code> 参数注入 <code>InvocationHandler</code> 实现类的全限定名(Fully Qualified Name)，其实现类必须有无参构造方法</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Proxy(</span></span><br><span class="line"><span class="meta">        enable = BuildConfig.isDebug,</span></span><br><span class="line"><span class="meta">        // 注入 `InvocationHandler` 实现类的全限定名</span></span><br><span class="line"><span class="meta">        handler = <span class="string">&quot;com.guodong.android.sword.app.GetTextNoArgInvocationHandler&quot;</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getTextNoArg</span><span class="params">()</span></span> = <span class="string">&quot;guodongAndroid&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Proxy(</span></span><br><span class="line"><span class="meta">        enable = BuildConfig.isDebug,</span></span><br><span class="line"><span class="meta">        // 注入 `InvocationHandler` 实现类的全限定名</span></span><br><span class="line"><span class="meta">        handler = <span class="string">&quot;com.guodong.android.sword.app.GetTextArgInvocationHandler&quot;</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getTextArg</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        b: <span class="type">Byte</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        z: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        c: <span class="type">Char</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        s: <span class="type">Short</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        i: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        l: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        f: <span class="type">Float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        d: <span class="type">Double</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        str: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        ia: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        sa: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        ls: <span class="type">List</span>&lt;<span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        lls: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        map: <span class="type">Map</span>&lt;<span class="type">String</span>, String&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        user: <span class="type">User</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        callback: <span class="type">Callback</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: User &#123;</span><br><span class="line">        <span class="keyword">return</span> User(<span class="string">&quot;guodongAndroid-Release&quot;</span>, <span class="number">28</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>笔者创建了两个测试函数：<code>getTextNoArg</code> 和 <code>getTextArg</code>，一个函数没有参数，另一个函数有多个不同类型的参数。这两个函数上都有 <code>Proxy</code> 注解，并且注解的参数 <code>enable</code> 都处于开启状态，<code>handler</code> 参数都注入了对应 <code>InvocationHandler</code> 实现类的全限定名。</p>
<p>下面执行测试逻辑，分别调用上述两个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> test = Test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textNoArg = test.getTextNoArg()</span><br><span class="line">Log.e(TAG, <span class="string">&quot;onCreate: textNoArg = <span class="subst">$&#123;textNoArg.length&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textArg = test.getTextArg(</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">1F</span>,</span><br><span class="line">    <span class="number">1.0</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    intArrayOf(),</span><br><span class="line">    Array(<span class="number">0</span>) &#123; <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">    listOf(),</span><br><span class="line">    listOf(),</span><br><span class="line">    mapOf(),</span><br><span class="line">    User(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(cause: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">Log.e(TAG, <span class="string">&quot;onCreate: textArg = <span class="variable">$textArg</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>原始输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.MainActivity: onCreate: textNoArg = 14</span><br><span class="line">2.MainActivity: onCreate: textArg = User(name=guodongAndroid-Release, age=28)</span><br></pre></td></tr></table></figure>
<p>代理输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.GetTextNoArgInvocationHandler: invoke: className = Test, methodName = getTextNoArg, args(0) = </span><br><span class="line">2.MainActivity: onCreate: textNoArg = 20</span><br><span class="line">3.GetTextArgInvocationHandler: invoke: className = Test, methodName = getTextArg, args(16) = 1, false, A, 1, 1, 1, 1.0, 1.0, test, [I@156552e7, [Ljava.lang.String;@110de94, [], [], &#123;&#125;, User(name=1, age=1), com.guodong.android.sword.app.MainActivity$onCreate$textArg$2@12780d3d</span><br><span class="line">4.onCreate: textArg = User(name=guodongAndroid-Debug, age=18)</span><br></pre></td></tr></table></figure>
<p>从上面的输出结果可以看出，<code>Proxy</code> 注解生效了：调用上述两个函数后成功执行了代理类的 <code>invoke</code> 函数。</p>
<p>至此，<code>Sword</code> 的使用就结束了，是不是比较简单呢？</p>
<p>但是这里有个问题：我们在给 <code>Proxy</code> 注解的 <code>handler</code> 参数注入 <code>InvocationHandler</code> 实现类的全限定名时使用的是硬编码，如果我们修改了实现类的类名，而忘记修改此处的全限定名，代码在运行时就会发生错误了。</p>
<p>针对这个问题，笔者的第一想法是使用  <code>handler = GetTextNoArgInvocationHandler::class.java.name</code>，但是不行，<strong>注解参数必须是编译期常量</strong>，此路不通了。</p>
<p>后面笔者想到一种方案：为 <code>InvocationHandler</code> 的实现类生成全限定名索引。</p>
<p>此方案参考自 <code>EventBus</code> 为 <code>Event</code> 事件生成 <code>EventIndex</code> ，不过 <code>EventBus</code> 使用 <code>APT</code> 技术进行实现，而 <code>Sword</code> 选择使用 <code>KSP</code> 实现。</p>
<p>接下来我们就看看如何为 <code>InvocationHandler</code> 的实现类生成全限定名索引吧。</p>
<p>首先看下最后的索引类 <code>HandlerFqName</code> 效果：</p>
<h2 id="handlerfqname"><a class="markdownIt-Anchor" href="#handlerfqname"></a> HandlerFqName</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The file is automatic generated by Sword, don&#x27;t modify it.</span></span><br><span class="line"><span class="keyword">package</span> com.guodong.android.sword.app</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.String</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class is automatic generated by Sword, don&#x27;t modify it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [com.guodong.android.sword.api.kt.InvocationHandler]实现类的全限定名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> HandlerFqName &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [com.guodong.android.sword.app.GetTextArgInvocationHandler]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">val</span> GetTextArgInvocationHandler: String =</span><br><span class="line">      <span class="string">&quot;com.guodong.android.sword.app.GetTextArgInvocationHandler&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [com.guodong.android.sword.app.GetTextNoArgInvocationHandler]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">val</span> GET_TEXT_NO_ARG: String =</span><br><span class="line">      <span class="string">&quot;com.guodong.android.sword.app.GetTextNoArgInvocationHandler&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="proxyhandler"><a class="markdownIt-Anchor" href="#proxyhandler"></a> ProxyHandler</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记[InvocationHandler]的实现类, 为其生成`FqName`索引类`HandlerFqName`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用 ksp 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.CLASS)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.BINARY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">ProxyHandler</span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字段的名称, 默认为类名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * `paramName`参数名称不要随意变动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> paramName: String = <span class="string">&quot;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在 <code>api-kotlin</code> 模块中新增 <code>ProxyHandler</code> 注解，此注解用于标记 <code>InvocationHandler</code> 的实现类，为其生成<code>FqName</code>索引，比如我们标记在 <code>GetTextNoArgInvocationHandler</code> 类上：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ProxyHandler(<span class="string">&quot;GET_TEXT_NO_ARG&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetTextNoArgInvocationHandler</span> : <span class="type">InvocationHandler</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>paramName</code> 参数可以指定生成字段的名称，如果没有设置，默认生成的字段名称为实现类的类名：<code>HandlerFqName.GetTextArgInvocationHandler</code>。</p>
<h2 id="ksp"><a class="markdownIt-Anchor" href="#ksp"></a> KSP</h2>
<p><a href="https://github.com/google/ksp">KSP</a> 基于 <code>KCP</code> 实现，提供了一个简化的编译器插件 API，与 <code>KCP</code> 陡峭的学习曲线相比，<code>KSP</code> 的学习曲线要平滑一些。、</p>
<p>如何使用 <code>KSP</code> 读者可以参考<a href="https://github.com/google/ksp">官网</a>，本文就不记录搭建 <code>KSP</code> 开发环境了，直接进入正题。</p>
<p>笔者先描述下自己的实现思路：</p>
<ol>
<li>首先判断当前模块是否有 <code>InvocationHandler</code> 接口，如若没有，则不处理，</li>
<li>其次判断当前模块是否有 <code>ProxyHandler</code> 注解，如若没有，则不处理，</li>
<li>以上两个条件都满足的，再获取包含 <code>ProxyHandler</code> 注解的所有 <code>Kotlin</code> 符号，</li>
<li>对获取的 <code>Kotlin</code> 符号进行几种条件过滤，目的是确保此符号是 <code>InvocationHandler</code> 接口的实现类，过滤条件：
<ol>
<li>判断是否是类，而不是接口、枚举类等，</li>
<li>判断类是否是公开且不是抽象类，确保当前类可以访问并直接实例化，</li>
<li>判断是否有主构造方法或主构造方法没有参数，确保有无参构造方法，</li>
<li>最后判断当前类是否实现了 <code>InvocationHandler</code> 接口。</li>
</ol>
</li>
<li>通过过滤后的符号，收集并存储要生成的字段名和全限定名，</li>
<li>最后通过 <code>KotlinPoet</code> 生成索引类。</li>
</ol>
<p><img data-src="/imgs/gosp/sword/02-00-idea.png" alt="idea" /></p>
<p>下面根据实现思路依次实现。<br />
首先定义一些常量，用于后面代码的编写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="comment">// 对应`ProxyHandler`注解里的`paramName`参数名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> PARAM_NAME = <span class="string">&quot;paramName&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成索引类的包名，提供给外部配置，默认`com.guodong.android.sword`</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> PACKAGE_NAME_PARAM_NAME = <span class="string">&quot;sword.pkg&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认索引类的包名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DEFAULT_PACKAGE_NAME = <span class="string">&quot;com.guodong.android.sword&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引类所在文件名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> FILE_NAME = <span class="string">&quot;HandlerFqName&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引类的类名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> CLASS_NAME = <span class="string">&quot;HandlerFqName&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个实体，用于存储生成的字段名和全限定名：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">ProxyHandlerParam</span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数名称, 默认为类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> paramName: String,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [InvocationHandler]实现类的全限定名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * e.g. com.example.ProxyTestInvocationHandler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> fqName: String,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>接下来主要分析 <code>SymbolProcessor</code> 的 <code>process(resolver: Resolver)</code> 函数，下面代码是思路中前两步的具体实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mInvocationHandlerName = requireNotNull(InvocationHandler::<span class="keyword">class</span>.qualifiedName)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mProxyHandlerName = requireNotNull(ProxyHandler::<span class="keyword">class</span>.qualifiedName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(resolver: <span class="type">Resolver</span>)</span></span>: List&lt;KSAnnotated&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断当前模块是否有 `InvocationHandler` 接口，如若没有，则不处理</span></span><br><span class="line">    <span class="keyword">val</span> mProxyHandlerType =</span><br><span class="line">    	resolver.getClassDeclarationByName(mProxyHandlerName)?.asType(emptyList())</span><br><span class="line">    <span class="keyword">if</span> (mProxyHandlerType == <span class="literal">null</span>) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;<span class="variable">$TAG</span>: Not found `ProxyHandler`&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前模块是否有 `ProxyHandler` 注解，如若没有，则不处理</span></span><br><span class="line">    <span class="keyword">val</span> mInvocationHandlerType =</span><br><span class="line">    	resolver.getClassDeclarationByName(mInvocationHandlerName)?.asType(emptyList())</span><br><span class="line">    <span class="keyword">if</span> (mInvocationHandlerType == <span class="literal">null</span>) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;<span class="variable">$TAG</span>: Not found `InvocationHandler`&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取包含 <code>ProxyHandler</code> 注解的所有 <code>Kotlin</code> 符号比较简单，通过 <code>KSP</code> 提供的 API，我们可以很方便的获取到：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> symbols = resolver.getSymbolsWithAnnotation(mProxyHandlerName)</span><br></pre></td></tr></table></figure>
<p>下面根据实现思路的第四步过滤我们获取到的符号：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> classDeclaration = symbols</span><br><span class="line">	.filter &#123; it.validate() &#125;</span><br><span class="line">	.filterIsInstance&lt;KSClassDeclaration&gt;()</span><br><span class="line">	.filter &#123; declaration -&gt;</span><br><span class="line">         <span class="comment">// Class</span></span><br><span class="line">         <span class="keyword">val</span> isClass = declaration.classKind == ClassKind.CLASS</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Public &amp;&amp; !Abstract</span></span><br><span class="line">         <span class="keyword">val</span> isPublic =</span><br><span class="line">         Modifier.PUBLIC <span class="keyword">in</span> declaration.modifiers || declaration.modifiers.isEmpty()</span><br><span class="line">         <span class="keyword">val</span> isNotAbstract = Modifier.ABSTRACT !<span class="keyword">in</span> declaration.modifiers</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 无参构造方法</span></span><br><span class="line">         <span class="keyword">val</span> primaryConstructor = declaration.primaryConstructor</span><br><span class="line">         <span class="keyword">val</span> hasNoArgumentConstructor =</span><br><span class="line">         primaryConstructor == <span class="literal">null</span> || primaryConstructor.parameters.isEmpty()</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 实现`InvocationHandler`接口</span></span><br><span class="line">         <span class="keyword">val</span> isImplInvocationHandler =</span><br><span class="line">         declaration.superTypes.any &#123; ref -&gt; ref.resolve() == mInvocationHandlerType &#125;</span><br><span class="line"></span><br><span class="line">         isClass &amp;&amp; isPublic &amp;&amp; isNotAbstract &amp;&amp; hasNoArgumentConstructor &amp;&amp; isImplInvocationHandler</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>过滤符号后，就可以收集并存储要生成的字段名和全限定名了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> params = mutableListOf&lt;ProxyHandlerParam&gt;()</span><br><span class="line"><span class="keyword">for</span> (declaration <span class="keyword">in</span> classDeclaration) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">annotation</span> <span class="keyword">in</span> declaration.annotations) &#123;</span><br><span class="line">        <span class="comment">// 这里笔者没有判断当前`annotation`是否是`ProxyHandler`可能会存在问题</span></span><br><span class="line">        <span class="comment">// 因为`resolve()`函数的注释中描述调用此函数的代价比较昂贵, 应尽可能避免调用，这里又是在遍历中调用，所以笔者就没有判断</span></span><br><span class="line">        <span class="comment">// 如果存在问题，我们可以给`ProxyHandler`注解的`paramName`参数换个唯一不会重复的名称</span></span><br><span class="line">        <span class="comment">/*if (annotation.annotationType.resolve() != mProxyHandlerType) &#123;</span></span><br><span class="line"><span class="comment">            continue</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (argument <span class="keyword">in</span> <span class="keyword">annotation</span>.arguments) &#123;</span><br><span class="line">            <span class="keyword">val</span> name = argument.name?.asString() ?: <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">// 判断是否是`ProxyHandler`注解中的参数名称</span></span><br><span class="line">            <span class="keyword">if</span> (name == PARAM_NAME) &#123;</span><br><span class="line">                <span class="comment">// 获取注解中的参数值</span></span><br><span class="line">                <span class="keyword">val</span> value: String = argument.value <span class="keyword">as</span>? String ?: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">// 获取当前实现类的全限定名</span></span><br><span class="line">                <span class="keyword">val</span> fqName: String = declaration.qualifiedName?.asString() ?: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果注解没有注入参数名则使用类名</span></span><br><span class="line">                <span class="keyword">val</span> paramName = value.ifEmpty &#123; declaration.simpleName.asString() &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 收集存储</span></span><br><span class="line">                <span class="keyword">val</span> param = ProxyHandlerParam(paramName, fqName)</span><br><span class="line">                params.add(param)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收集我们所需的数据后，最后就可以生成索引类了，笔者使用 <code>KotlinPoet</code> 来生成索引类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建类中的全限定名属性</span></span><br><span class="line"><span class="keyword">val</span> propertySpecs = params.map &#123; param -&gt;</span><br><span class="line">    PropertySpec.builder(param.paramName, String::<span class="keyword">class</span>)</span><br><span class="line">        .addModifiers(KModifier.CONST)</span><br><span class="line">        .initializer(<span class="string">&quot;%S&quot;</span>, param.fqName)</span><br><span class="line">        .addKdoc(<span class="string">&quot;[<span class="subst">$&#123;param.fqName&#125;</span>]&quot;</span>)</span><br><span class="line">        .build()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建`HandlerFqName`类</span></span><br><span class="line"><span class="keyword">val</span> type = TypeSpec.objectBuilder(CLASS_NAME)</span><br><span class="line">    .addKdoc(<span class="string">&quot;The class is automatic generated by Sword, don&#x27;t modify it.\n\n&quot;</span>)</span><br><span class="line">    .addKdoc(<span class="string">&quot;[<span class="subst">$&#123;mInvocationHandlerName&#125;</span>]实现类的全限定名&quot;</span>)</span><br><span class="line">    .addProperties(propertySpecs)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取包名</span></span><br><span class="line"><span class="keyword">val</span> pkg = env.options[PACKAGE_NAME_PARAM_NAME]</span><br><span class="line"><span class="keyword">val</span> packageName = <span class="keyword">if</span> (pkg.isNullOrEmpty()) &#123;</span><br><span class="line">    DEFAULT_PACKAGE_NAME</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pkg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建`HandlerFqName`文件</span></span><br><span class="line"><span class="keyword">val</span> fileBuilder = FileSpec.builder(packageName, FILE_NAME)</span><br><span class="line">    .addFileComment(<span class="string">&quot;The file is automatic generated by Sword, don&#x27;t modify it.&quot;</span>)</span><br><span class="line">    .addType(type)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建生成文件的依赖关系</span></span><br><span class="line"><span class="keyword">val</span> sources =</span><br><span class="line">    classDeclaration.map &#123; it.containingFile &#125;.filterNotNull().toList().toTypedArray()</span><br><span class="line"><span class="keyword">val</span> dependencies = Dependencies(<span class="literal">true</span>, *sources)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成索引类</span></span><br><span class="line">fileBuilder.build().writeTo(codegen, dependencies)</span><br></pre></td></tr></table></figure>
<p>至此，通过 <code>KSP</code> 生成索引类完成。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本文简单记录了 <code>Sword</code> 的使用方式，以及在使用过程中发现的问题，最后使用 <code>KSP</code> 解决问题的过程。在解决问题的过程中，笔者参考 <code>EventBus</code> 的实现，结合问题本身的逻辑，形成自己的解决方案。</p>
<p>通过解决这个问题的过程，笔者感受到学习开源项目的魅力，当我们遇到问题时，或许开源项目也遇到过类似问题并有成熟的解决方案供我们参考。</p>
<p>最近笔者对 <code>Sword</code> 的功能实现有新的想法：通过 <code>Kotlin IR</code> 进行实现。</p>
<p>目前这只是一个初步想法，理论上实现起来应该比使用 <code>ASM</code> 简单一些吧，待笔者实现后再记录一下吧。</p>
<p>下篇再见，happy~</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Sword - 为 Kotlin 函数增加代理功能(四) - Kotlin IR</title>
    <url>/2022/10/22/gosp/sword/03-sword/</url>
    <content><![CDATA[<h1 id="sword-为-kotlin-函数增加代理功能四-kotlin-ir"><a class="markdownIt-Anchor" href="#sword-为-kotlin-函数增加代理功能四-kotlin-ir"></a> Sword - 为 Kotlin 函数增加代理功能(四) - Kotlin IR</h1>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>Sword：一个可以给 Kotlin 函数增加代理的第三方库，基于 KCP 实现。</p>
<ol>
<li><a href="https://sunxiaodou.com/2022/09/20/gosp/sword/00-sword/">Sword - 为 Kotlin 函数增加代理功能(一)</a></li>
<li><a href="https://sunxiaodou.com/2022/10/11/gosp/sword/01-sword/">Sword - 为 Kotlin 函数增加代理功能(二)</a></li>
<li><a href="https://sunxiaodou.com/2022/10/13/gosp/sword/02-sword/">Sword - 为 Kotlin 函数增加代理功能(三)</a></li>
</ol>
<p>前面三篇文章笔者记录了 <code>Sword</code> 的实现过程，如何使用 <code>Sword</code> 以及如何通过 <code>KSP</code> 为 <code>InvocationHandler</code> 生成 <code>FqName</code> 索引类 <code>HandlerFqName</code>。</p>
<p>在第三篇文章的最后笔者有一个新的想法：通过 <code>Kotlin IR</code> 重新实现 <code>Sword</code> 的功能。经过最近几天晚上和早晨的努力，笔者初步实现了 <code>Sword</code> 的功能，可能还有一些问题，但是效果已经达到了笔者的预期，遂本篇文章记录下笔者的实现过程。</p>
<p><code>Kotlin IR</code> 是什么以及可以做什么，本文不再赘述，网上有不少资料，读者可以自行参考。</p>
<h2 id="预期效果"><a class="markdownIt-Anchor" href="#预期效果"></a> 预期效果</h2>
<p>假设有以下类(<code>GetTextNoArgInvocationHandler</code>)和函数(<code>getTextNoArg()</code>)：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ProxyHandler(<span class="string">&quot;GET_TEXT_NO_ARG&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetTextNoArgInvocationHandler</span> : <span class="type">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = GetTextNoArgInvocationHandler::<span class="keyword">class</span>.java.simpleName</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(className: <span class="type">String</span>, methodName: <span class="type">String</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;invoke: className = <span class="variable">$className</span>, methodName = <span class="variable">$methodName</span>, args(<span class="subst">$&#123;args.size&#125;</span>) = <span class="subst">$&#123;args.joinToString()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;guodongAndroid-Debug&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Proxy(</span></span><br><span class="line"><span class="meta">    enable = true,</span></span><br><span class="line"><span class="meta">    handler = HandlerFqName.GET_TEXT_NO_ARG</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextNoArg</span><span class="params">()</span></span> = <span class="string">&quot;guodongAndroid&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>Kotlin IR</code> 编译和 <code>Sword</code> 代理后，笔者期望 <code>getTextNoArg</code> 函数转换成类似下面的伪代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Proxy(</span></span><br><span class="line"><span class="meta">    enable = true,</span></span><br><span class="line"><span class="meta">    handler = HandlerFqName.GET_TEXT_NO_ARG</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextNoArg</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> GetTextNoArgInvocationHandler().invoke(<span class="string">&quot;Test&quot;</span>, <span class="string">&quot;getTextNoArg&quot;</span>, emptyArray()) <span class="keyword">as</span> String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="swordcomponentregistrar"><a class="markdownIt-Anchor" href="#swordcomponentregistrar"></a> SwordComponentRegistrar</h2>
<p>要使用 <code>IR</code> 首先需要注册 <code>IrGenerationExtension</code> 扩展，修改之前 <code>SwordComponentRegistrar</code> 中的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SwordComponentRegistrar</span> : <span class="type">ComponentRegistrar</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerProjectComponents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        project: <span class="type">MockProject</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        configuration: <span class="type">CompilerConfiguration</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> messageCollector =</span><br><span class="line">	        configuration.<span class="keyword">get</span>(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY, MessageCollector.NONE)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*ClassBuilderInterceptorExtension.registerExtension(</span></span><br><span class="line"><span class="comment">            project,</span></span><br><span class="line"><span class="comment">            SwordClassGenerationInterceptor(messageCollector)</span></span><br><span class="line"><span class="comment">        )*/</span></span><br><span class="line"></span><br><span class="line">        IrGenerationExtension.registerExtension(</span><br><span class="line">            project,</span><br><span class="line">            SwordIrGenerationExtension(messageCollector)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中：</p>
<ol>
<li>注释掉之前通过 <code>ASM</code> 修改字节码的 <code>ClassBuilderInterceptorExtension</code> 扩展，</li>
<li>新增 <code>IrGenerationExtension</code> 扩展。</li>
</ol>
<h2 id="dump"><a class="markdownIt-Anchor" href="#dump"></a> Dump</h2>
<p>在 <code>IR</code> 语法树中，所有的节点都实现了 <code>IrElement</code> 接口，这些节点可以是模块，包，文件，类，属性，函数，参数，表达式，函数调用、函数体等等。</p>
<p>那么这些节点是什么样子的呢？实现我们的 <code>SwordIrGenerationExtension</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SwordIrGenerationExtension</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messageCollector: MessageCollector,</span><br><span class="line">) : IrGenerationExtension &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">generate</span><span class="params">(moduleFragment: <span class="type">IrModuleFragment</span>, pluginContext: <span class="type">IrPluginContext</span>)</span></span> &#123;</span><br><span class="line">        messageCollector.report(</span><br><span class="line">            CompilerMessageSeverity.WARNING,</span><br><span class="line">            moduleFragment.dump()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>IrElement</code> 的扩展函数 <code>dump</code> 可以输出这些节点的语法树信息。</p>
<p>在上面的代码中，我们输出了整个模块节点的语法树信息，如果模块中有许多文件，类，那么这些信息是相当庞大的，<code>Sword</code> 的目标是 <code>Kotlin</code> 函数，所以此处笔者不再贴出模块节点的语法树信息，等到我们转换函数时，再看看函数节点的语法树信息。</p>
<p>假设我们不知道如何编写 <code>IR</code> 编译器插件的代码，我们可以先写出要实现效果的 <code>Kotlin</code> 代码，再借助 <code>dump</code> 函数输出 <code>IR</code> 语法树信息，参考且对比语法树信息进行开发 <code>IR</code> 编译器插件，所以 <code>dump</code> 在开发 <code>IR</code> 编译器插件时非常有用。</p>
<h2 id="irelement"><a class="markdownIt-Anchor" href="#irelement"></a> IrElement</h2>
<p>前面说了很多 <code>IrElement</code> 接口，目前我们还不知道它的真面目，接下来让我们看看它吧：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IrElement</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, D&gt;</span> <span class="title">accept</span><span class="params">(visitor: <span class="type">IrElementVisitor</span>&lt;<span class="type">R</span>, D&gt;, <span class="keyword">data</span>: <span class="type">D</span>)</span></span>: R</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;D&gt;</span> <span class="title">acceptChildren</span><span class="params">(visitor: <span class="type">IrElementVisitor</span>&lt;<span class="type">Unit</span>, D&gt;, <span class="keyword">data</span>: <span class="type">D</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;D&gt;</span> <span class="title">transform</span><span class="params">(transformer: <span class="type">IrElementTransformer</span>&lt;<span class="type">D</span>&gt;, <span class="keyword">data</span>: <span class="type">D</span>)</span></span>: IrElement</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;D&gt;</span> <span class="title">transformChildren</span><span class="params">(transformer: <span class="type">IrElementTransformer</span>&lt;<span class="type">D</span>&gt;, <span class="keyword">data</span>: <span class="type">D</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>IrElement</code> 中有四个接口函数，其中 <code>accept</code> 函数基于访问者模式访问各个节点，<code>transform</code> 函数又是基于 <code>accept</code> 函数提供修改节点语法树的能力。</p>
<p><code>accept</code> 函数中的参数 <code>IrElementVisitor</code> 接口提供了访问各个节点的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IrElementVisitor</span>&lt;<span class="type">out R, in D</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">visitElement</span><span class="params">(element: <span class="type">IrElement</span>, <span class="keyword">data</span>: <span class="type">D</span>)</span></span>: R</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">visitModuleFragment</span><span class="params">(declaration: <span class="type">IrModuleFragment</span>, <span class="keyword">data</span>: <span class="type">D</span>)</span></span> = visitElement(declaration, <span class="keyword">data</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">visitPackageFragment</span><span class="params">(declaration: <span class="type">IrPackageFragment</span>, <span class="keyword">data</span>: <span class="type">D</span>)</span></span> = visitElement(declaration, <span class="keyword">data</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">visitFile</span><span class="params">(declaration: <span class="type">IrFile</span>, <span class="keyword">data</span>: <span class="type">D</span>)</span></span> = visitPackageFragment(declaration, <span class="keyword">data</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">visitDeclaration</span><span class="params">(declaration: <span class="type">IrDeclarationBase</span>, <span class="keyword">data</span>: <span class="type">D</span>)</span></span> = visitElement(declaration, <span class="keyword">data</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">visitClass</span><span class="params">(declaration: <span class="type">IrClass</span>, <span class="keyword">data</span>: <span class="type">D</span>)</span></span> = visitDeclaration(declaration, <span class="keyword">data</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">visitFunction</span><span class="params">(declaration: <span class="type">IrFunction</span>, <span class="keyword">data</span>: <span class="type">D</span>)</span></span> = visitDeclaration(declaration, <span class="keyword">data</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IrElementVisitor</code> 中有非常多接口函数，上面代码片段列举了一些接口函数，这些接口函数大多数都有默认实现，仔细观察这些函数的默认实现，最后都直接或间接的调用到 <code>visitElement</code> 函数。</p>
<p><code>transform</code> 函数中的参数 <code>IrElementTransformer</code> 接口继承自 <code>IrElementVisitor</code> 接口，<code>IrElementTransformer</code> 接口主要是实现了 <code>IrElementVisitor</code> 的接口函数并调用 <code>IrElement.transformChildren</code> 函数遍历节点修改节点的语法树：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IrElementTransformer</span>&lt;<span class="type">in D</span>&gt; : <span class="type">IrElementVisitor</span>&lt;<span class="type">IrElement, D</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitElement</span><span class="params">(element: <span class="type">IrElement</span>, <span class="keyword">data</span>: <span class="type">D</span>)</span></span>: IrElement &#123;</span><br><span class="line">        element.transformChildren(<span class="keyword">this</span>, <span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">return</span> element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitModuleFragment</span><span class="params">(declaration: <span class="type">IrModuleFragment</span>, <span class="keyword">data</span>: <span class="type">D</span>)</span></span>: IrModuleFragment &#123;</span><br><span class="line">        declaration.transformChildren(<span class="keyword">this</span>, <span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">return</span> declaration</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitFile</span><span class="params">(declaration: <span class="type">IrFile</span>, <span class="keyword">data</span>: <span class="type">D</span>)</span></span>: IrFile &#123;</span><br><span class="line">        declaration.transformChildren(<span class="keyword">this</span>, <span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">return</span> declaration</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Sword</code> 中，我们主要利用 <code>transform</code> 函数修改节点语法树的能力来实现为 <code>Kotlin</code> 函数增加代理功能。</p>
<h2 id="irtype-irsymbol"><a class="markdownIt-Anchor" href="#irtype-irsymbol"></a> IrType &amp; IrSymbol</h2>
<p>在 <code>IR</code> 中不仅有 <code>IrElement</code> 还有 <code>IrType</code> 和 <code>IrSymbol</code> 。那么这两个有什么作用呢？</p>
<h3 id="irtype"><a class="markdownIt-Anchor" href="#irtype"></a> IrType</h3>
<p><code>IrType</code> 可以说是 <code>KotlinType</code> 在 <code>IR</code> 中的另一种表现形式，表示 <code>Kotlin</code> 中的各种类型，比如 <code>Any</code>，<code>Boolean</code>，<code>Int</code>，<code>String</code> 等等。<code>IrType</code> 常用在比较函数参数类型，调用函数时传入参数类型等，举个 <code>Sword</code> 中的栗子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> anyNType = pluginContext.irBuiltIns.anyNType</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> stringType = pluginContext.irBuiltIns.stringType</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> arrayAnyNType = pluginContext.irBuiltIns.arrayClass.typeWith(anyNType)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `InvocationHandler.invoke(className: String, methodName: String, args: Array&lt;Any?&gt;): Any?`</span></span><br><span class="line"><span class="keyword">val</span> invokeSymbol =</span><br><span class="line">	pluginContext.referenceFunctions(FqName(<span class="string">&quot;<span class="subst">$&#123;param.handler&#125;</span>.<span class="variable">$INVOKE_METHOD_NAME</span>&quot;</span>))</span><br><span class="line">		.single &#123;</span><br><span class="line">    		<span class="keyword">val</span> valueParameters = it.owner.valueParameters</span><br><span class="line">    		valueParameters.size == <span class="number">3</span> &amp;&amp;</span><br><span class="line">    		valueParameters[<span class="number">0</span>].type == stringType &amp;&amp;</span><br><span class="line">    		valueParameters[<span class="number">1</span>].type == stringType &amp;&amp;</span><br><span class="line">    		valueParameters[<span class="number">2</span>].type == arrayAnyNType</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码片段中 <code>pluginContext</code> 是 <code>IrGenerationExtension.generate</code> 函数中的第二个参数，通过它的 <code>irBuiltIns</code> 字段我们获取一些 <code>Kotlin</code> 内置的 <code>IrType</code>。</p>
<ul>
<li><code>anyNType</code> 表示 <code>Kotlin</code> 中的 <code>Any?</code> 类型，</li>
<li><code>stringType</code> 表示 <code>String</code> 类型，如果想获取 <code>String?</code> 类型，则需要调用 <code>stringType.makeNullable()</code> ，</li>
<li><code>arrayAnyNType</code> 表示 <code>Array&lt;Any?&gt;</code> 类型，<code>Array</code> 没有对应的 <code>IrType</code> 表示，我们需要先获取 <code>Array</code> 对应的 <code>IrSymbol</code>，再调用 <code>typeWith</code> 扩展函数传入所需泛型的 <code>IrType</code> 即可获取 <code>Array&lt;Any?&gt;</code> 的 <code>IrType</code>。</li>
</ul>
<p>在上面代码片段的最后，笔者的目标是获取 <code>InvocationHandler.invoke</code> 函数的 <code>IrSymbol</code>，考虑到开发者可能会重载 <code>invoke</code> 函数，所以笔者增加了以下判断逻辑：</p>
<ol>
<li>函数中有且仅有三个参数，</li>
<li>第一个参数的类型必须是 <code>String</code> 类型，</li>
<li>第二个参数的类型必须是 <code>String</code> 类型，</li>
<li>第三个参数的类型必须是 <code>Array&lt;Any?&gt;</code> 类型。</li>
</ol>
<p>满足以上几个条件的函数笔者才认为是 <code>InvocationHandler.invoke</code> 函数。</p>
<h3 id="irsymbol"><a class="markdownIt-Anchor" href="#irsymbol"></a> IrSymbol</h3>
<p><code>IrSymbol</code> 在 <code>Kotlin IR</code> 中可以算是比较重要的一个接口了。它以「符号」的形式描述了 <code>Kotlin</code> 的包、文件、类、函数、属性、字段等，笔者把它理解为 Java 字节码中的描述符，所以 <code>IrSymbol</code> 常用在创建类、函数、属性，函数调用等，举个 <code>Sword</code> 中的栗子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> anyNType = pluginContext.irBuiltIns.anyNType</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> emptyArraySymbol = pluginContext.referenceFunctions(FqName(<span class="string">&quot;kotlin.emptyArray&quot;</span>)).first()</span><br><span class="line"></span><br><span class="line">irCall(emptyArraySymbol).also &#123;</span><br><span class="line">    it.putTypeArgument(<span class="number">0</span>, anyNType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>anyNType</code> 在上节中出现过，它表示 <code>Any?</code> 类型，</li>
<li><code>emptyArraySymbol</code> 是 <code>emptyArray()</code> 函数在 <code>IR</code> 中的符号，我们同样可以通过 <code>irBuiltIns</code> 获取一些 <code>Kotlin</code> 内置的 <code>IrSymbol</code>，<strong>其他的符号可以通过 <code>pluginContext.referenceXXX()</code> 的一系列函数查找</strong>。</li>
<li>接下来调用 <code>irCall</code> 函数并传入 <code>emptyArraySymbol</code>，最后调用 <code>putTypeArgument()</code> 函数设置 <code>emptyArray()</code> 函数的泛型。</li>
</ul>
<p>所以上面的代码片段其实是调用 <code>Kotlin</code> 中的 <code>emptyArray&lt;Any?&gt;()</code>  函数。</p>
<h2 id="sword"><a class="markdownIt-Anchor" href="#sword"></a> Sword</h2>
<h3 id="swordirgenerationextension"><a class="markdownIt-Anchor" href="#swordirgenerationextension"></a> SwordIrGenerationExtension</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SwordIrGenerationExtension</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messageCollector: MessageCollector,</span><br><span class="line">) : IrGenerationExtension &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> proxyAnnotationFqName = FqName(<span class="string">&quot;com.guodong.android.sword.api.kt.Proxy&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">generate</span><span class="params">(moduleFragment: <span class="type">IrModuleFragment</span>, pluginContext: <span class="type">IrPluginContext</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 输出日志</span></span><br><span class="line">        messageCollector.report(</span><br><span class="line">            CompilerMessageSeverity.WARNING,</span><br><span class="line">            <span class="string">&quot;Welcome to guodongAndroid sword kcp kotlin ir plugin&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前模块是否存在 `Proxy` 注解</span></span><br><span class="line">        <span class="keyword">val</span> proxyAnnotation = pluginContext.referenceClass(proxyAnnotationFqName)</span><br><span class="line">        <span class="keyword">if</span> (proxyAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">            messageCollector.report(</span><br><span class="line">                CompilerMessageSeverity.ERROR,</span><br><span class="line">                <span class="string">&quot;Not found `Proxy` annotation, make sure to add the \&quot;sword-api-kt\&quot; library to your dependencies&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始转换</span></span><br><span class="line">        moduleFragment.transform(</span><br><span class="line">            SwordTransformer(pluginContext, proxyAnnotation, messageCollector),</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过前面的知识铺垫， <code>SwordIrGenerationExtension</code> 中的代码逻辑相信读者应该能理解了，笔者这里就不再赘述了，没有理解的读者可以再回顾下前面的内容。</p>
<p>接下来我们主要看看 <code>SwordTransformer</code> 中的逻辑。</p>
<h3 id="swordtransformer"><a class="markdownIt-Anchor" href="#swordtransformer"></a> SwordTransformer</h3>
<p>因为 <code>Sword</code> 的功能是为 <code>Kotlin</code> 函数增加代理功能，所以在 <code>SwordTransformer</code> 中我们仅关注与函数相关的转换函数，即：<code>visitFunctionNew(declaration: IrFunction)</code> 函数。</p>
<p>首先声明一些变量和常量，其中一些变量前面笔者已经介绍过：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="comment">// `InvocationHandler` 中的 `invoke` 函数名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> INVOKE_METHOD_NAME = <span class="string">&quot;invoke&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> anyNType = pluginContext.irBuiltIns.anyNType</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> stringType = pluginContext.irBuiltIns.stringType</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> arrayAnyNType = pluginContext.irBuiltIns.arrayClass.typeWith(anyNType)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> emptyArraySymbol = pluginContext.referenceFunctions(FqName(<span class="string">&quot;kotlin.emptyArray&quot;</span>)).first()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> arrayOfSymbol = pluginContext.irBuiltIns.arrayOf</span><br><span class="line"></span><br><span class="line"><span class="comment">// @JvmName 注解完全限定名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> jvmNameAnnotationFqName = FqName(<span class="string">&quot;kotlin.jvm.JvmName&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Proxy 注解完全限定名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> proxyAnnotationFqName = FqName(<span class="string">&quot;com.guodong.android.sword.api.kt.Proxy&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>下面我们就覆写 <code>visitFunctionNew()</code> 函数，在覆写的 <code>visitFunctionNew()</code> 函数中有较多的代码逻辑，还是老习惯，笔者先描述下自己的实现思路，然后再根据实现思路依次进行代码实现：</p>
<ol>
<li>过滤一些笔者认为不需要处理的函数，读者可以自行斟酌；过滤不包含 <code>Proxy</code> 注解的函数，</li>
<li>获取 <code>Proxy</code> 注解里的数据存储于第二篇文章中的 <code>SwordParam</code> 中，</li>
<li>获取当前类名和函数名，判断当前函数是否启用代理，如果启用了代理但是 <code>handler</code> 为空则抛出异常，</li>
<li>启用代理后，我们直接抛弃原函数体，生成新的代理函数体。</li>
</ol>
<h4 id="1过滤"><a class="markdownIt-Anchor" href="#1过滤"></a> 1.过滤</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitFunctionNew</span><span class="params">(declaration: <span class="type">IrFunction</span>)</span></span>: IrStatement &#123;</span><br><span class="line">    <span class="comment">// 过滤挂起函数，内联函数，多平台声明函数，外部函数(JNI)</span></span><br><span class="line">    <span class="keyword">if</span> (declaration.isSuspend || declaration.isInline || declaration.isExpect || declaration.isExternal) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.visitFunctionNew(declaration)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (declaration <span class="keyword">is</span> IrSimpleFunction) &#123;</span><br><span class="line">        <span class="comment">// 过滤中缀函数，尾递归函数，操作符函数</span></span><br><span class="line">        <span class="keyword">if</span> (declaration.isInfix || declaration.isTailrec || declaration.isOperator) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitFunctionNew(declaration)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤函数体为空的函数，不包含 `Proxy` 注解的函数</span></span><br><span class="line">    <span class="keyword">if</span> (declaration.body == <span class="literal">null</span> || !declaration.hasAnnotation(annotationClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.visitFunctionNew(declaration)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>过滤挂起函数，内联函数，多平台声明函数，外部函数(JNI)，</li>
<li>过滤中缀函数，尾递归函数，操作符函数，</li>
<li>过滤函数体为空的函数，不包含 <code>Proxy</code> 注解的函数。</li>
</ol>
<h4 id="2获取"><a class="markdownIt-Anchor" href="#2获取"></a> 2.获取</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitFunctionNew</span><span class="params">(declaration: <span class="type">IrFunction</span>)</span></span>: IrStatement &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> param = SwordParam()</span><br><span class="line">    param.hasProxyAnnotation = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取函数上 `Proxy` 注解的 `IrElement`, 返回 `IrConstructorCall`</span></span><br><span class="line">    <span class="keyword">val</span> irProxyConstructorCall = declaration.annotations.filter &#123;</span><br><span class="line">        it.isAnnotation(proxyAnnotationFqName)</span><br><span class="line">    &#125;.toList().single()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 `Proxy.enable` 属性的值并存储</span></span><br><span class="line">    <span class="keyword">val</span> enableParam = irProxyConstructorCall.getValueArgument(<span class="number">0</span>)</span><br><span class="line">    enableParam?.let &#123;</span><br><span class="line">        <span class="keyword">if</span> (it <span class="keyword">is</span> IrConst&lt;*&gt;) &#123;</span><br><span class="line">            param.enable = it.value <span class="keyword">as</span> <span class="built_in">Boolean</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 `Proxy.handler` 属性的值并存储</span></span><br><span class="line">    <span class="keyword">val</span> handlerParam = irProxyConstructorCall.getValueArgument(<span class="number">1</span>)</span><br><span class="line">    handlerParam?.let &#123;</span><br><span class="line">        <span class="keyword">if</span> (it <span class="keyword">is</span> IrConst&lt;*&gt;) &#123;</span><br><span class="line">            param.handler = it.value <span class="keyword">as</span> String</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 <code>Proxy</code> 注解中的数据，比较麻烦一些，一开始笔者认为获取到的注解可能类似于 <code>IrAnnotation</code>，然而发现却是 <code>IrConstructorCall</code>，后面仔细想来注解不就是通过构造函数构建一个注解实例么？我们在注解中传入的参数都是赋值给了其构造函数的属性。</p>
<p>通过 <code>getValueArgument()</code> 函数根据注解中声明属性的顺序获取其对应的属性，因为属性可能有默认值，我们在使用时可以不传入某个属性，比如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Proxy(</span></span><br><span class="line"><span class="meta">    // enable = true,</span></span><br><span class="line"><span class="meta">    handler = HandlerFqName.GET_TEXT_NO_ARG</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextNoArg</span><span class="params">()</span></span> = <span class="string">&quot;guodongAndroid&quot;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>Proxy</code> 注解中 <code>enable</code> 默认为 <code>True</code>，所以我们在使用时可以不传入 <code>enable</code> 的值，使其使用默认值，但是对于 <code>kotlin IR</code> 来说，没有明确使用的属性，通过 <code>getValueArgument()</code> 函数获取到的为 <code>null</code>，因为在 <code>Kotlin IR</code> 语法树中找不到这个属性。</p>
<p>由于注解中的属性值必须是编译期常量，所以我们可以把 <code>handlerParam</code> 转换为 <code>IrConst</code> 并获取它的值。</p>
<h4 id="3校验"><a class="markdownIt-Anchor" href="#3校验"></a> 3.校验</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitFunctionNew</span><span class="params">(declaration: <span class="type">IrFunction</span>)</span></span>: IrStatement &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ClassName</span></span><br><span class="line">    <span class="keyword">val</span> className: String = getClassName(declaration)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 MethodName</span></span><br><span class="line">    <span class="keyword">val</span> methodName = declaration.name.asString()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验 开启代理后是否注入了 `handler`</span></span><br><span class="line">    <span class="keyword">if</span> (param.enable &amp;&amp; (param.handler.isEmpty() || param.handler.isBlank())) &#123;</span><br><span class="line">        messageCollector.report(</span><br><span class="line">            CompilerMessageSeverity.ERROR,</span><br><span class="line">            <span class="string">&quot;[<span class="variable">$className</span>.<span class="variable">$methodName</span>]启用代理后请注入`handler`&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getClassName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    declaration: <span class="type">IrFunction</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> parentClassOrNull = declaration.parentClassOrNull</span><br><span class="line">    <span class="keyword">val</span> fileOrNull = declaration.fileOrNull</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        declaration.isLocal -&gt; &#123;</span><br><span class="line">            <span class="comment">// 本地方法: 类名.函数名.&lt;anonymous&gt;</span></span><br><span class="line">            <span class="comment">// 源码中有此逻辑, 逻辑较为繁琐，且不是 `Sword` 的核心逻辑，本文就不记录了</span></span><br><span class="line">        &#125;</span><br><span class="line">        parentClassOrNull != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取类名</span></span><br><span class="line">            parentClassOrNull.name.asString()</span><br><span class="line">        &#125;</span><br><span class="line">        fileOrNull != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果是顶级函数，获取文件名或`JvmName`注解指定的名字</span></span><br><span class="line">            <span class="keyword">val</span> annotations = fileOrNull.annotations</span><br><span class="line">            <span class="keyword">if</span> (annotations.hasAnnotation(jvmNameAnnotationFqName)) &#123;</span><br><span class="line">                <span class="keyword">val</span> <span class="keyword">annotation</span> = annotations.findAnnotation(jvmNameAnnotationFqName)!!</span><br><span class="line">                <span class="keyword">val</span> expression = <span class="keyword">annotation</span>.getValueArgument(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (expression != <span class="literal">null</span> &amp;&amp; expression <span class="keyword">is</span> IrConst&lt;*&gt;) &#123;</span><br><span class="line">                    expression.value <span class="keyword">as</span> String</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    fileOrNull.name</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fileOrNull.name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 <code>ClassName</code> 时有以下几点考虑：</p>
<ol>
<li>首先判断是否是本地方法，如果是本地方法则获取 <code>类名.方法名.[&lt;anonymous&gt;]</code>，</li>
<li>其次获取当前函数所在的父级 <code>IrClass</code>，如果不为 <code>null</code>，则使用类名，</li>
<li>最后获取函数所在的 <code>IrFile</code>，如果不为 <code>null</code>，再判断文件上是否有 <code>JvmName</code> 注解，有的话使用 <code>JvmName</code> 注解指定的名字，否则使用文件名。</li>
</ol>
<p>获取 <code>MethodName</code> 时直接使用了函数名称，此处没有判断函数上是否有 <code>JvmName</code> 注解逻辑，相信读者可以自行扩展。</p>
<p>下面就是一个开启代理后必须注入 <code>handler</code> 的校验逻辑。</p>
<h4 id="4转换"><a class="markdownIt-Anchor" href="#4转换"></a> 4.转换</h4>
<p>在前面介绍 <code>dump</code> 函数时我们并没有实际上看看 <code>dump</code> 函数的输出内容，接下来让我们看看它输出的语法树信息。</p>
<p>以下面的函数为例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Proxy(</span></span><br><span class="line"><span class="meta">    enable = true,</span></span><br><span class="line"><span class="meta">    handler = HandlerFqName.GetTextArgInvocationHandler</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testHandler</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">    <span class="keyword">return</span> GetTextArgInvocationHandler().invoke(<span class="string">&quot;Test&quot;</span>, <span class="string">&quot;testHandler&quot;</span>, emptyArray()) <span class="keyword">as</span> User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dump</code> 函数的输出结果如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">FUN name:testHandler visibility:public modality:FINAL &lt;&gt; (<span class="variable">$this</span>:com.guodong.android.sword.app.Test) returnType:com.guodong.android.sword.app.User</span><br><span class="line">  annotations:</span><br><span class="line">    Proxy(<span class="built_in">enable</span> = <span class="string">&#x27;true&#x27;</span>, handler = <span class="string">&#x27;com.guodong.android.sword.app.GetTextArgInvocationHandler&#x27;</span>)</span><br><span class="line">  <span class="variable">$this</span>: VALUE_PARAMETER name:&lt;this&gt; type:com.guodong.android.sword.app.Test</span><br><span class="line">  BLOCK_BODY</span><br><span class="line">    RETURN <span class="attribute">type</span>=kotlin.Nothing <span class="attribute">from</span>=<span class="string">&#x27;public final fun testHandler (): com.guodong.android.sword.app.User declared in com.guodong.android.sword.app.Test&#x27;</span></span><br><span class="line">      TYPE_OP <span class="attribute">type</span>=com.guodong.android.sword.app.User <span class="attribute">origin</span>=CAST <span class="attribute">typeOperand</span>=com.guodong.android.sword.app.User</span><br><span class="line">        CALL <span class="string">&#x27;public open fun invoke (className: kotlin.String, methodName: kotlin.String, args: kotlin.Array&lt;kotlin.Any?&gt;): kotlin.Any? declared in com.guodong.android.sword.app.GetTextArgInvocationHandler&#x27;</span> <span class="attribute">type</span>=kotlin.Any? <span class="attribute">origin</span>=<span class="literal">null</span></span><br><span class="line">          <span class="variable">$this</span>: CONSTRUCTOR_CALL <span class="string">&#x27;public constructor &lt;init&gt; () [primary] declared in com.guodong.android.sword.app.GetTextArgInvocationHandler&#x27;</span> <span class="attribute">type</span>=com.guodong.android.sword.app.GetTextArgInvocationHandler <span class="attribute">origin</span>=<span class="literal">null</span></span><br><span class="line">          className: CONST String <span class="attribute">type</span>=kotlin.String <span class="attribute">value</span>=<span class="string">&quot;Test&quot;</span></span><br><span class="line">          methodName: CONST String <span class="attribute">type</span>=kotlin.String <span class="attribute">value</span>=<span class="string">&quot;testHandler&quot;</span></span><br><span class="line">          args: CALL <span class="string">&#x27;public final fun emptyArray &lt;T&gt; (): kotlin.Array&lt;T of kotlin.ArrayIntrinsicsKt.emptyArray&gt; [inline] declared in kotlin.ArrayIntrinsicsKt&#x27;</span> <span class="attribute">type</span>=kotlin.Array&lt;kotlin.Any?&gt; <span class="attribute">origin</span>=<span class="literal">null</span></span><br><span class="line">            &lt;T&gt;: kotlin.Any?</span><br></pre></td></tr></table></figure>
<p><code>fun testHandler(): User</code></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">FUN <span class="keyword">name</span>:testHandler visibility:<span class="keyword">public</span> modality:<span class="keyword">FINAL</span> &lt;&gt; ($this:com.guodong.android.sword.app.Test) returnType:com.guodong.android.sword.app.User</span><br></pre></td></tr></table></figure>
<p>这是 <code>testHandler</code> 函数的定义。它定义了函数的名称，可见性，模态以及类型签名。我们可以清楚的看到它是一个 <code>public</code> 和 <code>final</code> 名为 <code>testHandler</code> 的函数，并且它有一个隐含的参数 <code>this</code>（<code>()</code>），但是没有类型参数（<code>&lt;&gt;</code>），最后返回值为 <code>com.guodong.android.sword.app.User</code>。</p>
<p>类中的非静态函数(构造函数除外)都有一个隐含的 <code>this</code> 参数：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="variable">$this</span>: VALUE_PARAMETER name:&lt;this&gt; type:com<span class="selector-class">.guodong</span><span class="selector-class">.android</span><span class="selector-class">.sword</span><span class="selector-class">.app</span>.Test</span><br></pre></td></tr></table></figure>
<p><code>GetTextArgInvocationHandler()</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="variable">$this</span>: CONSTRUCTOR_CALL <span class="string">&#x27;public constructor &lt;init&gt; () [primary] declared in com.guodong.android.sword.app.GetTextArgInvocationHandler&#x27;</span> type=com<span class="selector-class">.guodong</span><span class="selector-class">.android</span><span class="selector-class">.sword</span><span class="selector-class">.app</span><span class="selector-class">.GetTextArgInvocationHandler</span> origin=null</span><br></pre></td></tr></table></figure>
<p>调用 <code>GetTextArgInvocationHandler</code> 的无参构造方法。</p>
<p><code>Test &amp; testHandler</code></p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="symbol">className:</span> <span class="keyword">CONST</span> <span class="type">String</span> type=kotlin.<span class="type">String</span> value=<span class="string">&quot;Test&quot;</span></span><br><span class="line"><span class="symbol">methodName:</span> <span class="keyword">CONST</span> <span class="type">String</span> type=kotlin.<span class="type">String</span> value=<span class="string">&quot;testHandler&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Test</code> 和 <code>testHandler</code> 作为一个常量字符串。</p>
<p><code>emptyArray()</code></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">args: <span class="keyword">CALL</span> <span class="string">&#x27;public final fun emptyArray &lt;T&gt; (): kotlin.Array&lt;T of kotlin.ArrayIntrinsicsKt.emptyArray&gt; [inline] declared in kotlin.ArrayIntrinsicsKt&#x27;</span> <span class="keyword">type</span>=kotlin.<span class="keyword">Array</span>&lt;kotlin.<span class="keyword">Any</span>?&gt; origin=<span class="keyword">null</span></span><br><span class="line">            &lt;T&gt;: kotlin.<span class="keyword">Any</span>?</span><br></pre></td></tr></table></figure>
<p><code>emptyArray()</code> 函数是有类型参数的，因编译器推导我们在编写代码时可以省略，但是在 <code>Kotlin IR</code> 中明确显示了它的类型参数（<code>&lt;T&gt;: kotlin.Any?</code>），<strong>所以我们在转换代码时需要注意此处细节，否则转换代码在编译期不会报错，在运行时会抛出异常</strong>。</p>
<p><code>invoke(&quot;Test&quot;, &quot;testHandler&quot;, emptyArray())</code></p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">CALL &#x27;public open fun<span class="built_in"> invoke </span>(className: kotlin.String, methodName: kotlin.String, args: kotlin.Array&lt;kotlin.Any?&gt;): kotlin.Any? declared in com.guodong.android.sword.app.GetTextArgInvocationHandler&#x27; type=kotlin.Any? origin=null</span><br></pre></td></tr></table></figure>
<p>这是 <code>invoke</code> 函数的调用，清楚表示调用 <code>invoke</code> 函数需要三个参数以及参数的类型，同时函数返回值为 <code>kotlin.Any?</code></p>
<p><code>as String</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">TYPE_OP type=com<span class="selector-class">.guodong</span><span class="selector-class">.android</span><span class="selector-class">.sword</span><span class="selector-class">.app</span><span class="selector-class">.User</span> origin=CAST typeOperand=com<span class="selector-class">.guodong</span><span class="selector-class">.android</span><span class="selector-class">.sword</span><span class="selector-class">.app</span>.User</span><br></pre></td></tr></table></figure>
<p>这是强转操作，<code>TYPE_OP</code> 表示一种类型操作，<code>origin=CAST</code> 表示类型操作符。</p>
<p><code>return</code></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RETURN</span> <span class="keyword">type</span>=kotlin.<span class="keyword">Nothing</span> <span class="keyword">from</span>=<span class="string">&#x27;public final fun testHandler (): com.guodong.android.sword.app.User declared in com.guodong.android.sword.app.Test&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>Kotlin</code> 中 <code>return</code>  <a href="https://kotlinlang.org/docs/returns.html">其实是一个表达式</a>，所以此处 <code>return</code> 的 <code>type</code> 是 <code>kotlin.Nothing</code> 。</p>
<p>通过上面 <code>dump</code> 函数输出语法树的分析，我们已经知道转换后函数体的语法信息，接下来让我们根据上面的分析依次来实现吧。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> handlerConstructorSymbol =</span><br><span class="line">	pluginContext.referenceConstructors(FqName(param.handler)).single &#123;</span><br><span class="line">	    it.owner.valueParameters.isEmpty()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过 <code>pluginContext.referenceConstructors()</code> 查找 <code>Handler</code> 类的无参构造函数的符号。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">val invokeSymbol =</span><br><span class="line">	pluginContext<span class="selector-class">.referenceFunctions</span>(<span class="built_in">FqName</span>(<span class="string">&quot;$&#123;param.handler&#125;.$INVOKE_METHOD_NAME&quot;</span>))</span><br><span class="line">		<span class="selector-class">.single</span> &#123;</span><br><span class="line">			val valueParameters = it<span class="selector-class">.owner</span><span class="selector-class">.valueParameters</span></span><br><span class="line">			valueParameters<span class="selector-class">.size</span> == <span class="number">3</span> &amp;&amp;</span><br><span class="line">					valueParameters<span class="selector-attr">[0]</span><span class="selector-class">.type</span> == stringType &amp;&amp;</span><br><span class="line">					valueParameters<span class="selector-attr">[1]</span><span class="selector-class">.type</span> == stringType &amp;&amp;</span><br><span class="line">					valueParameters<span class="selector-attr">[2]</span><span class="selector-class">.type</span> == arrayAnyNType</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>接下来通过 <code>pluginContext.referenceFunctions()</code> 查找 <code>Handler</code> 类的 <code>invoke</code> 函数，可能存在函数重载，需要通过 <code>single</code>  函数确定我们需要的函数，这个在前面 <code>IrType</code> 举过例子。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IrBuilderWithScope.<span class="title">irSwordArrayParams</span><span class="params">(function: <span class="type">IrFunction</span>)</span></span>: IrCall &#123;</span><br><span class="line">    <span class="keyword">val</span> parameters = function.valueParameters</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (parameters.isEmpty()) &#123;</span><br><span class="line">        irCall(emptyArraySymbol).also &#123;</span><br><span class="line">            it.putTypeArgument(<span class="number">0</span>, anyNType)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        irCall(arrayOfSymbol).also &#123;</span><br><span class="line">            <span class="keyword">val</span> expressions = parameters.map &#123; parameter -&gt; irGet(parameter) &#125;</span><br><span class="line">            it.putValueArgument(<span class="number">0</span>, irVararg(anyNType, expressions))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是组装 <code>invoke</code> 函数的第三个参数 <code>args: Array&lt;Any?&gt;</code>，当前函数没有参数时使用 <code>emptyArray&lt;Any?&gt;()</code>，有参数时使用 <code>arrayOf(vararg elements: T)</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> invokeCall = irCall(invokeSymbol).apply &#123;</span><br><span class="line">    dispatchReceiver = irCallConstructor(handlerConstructorSymbol, emptyList())</span><br><span class="line">    putValueArgument(<span class="number">0</span>, irString(className))</span><br><span class="line">    putValueArgument(<span class="number">1</span>, irString(methodName))</span><br><span class="line">    putValueArgument(<span class="number">2</span>, irSwordArrayParams(function))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造 <code>Handler</code> 实例并调用它的 <code>invoke</code> 函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> irReturn = irReturn(</span><br><span class="line">    typeOperator(</span><br><span class="line">        resultType = function.returnType,</span><br><span class="line">        argument = invokeCall,</span><br><span class="line">        typeOperator = IrTypeOperator.CAST,</span><br><span class="line">        typeOperand = function.returnType</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>typeOperator</code> 是语法树中的 <code>TYPE_OP</code>，就是强转操作，<code>irReturn</code> 表示 <code>Kotlin</code> 中的 <code>return</code> 表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">irSword</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    function: <span class="type">IrFunction</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    param: <span class="type">SwordParam</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    className: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    methodName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: IrBlockBody &#123;</span><br><span class="line">    <span class="keyword">return</span> DeclarationIrBuilder(pluginContext, function.symbol).irBlockBody &#123;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        +irReturn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>+</code> 操作符（<code>unaryPlus</code>）链接整个返回表达式到函数体，最后用新的函数体替换原函数体达到代理的功能：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitFunctionNew</span><span class="params">(declaration: <span class="type">IrFunction</span>)</span></span>: IrStatement &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (param.enable) &#123;</span><br><span class="line">        declaration.body = irSword(declaration, param, className, methodName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.visitFunctionNew(declaration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，使用 <code>Kotlin IR</code> 为 <code>Kotlin</code> 函数增加代理功能完成。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本文简单记录了通过 <code>Kotlin IR</code> 实现 <code>Sword</code> 代理功能的过程，同时简单介绍了一些 <code>Kotlin IR</code> 的 API 以及笔者对这些 API 的个人理解。</p>
<p>希望可以帮您开发自己的 <code>Kotlin</code> 编译器插件，happy~</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
</search>
