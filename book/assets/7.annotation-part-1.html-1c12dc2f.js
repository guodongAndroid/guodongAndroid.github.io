import{_ as s}from"./7.annotation-type-8860ced4.js";import{_ as o,Y as t,Z as c,$ as e,a0 as a,a1 as d,a2 as p,a3 as l,E as i}from"./framework-3d290349.js";const r={},u=e("h2",{id:"前言",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),a(" 前言")],-1),k=l('<h2 id="注解类型" tabindex="-1"><a class="header-anchor" href="#注解类型" aria-hidden="true">#</a> 注解类型</h2><p><img src="'+s+`" alt="注解类型" loading="lazy"></p><p>如上图所示，Retrofit 中的注解主要分为以下三种类型：</p><ol><li>请求方法相关的注解，</li><li>请求参数相关的注解，</li><li>标记类型相关的注解。</li></ol><p><strong>本篇文章我们主要学习请求方法与标记类型相关的注解。</strong></p><h2 id="请求方法注解" tabindex="-1"><a class="header-anchor" href="#请求方法注解" aria-hidden="true">#</a> 请求方法注解</h2><p>Retrofit 提供了 <strong>7种</strong> 常见的HTTP请求方法注解，分别是：</p><ol><li>GET请求：<code>@GET</code>，</li><li>POST请求：<code>@POST</code>，</li><li>PUT请求：<code>@PUT</code>，</li><li>DELETE请求：<code>@DELETE</code>，</li><li>PATCH请求：<code>@PATCH</code>，</li><li>HEAD请求：<code>@HEAD</code>，</li><li>OPTIONS请求：<code>@OPTIONS</code>，</li></ol><p>这几种请求注解都可以传入一个相对或绝对的路径，或者完整的URL来表示 <code>endpoint</code>，如 <code>@GET</code> 注解：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@GET</span><span class="token punctuation">(</span><span class="token string">&quot;/foo&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>endpoint：可以简单理解为HTTP请求地址，可以是相对路径，绝对路径，或者完整的URL地址。</p></blockquote><p><code>@HTTP</code> 注解有三个参数，一个必选参数，两个可选参数：</p><ol><li><code>method</code>：HTTP请求方法，如：<code>GET</code>, <code>POST</code>等，必须大写，</li><li><code>path</code>： <code>endpoint</code>，同上面常见请求方法注解的参数，</li><li><code>hasBody</code> ：是否有请求体，默认false，</li></ol><p>可以替换上面7种请求注解，比如替换<code>@GET</code>注解：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@HTTP</span><span class="token punctuation">(</span>method <span class="token operator">=</span> <span class="token string">&quot;GET&quot;</span><span class="token punctuation">,</span> path <span class="token operator">=</span> <span class="token string">&quot;/foo&quot;</span><span class="token punctuation">,</span> hasBody <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也支持其他的HTTP请求方法，比如<code>TRACE</code>请求方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@HTTP</span><span class="token punctuation">(</span>method <span class="token operator">=</span> <span class="token string">&quot;TRACE&quot;</span><span class="token punctuation">,</span> path <span class="token operator">=</span> <span class="token string">&quot;/foo&quot;</span><span class="token punctuation">,</span> hasBody <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>需要注意</strong>：</p><blockquote><ol><li><p>如果我们定义的接口方法中的第一个参数被 <code>@Url</code> 注解标记，那么请求方法注解中的参数只能是默认值（即：空字符串），</p></li><li><p>有关 <code>@Url</code> 注解的使用，下篇文章我们再学习。</p></li></ol></blockquote><h3 id="结合规则" tabindex="-1"><a class="header-anchor" href="#结合规则" aria-hidden="true">#</a> 结合规则</h3><p>我们知道 Retrofit 必须传入一个 <code>baseUrl</code>，否则会抛出异常，那么 <code>baseUrl</code> 与 <code>endpoint</code> 之间是怎样的一种结合规则？</p><p>首先我们知道 <code>baseUrl</code> 必须以 <code>/</code> 结尾，</p><p>其次我们需要再明确下 <code>endpoint</code> 中什么是相对路径和绝对路径：<strong>如果 <code>endpoint</code> 以 <code>/</code> 开头，那么就是绝对路径，反之则是相对路径</strong>：</p><ol><li><code>/foo/bar</code>：是绝对路径，</li><li><code>foo/bar</code>：是相对路径</li></ol><p>最后 <code>baseUrl</code> 与 <code>endpoint</code> 之间的结合规则如下：</p><table><thead><tr><th>baseUrl</th><th>endpoint</th><th>result</th><th>说明</th></tr></thead><tbody><tr><td>http://example.com/api/</td><td>/foo/bar/</td><td>http://example.com/foo/bar/</td><td>绝对路径的endpoint仅会保留baseUrl中host部分，<br>忽略baseUrl中任何指定的路径</td></tr><tr><td>http://example.com/api/</td><td>foo/bar/</td><td>http://example.com/api/foo/bar/</td><td>期望的请求地址</td></tr><tr><td>http://example.com/</td><td>https://github.com/square/retrofit/</td><td>https://github.com/square/retrofit/</td><td>1.如果endpoint包含host，则替换baseUrl中的host,<br>2.如果endpoint包含scheme，也会替换baseUrl中的scheme</td></tr><tr><td>http://example.com/</td><td>//github.com/square/retrofit/</td><td>http://github.com/square/retrofit/</td><td>仅替换了baseUrl中的host，没有替换scheme</td></tr></tbody></table><h2 id="标记注解" tabindex="-1"><a class="header-anchor" href="#标记注解" aria-hidden="true">#</a> 标记注解</h2><h3 id="tag" tabindex="-1"><a class="header-anchor" href="#tag" aria-hidden="true">#</a> @Tag</h3><p><code>@Tag</code> 注解标记HTTP接口方法中的参数，可以为每个HTTP请求增加一个标记，它的使用如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Call</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ResponseBody</span><span class="token punctuation">&gt;</span></span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Tag</span> <span class="token class-name">String</span> tag<span class="token punctuation">)</span><span class="token punctuation">;</span>
request<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Call</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ResponseBody</span><span class="token punctuation">&gt;</span></span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Tag</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> tag<span class="token punctuation">)</span><span class="token punctuation">;</span>
request<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>@Tag</code> 注解以参数的 <code>class</code> 类型为键，参数值为值进行存储，如果参数是泛型类型(参数化类型)，则取它的原始类型为键。后续我们可以通过 <code>Request.tag</code> 方法获取设置的 <code>Tag</code> 值，比如可以在拦截器中获取进行一些特殊操作。</p><p><strong>需要注意：</strong></p><blockquote><p>如果存在两个相同键值的 <code>@Tag</code> 会导致抛出异常：<code>IllegalArgumentException(@Tag type java.lang.String is duplicate of parameter #1 and would always overwrite its value. (parameter #2) for method xxxxx)</code></p></blockquote><h3 id="streaming" tabindex="-1"><a class="header-anchor" href="#streaming" aria-hidden="true">#</a> @Streaming</h3><p><code>@Streaming</code> 注解标记HTTP接口方法，当接口方法的返回值类型为：<code>ResponseBody</code>时，返回原始的 <code>ResponseBody</code> 而不是 Retrofit 预读取/处理后的 <code>ResponseBody</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token class-name">ResponseBody</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Utils</span><span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>annotations<span class="token punctuation">,</span> <span class="token class-name">Streaming</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
        <span class="token operator">?</span> <span class="token class-name">StreamingResponseBodyConverter</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span> <span class="token comment">// 原始的ResponseBody</span>
        <span class="token operator">:</span> <span class="token class-name">BufferingResponseBodyConverter</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span> <span class="token comment">// 预读取/处理的ResponseBody</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>需要注意：</strong></p><blockquote><p>如果我们使用了 <code>@Streaming</code> 注解，那么数据的读取以及读取过程中 <code>socket</code> 的一些异常就需要我们自己处理了。</p></blockquote><h3 id="formurlencoded" tabindex="-1"><a class="header-anchor" href="#formurlencoded" aria-hidden="true">#</a> @FormUrlEncoded</h3><p><code>@FormUrlEncoded</code> 注解标记HTTP接口方法，表示此HTTP请求体将使用表单URL编码，表单中的字段应声明为接口方法中的参数并使用 <code>@Field</code> 或 <code>@FieldMap</code> 注解标记。</p><blockquote><p>有关 <code>@Field</code> 或 <code>@FieldMap</code> 注解的使用，下篇文章我们再学习。</p></blockquote><p><strong>需要注意：</strong></p><blockquote><ol><li>被 <code>@FormUrlEncoded</code> 注解标记的HTTP接口方法发出的请求中将会自动填充 <code>application/x-www-form-urlencoded</code> MIME 类型，并且字段名和值将在 URI 编码之前进行 UTF-8 编码(<code>@Field</code> 和 <code>@FieldMap</code> 注解中的 <code>encoded</code> 属性为 false 时)，</li><li><code>@Field</code> 和 <code>@FieldMap</code> 注解仅能用于被 <code>@FormUrlEncoded</code> 注解标记的接口方法中。</li></ol></blockquote><h3 id="multipart" tabindex="-1"><a class="header-anchor" href="#multipart" aria-hidden="true">#</a> @Multipart</h3><p><code>@Multipart</code> 注解标记HTTP接口方法，表示此HTTP请求体有多个部分，每个部分应声明为接口方法中的参数并使用 <code>@Part</code> 或 <code>@PartMap</code> 注解标识。</p><blockquote><p>有关 <code>@Part</code> 或 <code>@PartMap</code> 注解的使用，下篇文章我们再学习。</p></blockquote><p><strong>需要注意：</strong></p><blockquote><ol><li>被 <code>@Multipart</code> 注解标注的HTTP接口方法发出的请求中将会自动填充 <code>multipart/form-data</code> MIME 类型，</li><li><code>@Part</code> 或 <code>@PartMap</code> 注解仅能用于被 <code>@Multipart</code> 注解标记的接口方法中。</li></ol></blockquote><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><ol><li>一个HTTP接口方法中的参数不能同时存在两个及相同类型的 <code>@Tag</code> 注解，</li><li>一个HTTP接口方法不能同时被 <code>@FormUrlEncoded</code> 和 <code>@Multipart</code> 注解标记，</li><li>一个HTTP接口方法中的参数不能同时存在 <code>@Field</code> 和 <code>@Part</code>，或者 <code>@FieldMap</code> 和 <code>@Part</code>，或者 <code>@Field</code> 和 <code>@PartMap</code>，以及 <code>@FileMap</code> 和 <code>@PartMap</code>，</li><li>非必要尽量不要使用 <code>@Streaming</code> 注解。</li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本文我们学习了 Retrofit 中关于请求方法和标记类型的注解以及它们的作用和一些使用注意事项，特别是我们对 <code>baseUrl</code> 和 <code>endpoint</code> 结合规则的学习，对我们如何编写正确的接口方法提供了标准并起到了指导作用：</p><ol><li><strong>尽量使用相对路径来拼接完整请求地址</strong>，</li><li><strong>尽量使用统一的 <code>baseUrl</code></strong>，</li></ol><p>希望可以帮你更好的使用 Retrofit。</p><p>那么，下篇再见啦，happy~</p>`,55);function h(m,g){const n=i("RouterLink");return t(),c("div",null,[u,e("p",null,[a("距 "),d(n,{to:"/SourceCodeAnalysis/Retrofit/6.%E5%8F%8D%E5%B0%84(%E4%B8%89).html"},{default:p(()=>[a("上一篇文章")]),_:1}),a(" 已过了差不多半年时间。之前我们学习了动态代理、泛型和反射的一些知识，那么本篇文章我们学习一下 Retrofit 中有哪些注解以及它们的作用，为我们后续正式学习 Retrofit 奠定基础。")]),k])}const v=o(r,[["render",h],["__file","7.annotation-part-1.html.vue"]]);export{v as default};
