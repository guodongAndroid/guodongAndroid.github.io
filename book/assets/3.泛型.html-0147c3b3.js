import{_ as t,Y as c,Z as a,$ as d,a0 as e,a1 as r,a2 as i,a3 as n,E as s}from"./framework-3d290349.js";const l={},h=d("h2",{id:"前言",tabindex:"-1"},[d("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),e(" 前言")],-1),p=n('<p><code>Retrofit</code> 灵活运用了动态代理技术为我们创建了优秀的 <code>http</code> 请求框架，可以说动态代理是 <code>Retrofit</code> 的灵魂与核心，但是在 <code>Retrofit</code> 中也大量使用了反射与泛型，所以今天我们主要学习下泛型的一些基础知识，为我们继续学习 <code>Retrofit</code> 打下知识储备。</p><h2 id="泛型概述" tabindex="-1"><a class="header-anchor" href="#泛型概述" aria-hidden="true">#</a> 泛型概述</h2><p>众所周知，Java 的泛型是伪泛型，其会在编译时被擦除，在运行时不存在任何与泛型类型相关的信息。我们常用的就是集合类型了，例如 <code>List&lt;String&gt;</code> 在运行时就只有 <code>List</code> 了。</p><p>泛型为我们提供了编译期的类型安全。</p><p>出于安全原因，泛型默认不支持型变，因此 Java 提供了通配符上限，通配符下限和无限定通配符。</p><h2 id="通配符上限-协变" tabindex="-1"><a class="header-anchor" href="#通配符上限-协变" aria-hidden="true">#</a> 通配符上限：协变</h2><p>在 Java 中使用 <code>extends</code> 关键字表示通配符上限。</p><p>如果 S 是 F 的子类，那么 <code>List&lt;S&gt;</code> 相当于是 <code>List&lt;? extends F&gt;</code> 的子类，比如 <code>Integer</code> 是 <code>Number</code> 的子类，那么 <code>List&lt;Integer&gt;</code> 相当于 <code>List&lt;? extends Number&gt;</code> 的子类，上述这种型变方式称为泛型的协变。</p><p>对于支持协变的泛型集合，我们只能从集合中取出元素，但是不能向集合中添加/修改元素( <code>null</code> 除外)，因为取出元素时可以保证元素的类型上限，而添加/修改元素时无法确定元素的具体类型。</p><p>因此，支持协变的泛型，一般只能返回元素，不能注入元素( <code>null</code> 除外)。</p><h2 id="通配符下限-逆变" tabindex="-1"><a class="header-anchor" href="#通配符下限-逆变" aria-hidden="true">#</a> 通配符下限：逆变</h2><p>在 Java 中使用 <code>super</code> 关键字表示通配符下限。</p><p>如果 S 是 F 的子类，那么 <code>List&lt;F&gt;</code> 反而相当于是 <code>List&lt;? super S&gt;</code> 的子类，比如 <code>Integer</code> 是 <code>Number</code> 的子类，那么 <code>List&lt;Number&gt;</code> 相当于 <code>List&lt;? super Integer&gt;</code> 的子类，上述这种型变方式称为泛型的逆变。</p><p>对于支持逆变的泛型集合，我们只能往集合中添加/修改元素，但是不能从集合中取出元素，因为添加/修改元素时可以保证元素的类型下限，而取出元素时无法确定元素的具体类型。</p><p>因此，支持逆变的泛型，一般只能注入元素，不能返回元素。</p><h2 id="无限定通配符" tabindex="-1"><a class="header-anchor" href="#无限定通配符" aria-hidden="true">#</a> 无限定通配符</h2><p>在 Java 中使用 <code>?</code> 关键字表示无限定通配符。无限定通配符一般用于在不确定具体类型时。</p><p>支持无限定通配符的泛型，一般只能返回元素，不能注入元素( <code>null</code> 除外)。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ol><li>泛型为我们提供了编译期的类型安全。</li><li>支持协变的泛型，一般只能返回元素，不能注入元素( <code>null</code> 除外)。</li><li>支持逆变的泛型，一般只能注入元素，不能返回元素。</li><li>支持无限定通配符的泛型，一般只能返回元素，不能注入元素( <code>null</code> 除外)。</li></ol>',20);function u(_,f){const o=s("RouterLink");return c(),a("div",null,[h,d("p",null,[e("在 "),r(o,{to:"/SourceCodeAnalysis/Retrofit/2.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html"},{default:i(()=>[e("上一篇文章")]),_:1}),e(" 中我们学习了代理相关的技术，知晓了代理有静态和动态之分，且静态代理与动态代理各有优劣，笔者也分享了自己的使用经验。")]),p])}const x=t(l,[["render",u],["__file","3.泛型.html.vue"]]);export{x as default};
