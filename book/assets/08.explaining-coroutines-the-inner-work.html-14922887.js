import{_ as n,Y as s,Z as a,a3 as e}from"./framework-3d290349.js";const t={},o=e(`<h1 id="分析协程内部工作逻辑" tabindex="-1"><a class="header-anchor" href="#分析协程内部工作逻辑" aria-hidden="true">#</a> 分析协程内部工作逻辑</h1><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span>userId<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span> <span class="token comment">// 1</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Fetching user&quot;</span></span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
    <span class="token function">print</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 3</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Fetched user&quot;</span></span><span class="token punctuation">)</span> <span class="token comment">// 4</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这并不是真正的黑魔法——只是一种使用低级处理方式的智能方法。<code>getUser</code> 被标记为可挂起的函数，这意味着系统准备在后台调用它，你将 会得到一个未完成的包装好的 “卷饼”。但它可能还没有被执行。系统会把它添加进线程池中，在线程池中它将等待执行。一旦你准备好吃 “卷饼” 并请求结果，程序就会阻塞，直到你立刻得到结果，或者在协程中挂起并等待结果。</p><p>明白了这一点后，程序就可以跳过其他的代码，直到程序走到使用 <code>user</code> 的第一行代码处。这称为<strong>等待结果</strong>。此时，将执行 <code>getUser</code>，如果 <code>getUser</code> 还没有执行，程序将挂起。</p><p>这意味着可以在调用 <code>getUser</code> 和使用其结果（user）之间做一些你想做的事。因为编译器知道挂起点和可挂起函数是异步的，并按顺序处理它们的执行，所以你可以编写易于理解和简洁的代码。这将使你的代码具有非常好的可扩展性且易于维护。</p><p>由于使用协程编写异步代码非常简单，所以你可以轻松组合多个请求或者数据转换。不需要其他的方式，不需要奇怪的流来映射传递数据，也不需要组合复杂的运算符或转换结果。你需要做的就是将函数标记为挂起函数，并在协程块中调用它们。</p><p>关于协程的另一件极其重要的事情是它们不是线程。协程利用线程池在多个现有线程之间混合工作。你创建数百万个协程，而不用担心内存溢出。一百万个线程会占用非常多的内存，即使是当今最先进的计算机也会因此而崩溃。</p><p>虽然很多语言已经支持了协程，但是它们的实现不尽相同。</p>`,8),p=[o];function c(i,l){return s(),a("div",null,p)}const u=n(t,[["render",c],["__file","08.explaining-coroutines-the-inner-work.html.vue"]]);export{u as default};
