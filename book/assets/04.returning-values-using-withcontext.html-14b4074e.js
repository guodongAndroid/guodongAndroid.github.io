import{_ as n,Y as s,Z as a,a3 as t}from"./framework-3d290349.js";const e={},p=t(`<p>现在您可以使用抽象的 API 在线程和调度器之间切换，是时候学习另外一个协程构建器：<code>withContext</code>。</p><p>它允许您通过挂起的方式从另一个 CoroutineContext 返回一个值。如前所述，您将在本书后面章节了解更多有关上下文的信息，但这是了解另一个有用的挂起函数比较好的切入点。</p><p>关于挂断函数和协程，其中有一个非常重要的点就是它们不会阻塞正在运行的线程。这意味着每当您在协程中并调用挂起函数时，它将暂停协程，而不是阻塞线程。我们已经讨论了几次，但让我们看看它在实践中是如何工作的。</p><p>将 <strong>Main.kt</strong> 的内容替换为以下代码：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 1</span>
        <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">getUserSuspend</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;101&quot;</span></span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
        <span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token comment">// 4</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 3</span>
<span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">getUserSuspend</span><span class="token punctuation">(</span>userId<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> User <span class="token operator">=</span>
	<span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Default<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
	    <span class="token function">User</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;Filip&quot;</span></span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码片段与您前面使用的非常相似，但是有一个比较大的区别。上面的代码处理线程和调度器的方式与前面的相反。</p><p>与其在后台启动协程，然后将数据再推送到主线程，不如执行相反的操作——在主线程上启动协程，然后将数据获取推送到后台。这种方式非常符合直觉，同时也展示了使用 <code>withContext</code> 桥接主线程和后台线程是多么容易。</p><p>上面代码片段的可能执行以下四个步骤：</p><ol><li>您在主线程启动了一个协程，同时将协程的作用域限定为主线程。</li><li>通过调用挂起函数，您可以释放主线程以进行其他工作，直到数据准备好了。</li><li>在 <code>getUserSuspend</code> 内，您使用 <code>withContext(Dispatchers.Default)</code> 来获取 <code>user</code>，同时确保本次操作运行在一个不同的后台线程。</li><li>当 <code>user</code> 数据返回时，您就可以输出它了。</li></ol><p>这确实展示了使用协程编写良好且顺序的代码非常容易，同时这些协程仍然可以顺利运行并且不会导致任何 UI 冻结。</p>`,10),o=[p];function c(i,l){return s(),a("div",null,o)}const r=n(e,[["render",c],["__file","04.returning-values-using-withcontext.html.vue"]]);export{r as default};
