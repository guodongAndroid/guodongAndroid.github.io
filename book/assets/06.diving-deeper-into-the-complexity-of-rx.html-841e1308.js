import{_ as e,Y as t,Z as x,a3 as o}from"./framework-3d290349.js";const p={},n=o('<h1 id="深入了解-rx-的复杂性" tabindex="-1"><a class="header-anchor" href="#深入了解-rx-的复杂性" aria-hidden="true">#</a> 深入了解 Rx 的复杂性</h1><p>由于这本书不是关于 Rx 的，所以本书只简单描述下它的优点和缺点，让你对它有个简单的了解。如上所述，Rx 使异步编程变得简洁易读。此外，抛开大量的数据处理操作符不谈，Rx 也是一种强大的技术，同时，Rx 对数据流中的错误处理机制也为应用程序增加了额外的安全性。</p><p>但 Rx 并不完美。 它与任何其他框架或范式一样存在问题，其中一些最近出现在编程社区中。</p><p>首先，Rx 有较高的学习曲线。当你开始学习 Rx 时，你必须学习一些额外的概念，比如观察者模式和数据流。你还会发现 Rx 不仅仅是一个框架； 它带来了一种称为响应式编程的全新范式。正因如此，开始使用 Rx 时会感到非常困难。但更难掌握的是如何使用其大量的运算符。运算符的数量、线程调度的类型以及两者之间的组合，创造了如此多的选项，以至于几乎不可能知道 Rx 的全部范围。</p><p>使用 Rx 的另一个问题是“炒作”。 多年来，人们已经将 Rx 作为异步操作的灵丹妙药。</p><p>这最终导致这种编程是 Rx 驱动的，甚至给现有应用程序带来了更多的复杂性。 寻找变通方法并使用众多设计模式，只是为了让 Rx 工作，引入了不必要的复杂性的新问题。 正因如此，在 Android 中，Rx 社区一直在争论程序员是否应该将诸如网络请求之类的东西表示为数据流，而不是他们可以使用回调或更简单的方式处理的单个事件。</p><p>例如，同样的辩论过渡到导航事件。 程序员也应该将点击表示为事件流吗？ 在这个话题上，社区意见分歧很大。</p><p>幸运的是，在 Kotlin 中 Rx 并不是处理可观察流的唯一方法。在 Kotlin 中有一个相同行为的新技术和框架，其方式比 Rx 简单得多，它就是 Flows。 你将在本书后面部分了解有关 Flows 的更多信息！</p><p>那么，考虑上述问题，是否有更好或更简单的方法来处理异步呢？ 奇怪的是，有一个可以追溯到几十年前的概念，最近成为热门话题。</p>',9),r=[n];function i(a,c){return t(),x("div",null,r)}const s=e(p,[["render",i],["__file","06.diving-deeper-into-the-complexity-of-rx.html.vue"]]);export{s as default};
