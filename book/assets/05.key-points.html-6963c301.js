import{_ as e,Y as o,Z as i,a3 as l}from"./framework-3d290349.js";const c={},t=l("<ul><li>将回调作为提供结果值的一种方式可能非常难看，而且学习成本较高。</li><li>协程和挂起函数摒弃了回调并且减少了过多的线程分配。</li><li>将普通函数与可挂起函数区分开的是作为一等公民的 <code>Continuation</code>，协程 API 会在内部使用它。</li><li>在系统中也有续体，它们被用于处理函数生命周期 —— 返回值，在代码中跳转和更新调用栈。</li><li>当系统需要浏览调用堆栈时，您可以将续体视为系统调用的低级回调。</li><li>在函数被调用时续体总是会持久化一些关于上下文的信息 —— 传递的参数、调用点和返回类型。</li><li>续体可以解决的三种主要方式：在 <code>happy path</code> 下如函数期望一样返回数据，在其他情况下会抛出异常，如果业务逻辑有Bug会导致无限阻塞。</li><li>利用 <code>suspend</code> 修饰符以及 <code>launch</code> 和 <code>suspendCoroutine</code> 之类的函数，您可以创建自己的 API。</li><li><code>withContext</code> 是在桥接主线程和后台线程的同时编写简洁与顺序代码一种很好的方式。</li></ul>",1),n=[t];function d(s,_){return o(),i("div",null,n)}const r=e(c,[["render",d],["__file","05.key-points.html.vue"]]);export{r as default};
