import{_ as n,Y as s,Z as a,a3 as t}from"./framework-3d290349.js";const p={},e=t(`<p>之前我们提到 Jetbrains 为 Coroutines API 考虑的一件事是可扩展性。在前面的章节您已经看到如何把自己的函数转换为可挂起的，现在您可以做的另外一件事就是创建一些类似 API 的实用功能，它们可以隐藏线程和上下文切换逻辑。</p><p>我们在 <strong>Api.kt</strong> 中为您准备了一些示例。打开它您将看到一些函数，我们将逐一介绍它们。</p><p>第一个是一个比较方便的函数，它使用 <code>suspendCoroutine</code> 和 <code>Result&#39;s runCatching</code> 来尝试处理一个数据，并最后返回给您。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T <span class="token operator">:</span> Any<span class="token operator">&gt;</span> <span class="token function">getValue</span><span class="token punctuation">(</span>provider<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> T<span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span>
	suspendCoroutine <span class="token punctuation">{</span> continuation <span class="token operator">-&gt;</span>
		continuation<span class="token punctuation">.</span><span class="token function">resumeWith</span><span class="token punctuation">(</span>Result<span class="token punctuation">.</span><span class="token function">runCatching</span> <span class="token punctuation">{</span> <span class="token function">provider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果您要在代码中的某处调用此函数，它会看起来像下面这样：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> user <span class="token operator">=</span> getValue <span class="token punctuation">{</span> <span class="token function">getUserFromNetwork</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;101&quot;</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这可以帮助您抽象出所有尝试通过以下方式获取数据的逻辑：</p><ol><li>网络访问，</li><li>文件读取，</li><li>数据库查找等。</li></ol><p>并将它们切换至后台线程执行。如此主线程只需处理渲染数据，其余代码仅仅获取渲染数据即可。</p><p>下面两个示例非常简单，但它们对线程切换非常有用：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">executeBackground</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token keyword">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">executeMain</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token keyword">suspend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span>context <span class="token operator">=</span> Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个函数需要传入一个 <code>action</code> lambda 代码块，并且使用 <code>launch</code> 默认的上下文将它运行在后台线程。第二个函数同样需要传入 <code>action</code> lambda 代码块，但是它使用 <code>Dispatchers.Main</code> 上下文，所以您可以轻松的切换到主线程，并且不知道任何实现细节。</p><p>您可能会像下面这样使用它们：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>executeBackground <span class="token punctuation">{</span>
    <span class="token keyword">val</span> user <span class="token operator">=</span> getValue <span class="token punctuation">{</span> <span class="token function">getUserFromNetwork</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;101&quot;</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    executeMain <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述方法的命名是一个很好的例子，您可以理解它背后的意图。现在您拥有和 <code>GlobalScope.launch</code> 代码块相关的行为，但是您不必了解在这背后使用了哪个作用域以及哪个函数。</p><p>这在您构建基础业务逻辑层时非常有用，因为您可以提供主线程上下文和后台线程上下文以及运行函数的范围。并且在具体的实现，或者 <code>base presenter</code> 的子类，<code>view model</code> 或 <code>controller</code> 中，您只需调用这些函数，然后让该层的核心部分去处理线程。</p><p>根据您的需要，尽可能多的使用它们并在它们之上构建更多实用功能。</p>`,17),o=[e];function c(i,l){return s(),a("div",null,o)}const r=n(p,[["render",c],["__file","03.creating-your-own-suspendable-api.html.vue"]]);export{r as default};
